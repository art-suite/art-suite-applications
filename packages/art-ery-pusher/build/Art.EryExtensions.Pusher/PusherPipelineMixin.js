"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["subscribeToChanges", "session", "verboseLog", "log", "missing"], [global, require('./StandardImport'), require('./Lib'), require('art-communication-status')], (subscribeToChanges, session, verboseLog, log, missing) => {return function(superClass) {let PusherPipelineMixin; return PusherPipelineMixin = Caf.defClass(class PusherPipelineMixin extends superClass {constructor() {super(...arguments); this._pusherQuerySubscriptions = {}; this._pusherSubscriptions = {};};}, function(PusherPipelineMixin, classSuper, instanceSuper) {Caf.isF(this.abstractClass) && this.abstractClass(); this.prototype.getModelNamesAndKeysToUpdateOnRecordChange = function(updatedRecord) {return Caf.object(this.queries, (pipelineQuery) => pipelineQuery.toKeyString(updatedRecord));}; this.filter(require('./PusherFilter')); this.prototype.subscriberAdded = function(key, subscriber, queryName) {let temp, base; ((temp = (base = this._getQueryNamePusherSubscriptions(queryName))[key]) != null ? temp : base[key] = subscribeToChanges(queryName != null ? queryName : this.name, key, (pusherData) => this._processPusherChangedEvent(pusherData, key, queryName))); return instanceSuper.subscriberAdded.apply(this, arguments);}; this.prototype.subscriberRemoved = function(key, subscriber, queryName) {let subscriptions, base; subscriptions = this._getQueryNamePusherSubscriptions(queryName); Caf.exists(base = subscriptions[key]) && base.unsubscribe(); delete subscriptions[key]; return instanceSuper.subscriberRemoved.apply(this, arguments);}; this.prototype._getQueryNamePusherSubscriptions = function(queryName) {let temp, base; return queryName ? ((temp = (base = this._pusherQuerySubscriptions)[queryName]) != null ? temp : base[queryName] = {}) : this._pusherSubscriptions;}; this.prototype._processPusherChangedEvent = function(event, channelKey, queryName) {let key, sender, updatedAt, type, error; key = event.key; sender = event.sender; updatedAt = event.updatedAt; type = event.type; return (() => {try {return (() => {switch (type) {case "create": case "update": return (sender === session.data.artEryPusherSession) ? verboseLog({_processPusherChangedEvent: `saved 1 reload due to sender check! We are the ones who caused the event. (pipeline: ${Caf.toString(this.name)}, key: ${Caf.toString(key)})`}) : this.get(key).then((data) => this._sendDataSubscriptionEventSingle("update", key, data, queryName), (errorResponse) => (errorResponse.status === missing) ? this._sendDataSubscriptionEventSingle("delete", key, null, queryName) : log({key, errorResponse})); case "delete": verboseLog({_processPusherChangedEvent: {sendingDataDeletedEventToLocalSubscribers: {name: this.name, key, queryName}}}); return this._sendDataSubscriptionEventSingle("delete", key, null, queryName); default: return log.error(`PusherFluxModelMixin: _processPusherChangedEvent: unsupported type: ${Caf.toString(type)}`, {event});};})();} catch (error1) {error = error1; log({_processPusherChangedEvent: {error}}); return (() => {throw error;})();};})();};});};});});
//# sourceMappingURL=PusherPipelineMixin.js.map
