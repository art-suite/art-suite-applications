// Generated by CoffeeScript 1.12.7
(function() {
  var Config, Pusher, activeSubscriptions, config, defineModule, log, merge, ref, session,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./StandardImport'), defineModule = ref.defineModule, log = ref.log, merge = ref.merge;

  config = (Config = require('./Config')).config;

  session = require('art-ery').session;

  Pusher = require('./namespace');

  activeSubscriptions = Pusher.activeSubscriptions = {};

  Pusher.logActiveSubscriptions = function() {
    return log({
      activeSubscriptions: Object.keys(activeSubscriptions).sort()
    });
  };

  defineModule(module, function() {
    return function(superClass) {
      var PusherFluxModelMixin;
      return PusherFluxModelMixin = (function(superClass1) {
        extend(PusherFluxModelMixin, superClass1);

        function PusherFluxModelMixin() {
          this._processPusherChangedEvent = bind(this._processPusherChangedEvent, this);
          PusherFluxModelMixin.__super__.constructor.apply(this, arguments);
          this._channels = {};
          this._listeners = {};
        }

        PusherFluxModelMixin.prototype.fluxStoreEntryUpdated = function(arg) {
          var key, subscribers;
          key = arg.key, subscribers = arg.subscribers;
          if (subscribers.length > 0) {
            this._subscribe(key);
          }
          return PusherFluxModelMixin.__super__.fluxStoreEntryUpdated.apply(this, arguments);
        };

        PusherFluxModelMixin.prototype.fluxStoreEntryRemoved = function(arg) {
          var key;
          key = arg.key;
          this._unsubscribe(key);
          return PusherFluxModelMixin.__super__.fluxStoreEntryRemoved.apply(this, arguments);
        };

        PusherFluxModelMixin.prototype._getPusherChannel = function(key) {
          return Config.getPusherChannel(this.name, key);
        };

        PusherFluxModelMixin.prototype._subscribe = function(key) {
          var base, pusherClient, pusherEventName;
          pusherEventName = config.pusherEventName;
          pusherClient = Config.pusherClient;
          if (!pusherClient) {
            return;
          }
          (base = this._channels)[key] || (base[key] = pusherClient.subscribe(this._getPusherChannel(key)));
          if (!this._listeners[key]) {
            activeSubscriptions[this.name + " " + key] = true;
            return this._channels[key].bind(pusherEventName, this._listeners[key] = (function(_this) {
              return function(pusherData) {
                return _this._processPusherChangedEvent(pusherData, key);
              };
            })(this));
          }
        };

        PusherFluxModelMixin.prototype._unsubscribe = function(key) {
          var pusherClient, pusherEventName, ref1;
          pusherEventName = config.pusherEventName;
          pusherClient = Config.pusherClient;
          if (!(pusherClient && this._channels[key])) {
            return;
          }
          if (this._listeners[key]) {
            if ((ref1 = this._channels[key]) != null) {
              ref1.unbind(pusherEventName, this._listeners[key]);
            }
            delete this._listeners[key];
          }
          delete activeSubscriptions[this.name + " " + key];
          pusherClient.unsubscribe(this._getPusherChannel(key));
          return delete this._channels[key];
        };

        PusherFluxModelMixin.prototype._processPusherChangedEvent = function(event, channelKey) {
          var fluxRecord, key, model, sender, type, updatedAt;
          key = event.key, sender = event.sender, updatedAt = event.updatedAt, type = event.type;
          model = this.recordsModel || this;
          switch (type) {
            case "create":
            case "update":
              if (sender === session.data.artEryPusherSession) {
                log("saved 1 reload due to sender check! (model: " + this.name + ", key: " + key + ")");
                return;
              }
              if ((fluxRecord = model.fluxStoreGet(key)) && fluxRecord.updatedAt >= updatedAt) {
                log("saved 1 reload due to updatedAt check! (model: " + this.name + ", key: " + key + ")");
                return;
              }
              return model.loadPromise(key);
            case "delete":
              model.dataDeleted(key);
              return this.dataDeleted(channelKey, key);
            default:
              return log.error("PusherFluxModelMixin: _processPusherChangedEvent: unsupported type: " + type, {
                event: event
              });
          }
        };

        return PusherFluxModelMixin;

      })(superClass);
    };
  });

}).call(this);

//# sourceMappingURL=PusherFluxModelMixin.js.map
