"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Filter", "Config", "log", "isString", "Promise", "cryptoRandomString", "merge"], [global, require('./StandardImport'), {Config: require('./Config')}], (Filter, Config, log, isString, Promise, cryptoRandomString, merge) => {let sendChanged, PusherFilter; sendChanged = function(pipeline, key, payload) {let config, pusherEventName, channel, base; config = Config.config; pusherEventName = config.pusherEventName; channel = Config.getPusherChannel(pipeline, key); if (config.verbose) {log({sendChanged: {channel, pusherEventName, payload}});}; return Caf.exists(base = Config.pusherServer) && base.trigger(channel, pusherEventName, payload || {});}; return PusherFilter = Caf.defClass(class PusherFilter extends Filter {}, function(PusherFilter, classSuper, instanceSuper) {let afterFilter; this.prototype.initArtEryPusherSession = function(response) {return isString(response.session.artEryPusherSession) ? Promise.resolve(response) : response.withMergedSession({artEryPusherSession: cryptoRandomString(12)});}; this.prototype.notifyAllQueriesWhichMayNeedUpdating = function(pipeline, payload, data) {return Caf.each2(pipeline.getChannelsAndKeysToUpdateOnRecordChange(data), (key, queryName) => (key != null) ? sendChanged(queryName, key, payload) : undefined);}; this.prototype.notifySingleRecordWhichNeedsUpdating = function(pipeline, payload, data) {return sendChanged(pipeline, data, payload);}; this.after({create: afterFilter = function(response) {return this.initArtEryPusherSession(response).tap((response) => Promise.then(() => {let type, key, data, request, pipeline, artEryPusherSession, payload; type = response.type; key = response.key; data = response.data; request = response.request; pipeline = response.pipeline; artEryPusherSession = response.session.artEryPusherSession; data = merge(request.data, data, key && pipeline.toKeyObject(key)); payload = {type, sender: artEryPusherSession, key: key || pipeline.toKeyString(data)}; if (data.updatedAt) {payload.updatedAt = data.updatedAt;}; this.notifyAllQueriesWhichMayNeedUpdating(pipeline, payload, data); return !(type === "create") ? this.notifySingleRecordWhichNeedsUpdating(pipeline, payload, data) : undefined;}));}, update: afterFilter, delete: afterFilter});});});});
//# sourceMappingURL=PusherFilter.js.map
