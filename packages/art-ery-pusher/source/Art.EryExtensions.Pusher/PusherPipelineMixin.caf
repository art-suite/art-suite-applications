import &StandardImport, &Lib, &ArtCommunicationStatus

(superClass) -> class PusherPipelineMixin extends superClass
  @abstractClass?()

  constructor: ->
    @_pusherQuerySubscriptions = {}
    @_pusherSubscriptions = {}

  @filter &PusherFilter

  ## subscriberAdded - override to get notified
  subscriberAdded: (key, subscriber, queryName) ->
    @_getQueryNamePusherSubscriptions(queryName)[key] ?= subscribeToPusherChangeEvents
      @name
      queryName
      key
      (pusherData) -> @_processPusherChangedEvent pusherData, key, queryName

    super

  ## subscriberRemoved - override to get notified
  subscriberRemoved: (key, subscriber, queryName) ->
    subscriptions = @_getQueryNamePusherSubscriptions(queryName)
    subscriptions[key]?.unsubscribe()
    delete subscriptions[key]
    super

  ####################
  # PRIVATE
  ####################
  _getQueryNamePusherSubscriptions: (queryName) ->
    if queryName then @_pusherQuerySubscriptions[queryName] ?= {}
    else              @_pusherSubscriptions

  _processPusherChangedEvent: (event, channelKey, queryName) ->
    event extract key, sender, type

    switch type
    when :create :update
      if sender == session.data.artEryPusherSession
        verboseLog _processPusherChangedEvent: "" saved 1 reload due to sender check! We are the ones who caused the event. (pipeline: #{@name}, key: #{key})

      else
        # Get updated data
        # FUTURE: wouldn't it be nice if the pusher event contained "data" so we didn't have to fetch it?
        @get key
        .then
          (data) -> @_sendDataSubscriptionEventSingle :update key, data
          (errorResponse) ->
            if errorResponse.status == missing
              @_sendDataSubscriptionEventSingle :delete key, null
            else log.error {}
              message: "" Error fetching updated record.
              key, errorResponse

    when :delete
      verboseLog _processPusherChangedEvent: sendingDataDeletedEventToLocalSubscribers: {} @name, key, queryName

      # NOTE: queries get their own update messages, so we don't need the data
      @_sendDataSubscriptionEventSingle :delete key, null

    else log.error "PusherPipelineMixin: _processPusherChangedEvent: unsupported type: #{formattedInspect type}", {event}
