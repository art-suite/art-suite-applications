import &StandardImport, {} &Config

## sendChanged
  IN:
    pipeline: pipeline-name string or pipeline
  OUT:
    true if pusher event was actually sent
    else false-ish
sendChanged = (pipeline, key, payload) ->
  Config extract config extract pusherEventName

  channel = Config.getPusherChannel pipeline, key

  if config.verbose
    log sendChanged: {} channel, pusherEventName, pipeline, key, payload, Config.pusherServer

  if Config.pusherServer?
    Config.pusherServer.trigger channel, pusherEventName, payload || {}
    true

class PusherFilter extends Filter

  initArtEryPusherSession: (response) ->
    if isString response.session.artEryPusherSession
      Promise.resolve response
    else
      response.withMergedSession
        artEryPusherSession: cryptoRandomString 12 # should produce > 10^21 unique values

  notifyAllQueriesWhichMayNeedUpdating: (pipeline, payload, data)->
    each key, queryName in pipeline.getChannelsAndKeysToUpdateOnRecordChange data
      sendChanged queryName, key, payload if key?

  notifySingleRecordWhichNeedsUpdating: (pipeline, payload, data) ->
    sendChanged pipeline, data, payload

  @group "outer"

  @after
    create: afterFilter = (response) ->
      @initArtEryPusherSession response
      .tap (response) ->
        Promise.then ->
          response extract type, key, data, request, pipeline, session.artEryPusherSession
          data = merge
            request.data
            data
            key && pipeline.toKeyObject key

          payload = {}
            type
            sender:   artEryPusherSession
            key:      key || pipeline.toKeyString data

          payload.updatedAt = data.updatedAt if data.updatedAt

          @notifyAllQueriesWhichMayNeedUpdating pipeline, payload, data

          # record updated notification - no need to send on 'create' because no-one will be listening.
          unless type == :create
            @notifySingleRecordWhichNeedsUpdating pipeline, payload, data

    update: afterFilter
    delete: afterFilter
