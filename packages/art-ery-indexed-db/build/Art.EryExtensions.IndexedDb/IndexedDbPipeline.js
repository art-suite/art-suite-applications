"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["KeyFieldsMixin", "UpdateAfterMixin", "Pipeline", "pipelines", "withSort", "compare", "merge"], [global, require('./StandardImport')], (KeyFieldsMixin, UpdateAfterMixin, Pipeline, pipelines, withSort, compare, merge) => {let IndexedDb, globalIndexDb, getGlobalIndexDb, IndexedDbPipeline; IndexedDb = require('indexeddb-promised'); globalIndexDb = null; getGlobalIndexDb = function() {let dbVersion, dbName; if (!globalIndexDb) {dbVersion = 0; dbName = null; Caf.each2(pipelines, (pipeline) => {dbVersion += pipeline.dbVersion || 1; return dbName || (dbName = pipeline.dbName);}, (pipeline) => pipeline instanceof IndexedDbPipeline); globalIndexDb = new IndexedDb(dbName || (dbName = "IndexedDbPipeline")); globalIndexDb.setVersion(dbVersion); Caf.each2(pipelines, (pipeline) => {let name, _indexes, keyType, indexes; ({name} = pipeline); ({_indexes} = pipeline.class); keyType = {keyPath: "id"}; indexes = _indexes ? Caf.array(_indexes, (indexKey, queryModelName) => {let selectBy, orderBy; ([selectBy, orderBy] = indexKey.split("/")); return {name: queryModelName, keyPath: [selectBy, orderBy], options: {unique: false}};}) : undefined; return globalIndexDb.addObjectStore({dbVersion, dbName, name, keyType, indexes});}, (pipeline) => pipeline instanceof IndexedDbPipeline); globalIndexDb = globalIndexDb.build();}; return globalIndexDb;}; return IndexedDbPipeline = Caf.defClass(class IndexedDbPipeline extends KeyFieldsMixin(UpdateAfterMixin(Pipeline)) {}, function(IndexedDbPipeline, classSuper, instanceSuper) {this.abstractClass(); this.getter({objectStore: function() {return this._objectStore || (this._objectStore = getGlobalIndexDb()[this.pipelineName]);}}); this.indexes = function(indexes) {this._indexes = indexes; return this.query(this._getAutoDefinedQueries(indexes));}; this._getAutoDefinedQueries = function(indexes) {let queries; queries = {}; Caf.each2(indexes, (indexKey, queryModelName) => {let selectBy, orderBy, whereClause; ([selectBy, orderBy] = indexKey.split("/")); whereClause = {}; return queries[queryModelName] = {query: (request) => {let key; ({key} = request); return request.pipeline.objectStore.getAll().then((items) => Caf.array(items, null, (item) => item[selectBy] === key));}, dataToKeyString: (data) => data[selectBy], localSort: (queryData) => withSort(queryData, (a, b) => {let ret; return (0 === (ret = compare(a[orderBy], b[orderBy]))) ? compare(a.id, b.id) : ret;})};}); return queries;}; this.handlers({get: function(request) {return this.objectStore.get(request.key);}, getAll: function(request) {return this.objectStore.getAll();}, create: function(request) {return this.objectStore.add(request.data).then(() => request.data);}, update: function(request) {return this.objectStore.get(request.key).then((oldData) => {let newData; return this.objectStore.put(newData = merge(oldData, request.data)).then(() => newData);});}, delete: function(request) {return this.objectStore.get(request.key).then((oldData) => this.objectStore.delete(request.key).then(() => oldData));}});});});});
//# sourceMappingURL=IndexedDbPipeline.js.map
