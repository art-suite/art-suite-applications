"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["KeyFieldsMixin", "UpdateAfterMixin", "Pipeline", "withSort", "compare", "merge"], [global, require('./StandardImport')], (KeyFieldsMixin, UpdateAfterMixin, Pipeline, withSort, compare, merge) => {let IndexedDb, globalIndexDb, getGlobalIndexDb, IndexedDbPipeline; IndexedDb = require('indexeddb-promised'); globalIndexDb = {}; getGlobalIndexDb = function({pipelines, uniqueName}) {let dbVersion, dbName, indexDb; if (!globalIndexDb[uniqueName]) {dbVersion = 0; dbName = null; Caf.each2(pipelines, (pipeline) => {let temp; dbVersion += ((temp = pipeline.dbVersion) != null ? temp : 1); return dbName != null ? dbName : dbName = pipeline.dbName;}, (pipeline) => pipeline instanceof IndexedDbPipeline); indexDb = new IndexedDb(dbName != null ? dbName : dbName = "IndexedDbPipeline"); indexDb.setVersion(dbVersion); Caf.each2(pipelines, (pipeline) => {let name, _indexes, keyType, indexes; name = pipeline.name; _indexes = pipeline.class._indexes; keyType = {keyPath: "id"}; indexes = _indexes ? Caf.array(_indexes, (indexKey, queryModelName) => {let selectBy, orderBy; ([selectBy, orderBy] = indexKey.split("/")); return {name: queryModelName, keyPath: [selectBy, orderBy], options: {unique: false}};}) : undefined; return indexDb.addObjectStore({dbVersion, dbName, name, keyType, indexes});}, (pipeline) => pipeline instanceof IndexedDbPipeline); globalIndexDb[uniqueName] = indexDb.build();}; return globalIndexDb[uniqueName];}; return IndexedDbPipeline = Caf.defClass(class IndexedDbPipeline extends KeyFieldsMixin(UpdateAfterMixin(Pipeline)) {}, function(IndexedDbPipeline, classSuper, instanceSuper) {this.abstractClass(); this.getter({objectStore: function() {let temp; return ((temp = this._objectStore) != null ? temp : this._objectStore = getGlobalIndexDb(this.getRegistry())[this.pipelineName]);}}); this.indexes = function(indexes) {this._indexes = indexes; return this.query(this._getAutoDefinedQueries(indexes));}; this._getAutoDefinedQueries = function(indexes) {let queries; queries = {}; Caf.each2(indexes, (indexKey, queryModelName) => {let selectBy, orderBy, whereClause; ([selectBy, orderBy] = indexKey.split("/")); whereClause = {}; return queries[queryModelName] = {query: (request) => {let key; ({key} = request); return request.pipeline.objectStore.getAll().then((items) => Caf.array(items, null, (item) => item[selectBy] === key));}, dataToKeyString: (data) => data[selectBy], localSort: (queryData) => withSort(queryData, (a, b) => {let ret; return (0 === (ret = compare(a[orderBy], b[orderBy]))) ? compare(a.id, b.id) : ret;})};}); return queries;}; this.handlers({get: function(request) {return this.objectStore.get(request.key).then((ret) => ret && merge(ret));}, getAll: function(request) {return this.objectStore.getAll();}, create: function(request) {return this.objectStore.add(request.data).then(() => request.data);}, update: function(request) {return this.objectStore.get(request.key).then((oldData) => {let newData; return this.objectStore.put(newData = merge(oldData, request.data)).then(() => newData);});}, delete: function(request) {return this.objectStore.get(request.key).then((oldData) => this.objectStore.delete(request.key).then(() => merge(oldData)));}});});});});
//# sourceMappingURL=IndexedDbPipeline.js.map
