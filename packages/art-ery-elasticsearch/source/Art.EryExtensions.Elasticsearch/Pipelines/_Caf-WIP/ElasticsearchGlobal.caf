import &ArtStandardLib, &ArtClassSystem, &ArtEry, &ElasticsearchConfig, &ArtAws, &ArtCommunicationStatus

class ElasticsearchGlobal extends &ElasticsearchPipelineBase

  ##
    using @fields, generate the correct 'mappings' data for initializing the ElasticsearchPipelines index
    SEE:
      https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html
      https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html

    OUT: plain data-structue that is exactly what you can PUT to
      elasticsearch to initialize all mappings for the current elasticsearchPipelines.
  @getElasticsearchMappings: ->
    {}
      settings = {}
      mappings: object pipeline from elasticsearchPipelines when pipeline is ElasticsearchPipeline with-key pipeline.elasticsearchType
        mapping = pipeline.getMapping()
        if mapping.settings
          mergeInto settings, mapping.settings
          objectWithout mapping, :settings
        else mapping

  @handlers
    initialize: (request) ->
      request.subrequest request.pipeline, :indexExists"
      .then
        (exists) ->
          unless exists
            @normalizeJsonRestClientResponse request, @restClient.putJson @getIndexUrl(), @class.getElasticsearchMappings()
          else status: :alreadyInitialized

    getInitializeParams: (request) -> return @class.getElasticsearchMappings()

    getIndicies: (request) -> @restClient.getJson "/*"

    indexExists: (request) ->
      @restClient.getJson @getIndexUrl()
      .then -> request.success data: true
      .catch (e) ->
        if e.status == missing then request.success data: false
        else @normalizeJsonRestClientError request, e

    createIndex: (request) -> @normalizeJsonRestClientResponse request, @restClient.putJson @getIndexUrl()

    deleteIndex: (request) ->
      @request.require request.data?.force "" data.force=true required
      .then -> @normalizeJsonRestClientResponse request, @restClient.deleteJson @getIndexUrl()

##
  /* 506 */
  /*!************************************************************************************************************!*\
    !*** ../art-ery-elasticsearch/source/Art.EryExtensions.Elasticsearch/Pipelines/ElasticsearchGlobal.coffee ***!
    \************************************************************************************************************/
  /*! no static exports found */
  /***/ (function(module, exports, __webpack_require__) {

  /* WEBPACK VAR INJECTION */(function(module) {var Aws4RestClient, DeclarableMixin, ElasticsearchGlobal, ElasticsearchPipeline, Pipeline, array, config, defineModule, formattedInspect, log, merge, mergeInto, missing, object, objectWithout, pipelines, ref, ref1,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = __webpack_require__(/*! art-standard-lib */ 51), formattedInspect = ref.formattedInspect, log = ref.log, defineModule = ref.defineModule, merge = ref.merge, array = ref.array, object = ref.object, objectWithout = ref.objectWithout, mergeInto = ref.mergeInto;

  DeclarableMixin = __webpack_require__(/*! art-class-system */ 128).DeclarableMixin;

  ref1 = __webpack_require__(/*! art-ery */ 252), Pipeline = ref1.Pipeline, pipelines = ref1.pipelines;

  config = __webpack_require__(/*! ../ElasticsearchConfig */ 507).config;

  Aws4RestClient = __webpack_require__(/*! art-aws */ 409).Aws4RestClient;

  missing = __webpack_require__(/*! art-foundation */ 121).CommunicationStatus.missing;

  ElasticsearchPipeline = __webpack_require__(/*! ./ElasticsearchPipeline */ 508);

  defineModule(module, ElasticsearchGlobal = (function(superClass) {
    extend(ElasticsearchGlobal, superClass);

    function ElasticsearchGlobal() {
      return ElasticsearchGlobal.__super__.constructor.apply(this, arguments);
    }


    /*
    using @fields, generate the correct 'mappings' data for initializing the ElasticsearchPipelines index
    SEE:
      https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html
      https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html

    OUT: plain data-structue that is exactly what you can PUT to
      elasticsearch to initialize all mappings for the current elasticsearchPipelines.
    */

    ElasticsearchGlobal.getElasticsearchMappings = function() {
      var elasticsearchPipelines, settings;
      elasticsearchPipelines = array(pipelines, {
        when: function(v) {
          return v instanceof ElasticsearchPipeline;
        }
      });
      settings = {};
      return {
        mappings: object(elasticsearchPipelines, {
          key: function(pipeline) {
            return pipeline.elasticsearchType;
          },
          "with": function(pipeline) {
            var mapping;
            mapping = pipeline.getMapping();
            if (mapping.settings) {
              mergeInto(settings, mapping.settings);
              return objectWithout(mapping, "settings");
            } else {
              return mapping;
            }
          }
        }),
        settings: settings
      };
    };

    ElasticsearchGlobal.handlers({
      initialize: function(request) {
        return request.subrequest(request.pipeline, "indexExists").then((function(_this) {
          return function(exists) {
            if (!exists) {
              return _this.normalizeJsonRestClientResponse(request, _this.restClient.putJson(_this.getIndexUrl(), _this["class"].getElasticsearchMappings()));
            } else {
              return {
                status: "alreadyInitialized"
              };
            }
          };
        })(this));
      },
      getInitializeParams: function(request) {
        return this["class"].getElasticsearchMappings();
      },
      getIndicies: function(request) {
        return this.restClient.getJson("/*");
      },
      indexExists: function(request) {
        return this.restClient.getJson(this.getIndexUrl()).then(function() {
          return request.success({
            data: true
          });
        })["catch"]((function(_this) {
          return function(e) {
            if (e.status === missing) {
              return request.success({
                data: false
              });
            } else {
              return _this.normalizeJsonRestClientError(request, e);
            }
          };
        })(this));
      },
      createIndex: function(request) {
        return this.normalizeJsonRestClientResponse(request, this.restClient.putJson(this.getIndexUrl()));
      },
      deleteIndex: function(request) {
        var ref2;
        return request.require((ref2 = request.data) != null ? ref2.force : void 0, "data.force=true required").then((function(_this) {
          return function() {
            return _this.normalizeJsonRestClientResponse(request, _this.restClient.deleteJson(_this.getIndexUrl()));
          };
        })(this));
      }
    });

    return ElasticsearchGlobal;

  })(__webpack_require__(/*! ./ElasticsearchPipelineBase */ 509)));

  /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/module.js */ 1)(module)))

  /***/ }),