"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseClass", "log", "CanvasPathSetTag", "merge", "toInspectedObjects", "rect", "commandArrayType", "valueArrayType", "Error", "parseFloat", "XbdTag", "isArray", "formattedInspect"], [global, require('./StandardImport')], (BaseClass, log, CanvasPathSetTag, merge, toInspectedObjects, rect, commandArrayType, valueArrayType, Error, parseFloat, XbdTag, isArray, formattedInspect) => {let CanvasPathSet; return CanvasPathSet = Caf.defClass(class CanvasPathSet extends BaseClass {constructor(a) {super(...arguments); this.paths = (a instanceof XbdTag) ? this._initFromXbd(a) : isArray(a) ? a : (a != null) ? (() => {throw new Error(`unsupported type constructing CanvasPathSet: ${Caf.toString(formattedInspect(a))}`);})() : [];};}, function(CanvasPathSet, classSuper, instanceSuper) {this.property("aspectRatio", "name"); this.getter({aspectRatio: function() {let temp; return ((temp = this._aspectRatio) != null ? temp : 1);}}); this.prototype.applyPath = function(context, where) {log.warn("DEPRICATED: Art.CanvasPath.applyPath - use applyRawPath"); return this.applyRawPath(context, where);}; this.prototype.applyRawPath = function(context, size) {return Caf.each2(this.paths, (path) => path.applyRawPath(context, size));}; this.getter({xbd: function() {return CanvasPathSetTag(merge({aspectRatio: (this.aspectRatio !== 1) ? this.aspectRatio : undefined, name: this.name}), Caf.array(this.paths, (path) => path.xbd));}, inspectedObjects: function() {return {CanvasPathSet: toInspectedObjects(this.paths)};}, drawArea: function() {return Caf.reduce(this.paths, (area, p) => p.drawArea.unionInto(area), null, rect());}, flattened: function() {let totalCommands, totalPointValues, totalRadii, _commands, _points, _radii, ci, pi, ri; totalCommands = totalPointValues = totalRadii = 0; Caf.each2(this.paths, ({commands, radii, points, normalized}, i) => {if (!normalized) {throw new Error(`Path not normalized (i=${Caf.toString(i)})`);}; if (commands) {totalCommands += commands.length;}; if (points) {totalPointValues += points.length;}; return radii ? totalRadii += radii.length : undefined;}); if (totalCommands > 0) {_commands = new commandArrayType(totalCommands);}; if (totalPointValues > 0) {_points = new valueArrayType(totalPointValues);}; if (totalRadii > 0) {_radii = new valueArrayType(totalRadii);}; ci = pi = ri = 0; Caf.each2(this.paths, ({commands, radii, points}, i) => {Caf.each2(commands, (v) => _commands[ci++] = v); Caf.each2(points, (v) => _points[pi++] = v); return Caf.each2(radii, (v) => _radii[ri++] = v);}); return new (require('./CanvasPath'))({commands: _commands, points: _points, radii: _radii, name: this.name, aspectRatio: this.aspectRatio});}}); this.prototype.normalize = function(drawArea = this.drawArea) {Caf.each2(this.paths, (path) => path.normalize(drawArea)); this.aspectRatio = drawArea.aspectRatio; return this;}; this.prototype.removeStyles = function() {return Caf.each2(this.paths, (path) => path.removeStyles());}; this.prototype._initFromXbd = function(xbdTag) {let temp, base; this.aspectRatio = parseFloat(((temp = xbdTag.attrs.aspectRatio.toString()) != null ? temp : 1)); this.name = Caf.exists(base = xbdTag.attrs.name) && base.toString(); return Caf.array(xbdTag.tags, (pathTag) => new (require('./CanvasPath'))(pathTag));};});});});
//# sourceMappingURL=CanvasPathSet.js.map
