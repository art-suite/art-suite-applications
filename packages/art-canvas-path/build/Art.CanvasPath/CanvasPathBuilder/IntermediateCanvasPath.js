"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseClass", "rect", "max", "min", "valueArrayType", "maxFixedPointValue", "Math", "commandArrayType", "CanvasPath", "merge", "commandMap"], [global, require('./StandardImport')], (BaseClass, rect, max, min, valueArrayType, maxFixedPointValue, Math, commandArrayType, CanvasPath, merge, commandMap) => {let IntermediateCanvasPath; return IntermediateCanvasPath = Caf.defClass(class IntermediateCanvasPath extends BaseClass {constructor() {super(...arguments); this._originalMaxX = 0; this._originalMaxY = 0; this._originalMinX = 0; this._originalMinY = 0; this._commands = []; this._pointData = []; this._radiiData = [];};}, function(IntermediateCanvasPath, classSuper, instanceSuper) {this.getter("originalMaxX", "originalMaxY", "originalMinX", "originalMinY", "pointCount", {originalMax: function() {return [this._originalMaxX, this._originalMaxY];}, originalMin: function() {return [this._originalMinX, this._originalMinY];}}, "pointData", "commands", {inspectedObjects: function() {return {svgPath: {originalMin: this.originalMin, originalMax: this.originalMax, pointCount: this.pointCount, pointData: this.pointData, commands: this.commands}};}}); this.property("fillStyle", "strokeStyle", "lineWidth", "miterLimit", "lineCap", "lineJoin", "matrix"); this.getter({stroke: function() {return this.strokeStyle != null;}, fill: function() {return this.fillStyle != null;}, drawArea: function() {return rect(this._originalMinX, this._originalMinY, this._originalMaxX - this._originalMinX, this._originalMaxY - this._originalMinY);}}); this.prototype._addPoint = function(x, y) {if (this._pointData.length === 0) {this._originalMaxX = this._originalMinX = x; this._originalMaxY = this._originalMinY = y;} else {this._originalMaxX = max(x, this._originalMaxX); this._originalMaxY = max(y, this._originalMaxY); this._originalMinX = min(x, this._originalMinX); this._originalMinY = min(y, this._originalMinY);}; this._pointData.push(x); return this._pointData.push(y);}; this.prototype.resolveMatrix = function() {let m, pointData, from, into, to, i1, temp; return (m = this.matrix) ? (pointData = this._pointData, this._pointData = [], (from = pointData, into = from, (from != null) ? (to = from.length, i1 = 0, (() => {while (i1 < to) {let x, i, y; x = from[i1]; i = i1; y = pointData[i + 1]; this._addPoint(m.transformX(x, y), m.transformY(x, y)); temp = i1 += 2;}; return temp;})()) : undefined, into), this.matrix = undefined) : undefined;}; this.getter({painted: function() {return this.stroke || this.fill;}, encodedPointData: function() {let uintArray, subX, subY, scalerX, scalerY, from, into, to, i1, temp; return (this._pointData.length > 0) ? (uintArray = new valueArrayType(this._pointData.length), subX = this._originalMinX, subY = this._originalMinY, scalerX = maxFixedPointValue / (this._originalMaxX - this._originalMinX), scalerY = maxFixedPointValue / (this._originalMaxY - this._originalMinY), (from = this._pointData, into = from, (from != null) ? (to = from.length, i1 = 0, (() => {while (i1 < to) {let x, i, y; x = from[i1]; i = i1; y = this._pointData[i + 1]; uintArray[i] = scalerX * (x - subX) + .5 | 0; uintArray[i + 1] = scalerY * (y - subY) + .5 | 0; temp = i1 += 2;}; return temp;})()) : undefined, into), uintArray) : undefined;}, encodedRadiiData: function() {let uintArray, scaler, from, into, to, i1, temp; return (this._radiiData.length > 0) ? (uintArray = new valueArrayType(this._radiiData.length), scaler = maxFixedPointValue / Math.PI * 2, (from = this._radiiData, into = from, (from != null) ? (to = from.length, i1 = 0, (() => {while (i1 < to) {let r, i; r = from[i1]; i = i1; uintArray[i] = Caf.mod(scaler * r, maxFixedPointValue) | 0; temp = i1++;}; return temp;})()) : undefined, into), uintArray) : undefined;}, encodedCommands: function() {let out, from, into, to, i1, temp; return (this._commands.length > 0) ? (from = this._commands, into = out = new commandArrayType(Math.ceil(this._commands.length / 2)), (from != null) ? (to = from.length, i1 = 0, (() => {while (i1 < to) {let v, i, v2, temp1; v = from[i1]; i = i1; v2 = ((temp1 = this._commands[i + 1]) != null ? temp1 : 0); out[i / 2] = (v << 4) + v2; temp = i1 += 2;}; return temp;})()) : undefined, into) : undefined;}, originalX: function() {return this._originalMinX;}, originalY: function() {return this._originalMinY;}, originalWidth: function() {return this._originalMaxX - this._originalMinX;}, originalHeight: function() {return this._originalMaxY - this._originalMinY;}, originalScale: function() {return max(this.originalWidth, this.originalHeight);}, encodedWidth: function() {return this.originalWidth / this.originalScale;}, encodedHeight: function() {return this.originalHeight / this.originalScale;}, aspectRatio: function() {return this.originalWidth / this.originalHeight;}, canvasPath: function() {return new CanvasPath(merge({points: this.encodedPointData, radii: this.encodedRadiiData, commands: this.encodedCommands, aspectRatio: this.aspectRatio, x: this.originalX, y: this.originalY, scale: this.originalScale, fillStyle: this.fillStyle, strokeStyle: this.strokeStyle, lineWidth: this.lineWidth, miterLimit: this.miterLimit, lineCap: this.lineCap, lineJoin: this.lineJoin, matrix: this.matrix}));}}); this.prototype._addRadius = function(r) {return this._radiiData.push(r);}; this.prototype._addCommand = function(commandName) {return this._commands.push(commandMap[commandName]);}; this.prototype.beginPath = function() {}; this.prototype.closePath = function() {}; this.prototype.moveTo = function(a, b) {this._addCommand("moveTo"); return this._addPoint(a, b);}; this.prototype.lineTo = function(a, b) {this._addCommand("lineTo"); return this._addPoint(a, b);}; this.prototype.quadraticCurveTo = function(a, b, c, d) {this._addCommand("quadraticCurveTo"); this._addPoint(a, b); return this._addPoint(c, d);}; this.prototype.bezierCurveTo = function(a, b, c, d, e, f) {this._addCommand("bezierCurveTo"); this._addPoint(a, b); this._addPoint(c, d); return this._addPoint(e, f);}; this.prototype.arc = function(x, y, r1, r2, r3, counterClockwise) {this._addCommand(counterClockwise ? "antiArc" : "arc"); this._addPoint(x, y); this._addRadius(r1); this._addRadius(r2); return this._addRadius(r3);};});});});
//# sourceMappingURL=IntermediateCanvasPath.js.map
