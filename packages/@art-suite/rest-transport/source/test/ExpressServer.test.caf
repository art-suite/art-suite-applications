import &StandardImport, Server: &build/Server

{pipelines} = pipelineRegistry = new PipelineRegistry location: :client

server = null

class MyPipeline extends Pipeline
  @registry pipelineRegistry
  @filter RestTransportClientFilter
  @publicHandler
    get:    (request) -> "" Hello #{if request.session.user then request.session.user else :world}.
    login:  (request) -> request.respondWithSession user: request.key

&ArtConfig.configure()

chainedTest "start server" ->
  server = Server.start {} pipelineRegistry, port: 0 verbose: true quiet: true

.tapTest
  "get before setting remoteServer is processed 'locally'" ->
    pipelines.myPipeline.get returnResponse: true
    .then (response) ->
      assert.eq response.data, "" Hello world.
      assert.doesNotExist response.remoteRequest.method
      assert.instanceOf response.remoteResponse, Request

  "set remoteServer" ->
    getRestTransportClientConfig pipelineRegistry
    .remoteServer = remoteServer = :http:// + server.hostAndPort

  "make a get request" ->
    pipelines.myPipeline.get returnResponse: true
    .then (response) ->
      assert.eq response.data, "" Hello world.
      assert.exists response.remoteRequest.method
      assert.notInstanceOf response.remoteResponse, Request

  "make a login request" ->
    pipelines.myPipeline.login key: :Shane returnResponse: true
    .then (response) ->
      assert.eq response.props, {}
      assert.eq response.session.user, :Shane

  "make a get request with session" ->
    pipelines.myPipeline.get()
    .then (result) -> assert.eq result, "" Hello Shane.

test "shut down the server" ->
  server.stop()
