import &StandardImport, {} &build/Server

{pipelines} = pipelineRegistry = new PipelineRegistry location: :client

server = null

class MyPipeline extends Pipeline
  @registry pipelineRegistry
  @filter RestTransportClientFilter
  @publicHandler
    get:    (request) -> "" Hello #{if request.session.user then request.session.user else :world}.
    login:  (request) -> request.respondWithSession user: request.key

&ArtConfig.configure()

chainedTest "start server" ->
  server = Server.start {} pipelineRegistry, port: 0 verbose: true quiet: true

.thenTest
  "get before setting remoteServer is processed 'locally'" ->
    pipelines.myPipeline.get returnResponse: true
    .then (response) ->
      assert.eq response.data, "" Hello world.
      assert.doesNotExist response.remoteRequest.method
      assert.instanceOf response.remoteResponse, Request

  "set remoteServer" ->
    getRestTransportClientConfig pipelineRegistry
    .remoteServer = remoteServer = :http:// + server.hostAndPort

  "make a get request" ->
    pipelines.myPipeline.get returnResponse: true
    .tap (response) ->
      assert.eq response.data, "" Hello world.
      assert.eq response.remoteRequest.method, :get
      assert.notInstanceOf response.remoteResponse, Request

  "check returned session" (response) ->
    assert.isString response.remoteResponse.session extract signature
    assert.isPlainObject response.remoteResponse

    assert.eq
      response.remoteResponse
      status:  :success
      props:   data: "Hello world."
      session: {} signature

  "make a login request" ->
    pipelines.myPipeline.login key: :Shane returnResponse: true
    .then (response) ->
      assert.eq response.props, {}
      assert.eq response.session.user, :Shane

  "make a get request with session" ->
    pipelines.myPipeline.get returnResponse: true
    .then (response) ->
      assert.eq response.remoteRequest.method, :get
      assert.eq response.data, "" Hello Shane.

  "set useLegacySessionTransport" ->
    getRestTransportClientConfig pipelineRegistry
    .useLegacySessionTransport = true

  "make a legacy get-request with session" ->
    pipelines.myPipeline.get returnResponse: true
    .then (response) ->
      assert.eq response.remoteRequest.method, :post # has to use post, since it has a payload (the session)
      assert.eq response.data, "" Hello Shane.

  "reset session" -> pipelineRegistry.session.reset()

  "make a legacy get-request without session" ->
    pipelines.myPipeline.get returnResponse: true
    .then (response) ->
      assert.eq response.remoteRequest.method, :get # can use get, since it has no payload
      assert.eq response.data, "" Hello world.

test "shut down the server" ->
  server.stop()
