import &StandardImport, &ArtRestClient, &RestTransportClientConfig

{}
  restMap = {}
    :get
    :delete
    create: :post
    update: :put

  getPipelineRestPath = (apiRoot, pipeline) -> "/#{apiRoot}/#{pipeline.name}"
  getPipelineRestPathRegex = (apiRoot, pipeline) ->
    ///i
      ^
      #{escapeRegExp getPipelineRestPath apiRoot, pipeline}
      (?:-([a-z0-9_]+))?          # optional request-type (if missing, it is derived from the HTTP method)
      (?:\/([^?]+))?       # optional key
      (?=\?|$)

  getStandardHttpMethod = (type, session, useLegacySessionTransport) ->
    if method = restMap[type]
      if useLegacySessionTransport && method == :get && objectHasKeys session
        # old session-transport is sent as payload, but in-browser, "get" can't have
        # a payload, so if there is a session, we can't use the "get" method
        return null
    method

  getRestClientParamsForArtEryRequest = ({session, server, restPath, type, key, data, useLegacySessionTransport}) ->
    urlKeyClause = if present key then "/#{key}" else ''
    server ?= ''
    hasSessionData = objectHasKeys session

    merge {}
      headers: if !useLegacySessionTransport && session?.signature then authorization: "" Bearer #{} session.signature
      url:
        if method = getStandardHttpMethod type, session, useLegacySessionTransport
          "" #{server}#{restPath}#{urlKeyClause}
        else
          method = :post
          "" #{server}#{restPath}-#{type}#{urlKeyClause}

      method
      data

  getRemoteRequestProps = (request, options) ->
    request extract session, data, props, pipeline, type, key

    options extract remoteServer, useLegacySessionTransport

    props = object v,k from props when v != undefined && k != :key && k != :data
    data  = object v   from data  when v != undefined

    remoteRequestData = null
    (remoteRequestData ?= {}).session = session.signature if useLegacySessionTransport && session.signature
    (remoteRequestData ?= {}).props   = props if objectHasKeys props
    (remoteRequestData ?= {}).data    = data  if objectHasKeys data

    getRestClientParamsForArtEryRequest {}
      restPath: getPipelineRestPath getApiRoot(request), pipeline
      server:
        switch remoteServer
        when true, ".", "/" then '' # use the same URL as the current 'page' - this will only apply within an actual browser
        else remoteServer
      type
      key
      session
      data:           remoteRequestData
      useLegacySessionTransport

  ## sendRemoteRequest
    IN:
      request: ArtEryPipelines Request (required)
      options: plain object (required)
        remoteServer:       string - required unless sendRequestMethod is provided
        useLegacySessionTransport: boolean
        sendRequestMethod:  custom method for sending the request; same signature as &ArtRestClient.restJsonRequest
  sendRemoteRequest: (request, options) ->
    sendRequestMethod = options.sendRequestMethod ? restJsonRequest

    sendRequestMethod remoteRequest = getRemoteRequestProps request, options
    .catch (error) ->
      status = error.info?.status ? error.status ? failure
      {response, message} = error.info ? error

      merge response, {status, message}

    .then (remoteResponse) ->
      remoteResponse ?= status: missing
      request.addFilterLog "#{remoteRequest.method.toLocaleUpperCase()} #{remoteRequest.url}", :remoteRequest
      request.toResponse remoteResponse.status, merge remoteResponse, {remoteRequest, remoteResponse}
