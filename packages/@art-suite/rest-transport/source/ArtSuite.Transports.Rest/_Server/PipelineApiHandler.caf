import
  &StandardImport
  &SessionsLib
  &RestServerLib

class PipelineApiHandler extends &ArtExpressServer.PromiseHandler

  ## constructor
    options:
      pipelineRegistry: [required: ArtPipelines.PipelineRegistry] registry for all the pipelines that will be handled
      apiRoot:  [string] root URL path for the api
  constructor: (options = {}) ->
    @_pipelineRegistry = options.pipelineRegistry
    @_apiRoot = options.apiRoot ? config.apiRoot

  @getter
    :pipelineRegistry
    :apiRoot
    pipelines: -> @pipelineRegistry.pipelines
    pipelineRestPathPatterns: -> @_pipelineRestPathPatterns ?= object pipeline in @pipelines with getPipelineRestPathRegex @apiRoot, pipeline

  # canHandleRequest: IN: request [{url: string}]
  canHandleRequest: ({url}) -> find pattern, pipelineName in @pipelineRestPathPatterns when pattern.test url

  ## handleApiRequest: (override - see ArtExprssServer#handleApiRequest)
    IN:
      request:      [required: {url: string, method: string}]
      requestData:  [required, but inidividual properties are not]
        session
        data
        props
    OUT:
      status: string
      data: # HTTP response payload data; which might look like
        data: {...}     # application returned payload data
        session: {...}  # session data
        xxx: yyy        # other possible props.*
  handleApiRequest: (request, requestData) ->
    requestData ?= {}
    if found = @_findPipelineForRequest request
      {pipeline, type, key} = found
      if bearerHeader = request.headers?.authorization
        [_, bearerSession] = bearerHeader.split ' '

      verifySession bearerSession ? requestData.session
      .catch -> null
      .then (session) ->
        pipeline._processRequest createRequestFromRemoteRequestProps {}
          pipeline, type, key, requestData
          session: session || {}
          remoteRequest: request

        .then (response) ->
          if response.isServerFailure
            response.toPromise()
            .catch (error) ->
              log.withOptions
                isError: true unquoted: true
                """ #{@getRequestLogHeader request, response}: #{} error.stack

          else if config.server.verbose
            log
              ""
                #{@getRequestLogHeader request, response}:
                subrequestCount: #{response.subrequestCount}, recordsReturned: #{if response.data then if isArray response.data then response.data.length else 1 else 0}

          if isSuccess response.status
            Promise.resolve prepareSignedSessionForResponse session, merge response.props, {} session: response.responseSession
            .then (data) -> {} response.status, data

          else
            {status, props: data} = response.responseForRemoteRequest
            throw new RequestError {} status, data

    else
      Promise.resolve null # missing

  getRequestLogHeader: (request, response) ->
    "" #{@logHeader} #{request.method}:#{request.url} (#{encodeHttpStatus response.status}, #{(currentSecond() - response.startTime) * 1000 | 0}ms)

  ######################
  # PRIVATE
  ######################

  httpMethodsToArtEryRequestTypes =
    get:    :get
    post:   :create
    put:    :update
    delete: :delete

  _findPipelineForRequest: (request) ->
    {url, method} = request

    if found = find pattern, pipelineName in @pipelineRestPathPatterns with {} match, pipelineName if match = url.match pattern
      found extract pipelineName, match
      [__, type, key] = match
      type ?= type = httpMethodsToArtEryRequestTypes[method.toLocaleLowerCase()]

      pipeline = @pipelines[pipelineName]

      if config.server.verbose && type && !pipeline.publicRequestTypes[type]
        log.warn "" ArtEryHandler blocked request: '#{pipeline.name}.#{type}': #{if type in pipeline.requestTypes then "not in publicRequestTypes" else "not a valid request-type"}

      pipeline.publicRequestTypes[type] && {} pipeline, type, key
