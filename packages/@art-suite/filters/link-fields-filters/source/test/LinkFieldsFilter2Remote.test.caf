import &StandardImport, &@ArtSuite/DatabaseFilters

&ArtConfig.configure()

describe
  fullV2: ->
    {pipelines} = pipelineRegistry = new PipelineRegistry location: :client
    class BasePipeline extends &SimplePipeline
      @registry pipelineRegistry
      @abstractClass()

    ## Version 2
    class MessageRemote extends BasePipeline
      @filter createDatabaseFilters
        prefetchedRecordsExpirationSeconds: .01
        linkFilterVersion: 2
        fields:
          userRemote: :autoCreate :link :prefetch
          message:    :trimmedString

    class UserRemote extends BasePipeline
      @filter createDatabaseFilters
        prefetchedRecordsExpirationSeconds: .01
        linkFilterVersion: 2
        fields:
          name: :trimmedString

    chainedTest ->
      pipelines.messageRemote.create
        data:
          message:          :Hi
          userRemote: name: :Frank

        returnResponse: true

      .then (response) ->
        response.data extract userRemoteId, createdAt, updatedAt, id
        assert.eq
          response.responseProps
          data:                                     {} id, userRemoteId,  createdAt, updatedAt, message: :Hi
          dataUpdates: userRemote: [userRemoteId]:  {}                    createdAt, updatedAt, name:    :Frank  id: userRemoteId

        {} userRemoteId, messageRemoteId: id

    .tapTest "get messageRemote" ({messageRemoteId, userRemoteId}) ->
      pipelines.messageRemote.get messageRemoteId, returnResponse: true
      .then (response) ->
        response extract
          data extract userRemoteId, createdAt, updatedAt, id
          responseProps

        assert.eq
          responseProps
          data:                                     {} id, userRemoteId,  createdAt, updatedAt, message: :Hi
          dataUpdates: userRemote: [userRemoteId]:  {}                    createdAt, updatedAt, name:    :Frank  id: userRemoteId

        assert.exists getPrefetchedRecord pipelines.userRemote, userRemoteId

    .tapTest "let prefetchedRecords expire" -> timeout .02

  transition2A: ->
    {pipelines} = pipelineRegistry = new PipelineRegistry location: :client
    class BasePipeline extends &SimplePipeline
      @registry pipelineRegistry
      @abstractClass()

    ## Version 2A
    class MessageRemote2A extends BasePipeline
      @filter createDatabaseFilters
        linkFilterVersion: :transition2A
        fields:
          userRemote2A: :autoCreate :link :prefetch
          message:      :trimmedString

    class UserRemote2A extends BasePipeline
      @filter createDatabaseFilters
        linkFilterVersion: :transition2A
        fields:
          name: :trimmedString

    chainedTest ->
      pipelines.messageRemote2A.create
        data:
          message:            :Hi
          userRemote2A: name: :Frank
        returnResponse: true
      .then (response) ->
        response.data extract userRemote2AId, createdAt, updatedAt, id
        assert.eq
          response.responseProps
          data: {}
            id, userRemote2AId,  createdAt, updatedAt
            message:  :Hi
            userRemote2A: {}
              createdAt
              updatedAt
              name:   :Frank
              id:     userRemote2AId

        {} userRemote2AId, messageRemote2AId: id

    .tapTest "get messageRemote2A" ({messageRemote2AId, userRemote2AId}) ->
      pipelines.messageRemote2A.get messageRemote2AId, returnResponse: true
      .then (response) ->
        response extract
          data extract userRemote2AId, createdAt, updatedAt, id
          responseProps

        assert.eq
          responseProps
          data: {}
            id, userRemote2AId,  createdAt, updatedAt
            message:      :Hi
            userRemote2A: {} createdAt, updatedAt, name: :Frank id: userRemote2AId

        assert.doesNotExist getPrefetchedRecord pipelines.userRemote2A, userRemote2AId

  transition2B: ->
    {pipelines} = pipelineRegistry = new PipelineRegistry location: :client
    class BasePipeline extends &SimplePipeline
      @registry pipelineRegistry
      @abstractClass()

    ## Version 2B
    class MessageRemote2B extends BasePipeline
      @filter createDatabaseFilters
        prefetchedRecordsExpirationSeconds: .01
        linkFilterVersion: :transition2B
        fields:
          userRemote2B: :autoCreate :link :prefetch
          message:      :trimmedString

    class UserRemote2B extends BasePipeline
      @filter createDatabaseFilters
        prefetchedRecordsExpirationSeconds: .01
        linkFilterVersion: :transition2B
        fields:
          name: :trimmedString

    # These are IDENTICAL to fullV2 except with *Remote2B* names instead of *Remote* names
    chainedTest ->
      pipelines.messageRemote2B.create
        data:
          message:            :Hi
          userRemote2B: name: :Frank
        returnResponse: true
      .then (response) ->
        response.data extract userRemote2BId, createdAt, updatedAt, id
        assert.eq
          response.responseProps
          data:                                         {} id, userRemote2BId,  createdAt, updatedAt, message: :Hi
          dataUpdates: userRemote2B: [userRemote2BId]:  {}                      createdAt, updatedAt, name:    :Frank  id: userRemote2BId

        {} userRemote2BId, messageRemote2BId: id

    .tapTest "get messageRemote2B" ({messageRemote2BId, userRemote2BId}) ->
      pipelines.messageRemote2B.get messageRemote2BId, returnResponse: true
      .then (response) ->
        response extract
          data extract userRemote2BId, createdAt, updatedAt, id
          responseProps

        assert.eq
          responseProps
          data:                                         {} id, userRemote2BId,  createdAt, updatedAt, message: :Hi
          dataUpdates: userRemote2B: [userRemote2BId]:  {}                      createdAt, updatedAt, name:    :Frank  id: userRemote2BId

        assert.exists getPrefetchedRecord pipelines.userRemote2B, userRemote2BId

    .tapTest "let prefetchedRecords expire" -> timeout .02
