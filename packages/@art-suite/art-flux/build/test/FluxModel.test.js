"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "ModelRegistry", "beforeEach", "test", "Promise", "assert", "pending", "missing", "timeout", "success", "log"], [global, require('./StandardImport')], (describe, ModelRegistry, beforeEach, test, Promise, assert, pending, missing, timeout, success, log) => {let models, fluxStore, FluxModel, reset; models = fluxStore = FluxModel = null; reset = function() {let modelRegistry; ({models} = modelRegistry = new ModelRegistry); FluxModel = FluxModel = Caf.defClass(class FluxModel extends require('../../build').FluxModel {}, function(FluxModel, classSuper, instanceSuper) {this.modelRegistry(modelRegistry);}); return fluxStore = modelRegistry.modelStore;}; return describe({load: function() {beforeEach(reset); test("model with async load", () => new Promise((resolve) => {let MyBasicModel, res; MyBasicModel = Caf.defClass(class MyBasicModel extends FluxModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.prototype.load = function(key) {fluxStore.onNextReady(() => this.updateModelRecord(key, {status: missing})); return null;};}); res = fluxStore.subscribe("myBasicModel", "123", (fluxRecord) => {if (!(fluxRecord.status !== pending)) {return;}; assert.selectedEq({status: missing, key: "123", modelName: "myBasicModel"}, fluxRecord); return resolve();}); return assert.selectedEq({status: pending, key: "123", modelName: "myBasicModel"}, res);})); test("model with @loadModelRecord", () => new Promise((resolve) => {let MyBasicModel, res; MyBasicModel = Caf.defClass(class MyBasicModel extends FluxModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.prototype.loadModelRecord = function(key) {return timeout(20).then(() => {return {status: missing};});};}); res = fluxStore.subscribe("myBasicModel", "123", (fluxRecord) => {if (!(fluxRecord.status !== pending)) {return;}; assert.selectedEq({status: missing, key: "123", modelName: "myBasicModel"}, fluxRecord); return resolve();}); return assert.selectedEq({status: pending, key: "123", modelName: "myBasicModel"}, res);})); test("model with custom load - delayed", () => {let MyBasicModel; MyBasicModel = Caf.defClass(class MyBasicModel extends FluxModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.prototype.load = function(key, callback) {this.updateModelRecord(key, () => {return {status: success, data: {theKeyIs: key}};}); return null;};}); return (new Promise((resolve) => {let res; res = fluxStore.subscribe("myBasicModel", "123", (fluxRecord) => {assert.selectedEq({status: success, key: "123", modelName: "myBasicModel", data: {theKeyIs: "123"}}, fluxRecord); return resolve();}); return assert.selectedEq({status: pending, key: "123", modelName: "myBasicModel"}, res);})).then(() => new Promise((resolve) => fluxStore.subscribe("myBasicModel", "456", (fluxRecord) => {assert.selectedEq({status: success, key: "456", modelName: "myBasicModel", data: {theKeyIs: "456"}}, fluxRecord); return resolve();})));}); return test("model with custom load - immediate", () => {let MyBasicModel; MyBasicModel = Caf.defClass(class MyBasicModel extends FluxModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.prototype.load = function(key, callback) {return this.updateModelRecord(key, {status: success, data: {theKeyIs: key}});};}); return new Promise((resolve, reject) => {let res; res = fluxStore.subscribe("myBasicModel", "123", (fluxRecord) => {log.error("THIS SHOULDN'T HAPPEN!"); return reject();}); assert.selectedEq({status: success, key: "123", modelName: "myBasicModel", data: {theKeyIs: "123"}}, res); return fluxStore.onNextReady(() => resolve());});});}, loadData: function() {beforeEach(reset); test("basic loadData returning promise", () => {let MyBasicModel; MyBasicModel = Caf.defClass(class MyBasicModel extends FluxModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.prototype.loadData = function(key) {return Promise.resolve({theKeyIs: key});};}); return (new Promise((resolve) => fluxStore.subscribe("myBasicModel", "123", (fluxRecord) => {assert.selectedEq({status: success, key: "123", modelName: "myBasicModel", data: {theKeyIs: "123"}}, fluxRecord); return resolve();}))).then(() => new Promise((resolve) => fluxStore.subscribe("myBasicModel", "456", (fluxRecord) => {assert.selectedEq({status: success, key: "456", modelName: "myBasicModel", data: {theKeyIs: "456"}}, fluxRecord); return resolve();})));}); test("basic loadData returning value directly", () => {let MyBasicModel; MyBasicModel = Caf.defClass(class MyBasicModel extends FluxModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.prototype.loadData = function(key) {return {theKeyIs: key};};}); return (new Promise((resolve) => fluxStore.subscribe("myBasicModel", "123", (fluxRecord) => {assert.selectedEq({status: success, key: "123", modelName: "myBasicModel", data: {theKeyIs: "123"}}, fluxRecord); return resolve();}))).then(() => new Promise((resolve) => fluxStore.subscribe("myBasicModel", "456", (fluxRecord) => {assert.selectedEq({status: success, key: "456", modelName: "myBasicModel", data: {theKeyIs: "456"}}, fluxRecord); return resolve();})));}); return test("When there are multiple loadPromises with the same key, loadData is only called once per unique key", () => {let loadCount, User, p1, p2, p3; loadCount = 0; User = Caf.defClass(class User extends FluxModel {}, function(User, classSuper, instanceSuper) {this.prototype.loadData = function(key) {return timeout(10).then(() => {loadCount++; return {id: key, userName: "fred"};});};}); p1 = models.user.loadPromise("abc"); p2 = models.user.loadPromise("abc"); p3 = models.user.loadPromise("def"); return Promise.all([p1, p2, p3]).then(() => {assert.eq(loadCount, 2); assert.eq(p1, p2); return assert.neq(p1, p3);});});}, functionsBoundToInstances: function() {beforeEach(reset); return test("member functions declared in Concrete models can be used without 'this'", () => {let User, user, foo; User = Caf.defClass(class User extends FluxModel {}, function(User, classSuper, instanceSuper) {this.prototype.foo = function() {return this._foo = (this._foo || 0) + 1;};}); user = User.user; foo = user.foo; foo(); assert.eq(user._foo, 1); foo(); return assert.eq(user._foo, 2);});}, aliases: function() {beforeEach(reset); return test("@aliases adds aliases to the model registry", () => {let User; User = Caf.defClass(class User extends FluxModel {}, function(User, classSuper, instanceSuper) {this.aliases("owner", "sister");}); assert.eq(models.user.class, User); assert.eq(models.user, models.owner); return assert.eq(models.user, models.sister);});}, simultanious: function() {beforeEach(reset); test("two simultantious FluxModel requests on the same key only triggers one store request", () => {let counts, MyBasicModel; counts = {load: 0, sub1: 0, sub2: 0}; MyBasicModel = Caf.defClass(class MyBasicModel extends FluxModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.prototype.load = function(key, callback) {counts.load++; return this.updateModelRecord(key, {status: success, data: {theKeyIs: key}});};}); fluxStore.subscribe("myBasicModel", "123", (fluxRecord) => {assert.eq(fluxRecord.count, 2); return counts.sub1++;}); fluxStore.subscribe("myBasicModel", "123", (fluxRecord) => {assert.eq(fluxRecord.count, 2); return counts.sub2++;}); fluxStore.update("myBasicModel", "123", (fluxRecord) => {return {count: (fluxRecord.count || 0) + 1};}); fluxStore.update("myBasicModel", "123", (fluxRecord) => {return {count: (fluxRecord.count || 0) + 1};}); return fluxStore.onNextReady(() => assert.eq(counts, {load: 1, sub1: 1, sub2: 1}));}); return test("two simultantious FluxModel requests on the different keys triggers two store requests", () => {let counts, MyBasicModel; counts = {load: 0, sub1: 0, sub2: 0}; MyBasicModel = Caf.defClass(class MyBasicModel extends FluxModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.prototype.load = function(key, callback) {counts.load++; return this.updateModelRecord(key, {status: success, data: {theKeyIs: key}});};}); fluxStore.subscribe("myBasicModel", "123", (fluxRecord) => {assert.eq(fluxRecord.count, 1); return counts.sub1++;}); fluxStore.subscribe("myBasicModel", "456", (fluxRecord) => {assert.eq(fluxRecord.count, 1); return counts.sub2++;}); fluxStore.update("myBasicModel", "123", (fluxRecord) => {return {count: (fluxRecord.count || 0) + 1};}); fluxStore.update("myBasicModel", "456", (fluxRecord) => {return {count: (fluxRecord.count || 0) + 1};}); return fluxStore.onNextReady(() => assert.eq(counts, {load: 2, sub1: 1, sub2: 1}));});}});});});
//# sourceMappingURL=FluxModel.test.js.map
