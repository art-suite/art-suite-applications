"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["ArtModelSubscriptionsMixin", "Component", "parseSubscriptions", "Error", "formattedInspect", "isFunction", "isString", "ArtModelRegistry", "success", "log"], [global, require('art-standard-lib'), require('art-communication-status'), require('@art-suite/art-models'), require("art-react"), require('../Lib'), require('./ComponentLib')], (ArtModelSubscriptionsMixin, Component, parseSubscriptions, Error, formattedInspect, isFunction, isString, ArtModelRegistry, success, log) => {let FluxComponent; return FluxComponent = Caf.defClass(class FluxComponent extends ArtModelSubscriptionsMixin(Component) {constructor() {super(...arguments); this.class._prepareSubscriptions();};}, function(FluxComponent, classSuper, instanceSuper) {this.abstractClass(); this.subscriptions = function(...args) {Caf.each2(parseSubscriptions(args), (options, stateField) => this._addSubscription(stateField, options)); return null;}; this.prototype._preprocessProps = function(newProps) {this._updateAllSubscriptions(newProps = instanceSuper._preprocessProps.apply(this, arguments)); return newProps;}; this.prototype.componentWillUnmount = function() {instanceSuper.componentWillUnmount.apply(this, arguments); return this.unsubscribeAll();}; this.extendableProperty({subscriptionProperties: {}}); this._addSubscription = function(stateField, subscriptionOptions) {let existingGetters, statusField, progressField, failureInfoField; if (this.getSubscriptionProperties()[stateField]) {throw new Error(`subscription already defined for: ${Caf.toString(formattedInspect({stateField}))}`);}; this.extendSubscriptionProperties(stateField, subscriptionOptions); existingGetters = /element/; return !stateField.match(existingGetters) ? (this.addGetter(stateField, function() {return this.state[stateField];}), this.addGetter(statusField = stateField + "Status", function() {return this.state[statusField];}), this.addGetter(progressField = stateField + "Progress", function() {return this.state[progressField];}), this.addGetter(failureInfoField = stateField + "FailureInfo", function() {return this.state[failureInfoField];})) : undefined;}; this._prepareSubscription = function(subscription) {let stateField, model, key, modelName; ({stateField, model, key} = subscription); subscription.propsToModel = (() => {switch (false) {case !isFunction(model): return model; case !isString(modelName = model): if (!(model = ArtModelRegistry.models[model])) {throw new Error(`${Caf.toString(this.getName())}::subscriptions() model '${Caf.toString(modelName)}' not registered (${Caf.toString(this.getNamespacePath())})`);}; return () => model; default: return (!model) ? (() => {throw new Error(`no model specified in subscription: ${Caf.toString(formattedInspect({stateField, model, class: [this.name, subscription]}))}`);})() : undefined;};})(); return subscription.propsToKey = isFunction(key) ? key : (key != null) ? () => key : undefined;}; this._prepareSubscriptions = function() {if (this._subscriptionsPrepared) {return;}; this._subscriptionsPrepared = true; return Caf.each2(this.getSubscriptionProperties(), (subscription, stateField) => this._prepareSubscription(subscription));}; this.prototype._updateSubscription = function(stateField, key, model, props) {let initialData; return this.subscribe(stateField, model.modelName, key, {stateField, initialModelRecord: (initialData = props[stateField]) ? {status: success, data: initialData} : undefined});}; this.prototype._updateAllSubscriptions = function(props = this.props) {Caf.each2(this.class.getSubscriptionProperties(), (subscriptionProps, stateField) => {let propsToKey, propsToModel, model, error, modelName, key; ({propsToKey, propsToModel} = subscriptionProps); model = (() => {try {return propsToModel(props, stateField);} catch (error1) {error = error1; log.error(error); log.error({"UpdateSubscription propsToModel error": {FluxComponent: [this, stateField, subscriptionProps, props]}}); return null;};})(); if (isString(modelName = model)) {if (!(model = this.models[modelName])) {log.error({"UpdateSubscription could not find model-name returned from propsToModel": {FluxComponent: [this, stateField, subscriptionProps, props, modelName]}});};}; return model ? (key = (() => {try {return (propsToKey != null) ? propsToKey(props, stateField) : model.propsToKey(props, stateField);} catch (error2) {error = error2; log.error(error); log.error({"UpdateSubscription propsToKey error": {FluxComponent: [this, stateField, subscriptionProps, props]}}); return null;};})(), this._updateSubscription(stateField, key, model, props)) : undefined;}); return null;}; this.prototype._componentDidHotReload = function() {this.unsubscribeAll(); this._updateAllSubscriptions(); return instanceSuper._componentDidHotReload.apply(this, arguments);}; this.postCreateConcreteClass = function({hotReloaded}) {if (this.prototype.subscriptions) {this.subscriptions(this.prototype.subscriptions);}; this._subscriptionsPrepared = false; if (hotReloaded) {this._prepareSubscriptions();}; return classSuper.postCreateConcreteClass.apply(this, arguments);};});});});
//# sourceMappingURL=FluxComponent.js.map
