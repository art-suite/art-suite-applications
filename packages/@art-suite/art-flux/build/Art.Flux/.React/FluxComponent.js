// Generated by CoffeeScript 1.12.7
(function() {
  var ArtModelRegistry, ArtModelSubscriptionsMixin, Component, FluxComponent, artFluxDeprecatedWarning, createComponentFactory, defineModule, formattedInspect, globalCount, isFunction, isPlainObject, isString, log, parseSubscriptions, ref, ref1, ref2, success,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  ref = require('art-standard-lib'), defineModule = ref.defineModule, log = ref.log, isPlainObject = ref.isPlainObject, isString = ref.isString, isFunction = ref.isFunction, globalCount = ref.globalCount, formattedInspect = ref.formattedInspect;

  success = require('art-communication-status').success;

  ref1 = require('@art-suite/art-models'), ArtModelRegistry = ref1.ArtModelRegistry, ArtModelSubscriptionsMixin = ref1.ArtModelSubscriptionsMixin;

  ref2 = require("art-react"), Component = ref2.Component, createComponentFactory = ref2.createComponentFactory;

  artFluxDeprecatedWarning = require("../Lib").artFluxDeprecatedWarning;

  parseSubscriptions = require('./ComponentLib').parseSubscriptions;


  /*
    FluxComponent
  
    Declarative (automatic) Flux Subscription support:
    - @subscriptions declaration method
  
    TODO:
      * _prepareSubscription should be triggered via createWithPostCreate rather than with each component creation
   */

  defineModule(module, FluxComponent = (function(superClass) {
    extend(FluxComponent, superClass);

    FluxComponent.abstractClass();

    function FluxComponent() {
      FluxComponent.__super__.constructor.apply(this, arguments);
      this["class"]._prepareSubscriptions();
    }

    FluxComponent.subscriptions = function() {
      var args, options, ref3, stateField;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      ref3 = parseSubscriptions(args);
      for (stateField in ref3) {
        options = ref3[stateField];
        this._addSubscription(stateField, options);
      }
      return null;
    };

    FluxComponent.prototype._preprocessProps = function(newProps) {
      this._updateAllSubscriptions(newProps = FluxComponent.__super__._preprocessProps.apply(this, arguments));
      return newProps;
    };

    FluxComponent.prototype.componentWillUnmount = function() {
      FluxComponent.__super__.componentWillUnmount.apply(this, arguments);
      return this.unsubscribeAll();
    };

    FluxComponent.extendableProperty({
      subscriptionProperties: {}
    });

    FluxComponent._addSubscription = function(stateField, subscriptionOptions) {
      var existingGetters, failureInfoField, progressField, statusField;
      if (this.getSubscriptionProperties()[stateField]) {
        throw new Error("subscription already defined for: " + (formattedInspect({
          stateField: stateField
        })));
      }
      this.extendSubscriptionProperties(stateField, subscriptionOptions);
      existingGetters = /element/;
      if (!stateField.match(existingGetters)) {
        this.addGetter(stateField, function() {
          return this.state[stateField];
        });
        this.addGetter((statusField = stateField + "Status"), function() {
          return this.state[statusField];
        });
        this.addGetter((progressField = stateField + "Progress"), function() {
          return this.state[progressField];
        });
        return this.addGetter((failureInfoField = stateField + "FailureInfo"), function() {
          return this.state[failureInfoField];
        });
      }
    };

    FluxComponent._prepareSubscription = function(subscription) {
      var key, model, modelName, stateField;
      stateField = subscription.stateField, model = subscription.model, key = subscription.key;
      subscription.propsToModel = (function() {
        switch (false) {
          case !isFunction(model):
            return model;
          case !isString(modelName = model):
            if (!(model = ArtModelRegistry.models[model])) {
              throw new Error((this.getName()) + "::subscriptions() model '" + modelName + "' not registered (" + (this.getNamespacePath()) + ")");
            }
            return function() {
              return model;
            };
          default:
            if (!model) {
              throw new Error("no model specified in subscription: " + (formattedInspect({
                stateField: stateField,
                model: model,
                "class": this.name,
                subscription: subscription
              })));
            }
        }
      }).call(this);
      return subscription.propsToKey = isFunction(key) ? key : key != null ? function() {
        return key;
      } : void 0;
    };

    FluxComponent._prepareSubscriptions = function() {
      var ref3, results, stateField, subscription;
      if (this._subscriptionsPrepared) {
        return;
      }
      this._subscriptionsPrepared = true;
      ref3 = this.getSubscriptionProperties();
      results = [];
      for (stateField in ref3) {
        subscription = ref3[stateField];
        results.push(this._prepareSubscription(subscription));
      }
      return results;
    };

    FluxComponent.prototype._updateSubscription = function(stateField, key, model, props) {
      var initialData;
      return this.subscribe(stateField, model.modelName, key, {
        stateField: stateField,
        initialModelRecord: (initialData = props[stateField]) ? {
          status: success,
          data: initialData
        } : void 0
      });
    };

    FluxComponent.prototype._updateAllSubscriptions = function(props) {
      var error, key, model, modelName, propsToKey, propsToModel, ref3, stateField, subscriptionProps;
      if (props == null) {
        props = this.props;
      }
      ref3 = this["class"].getSubscriptionProperties();
      for (stateField in ref3) {
        subscriptionProps = ref3[stateField];
        propsToKey = subscriptionProps.propsToKey, propsToModel = subscriptionProps.propsToModel;
        model = (function() {
          try {
            return propsToModel(props, stateField);
          } catch (error1) {
            error = error1;
            log.error(error);
            log.error({
              "UpdateSubscription propsToModel error": {
                FluxComponent: this,
                stateField: stateField,
                subscriptionProps: subscriptionProps,
                props: props
              }
            });
            return null;
          }
        }).call(this);
        if (isString(modelName = model)) {
          if (!(model = this.models[modelName])) {
            log.error({
              "UpdateSubscription could not find model-name returned from propsToModel": {
                FluxComponent: this,
                stateField: stateField,
                subscriptionProps: subscriptionProps,
                props: props,
                modelName: modelName
              }
            });
          }
        }
        if (model) {
          key = (function() {
            try {
              if (propsToKey != null) {
                return propsToKey(props, stateField);
              } else {
                return model.propsToKey(props, stateField);
              }
            } catch (error1) {
              error = error1;
              log.error(error);
              log.error({
                "UpdateSubscription propsToKey error": {
                  FluxComponent: this,
                  stateField: stateField,
                  subscriptionProps: subscriptionProps,
                  props: props
                }
              });
              return null;
            }
          }).call(this);
          this._updateSubscription(stateField, key, model, props);
        }
      }
      return null;
    };

    FluxComponent.prototype._componentDidHotReload = function() {
      this.unsubscribeAll();
      this._updateAllSubscriptions();
      return FluxComponent.__super__._componentDidHotReload.apply(this, arguments);
    };

    FluxComponent.postCreateConcreteClass = function(arg) {
      var hotReloaded;
      hotReloaded = arg.hotReloaded;
      if (this.prototype.subscriptions) {
        this.subscriptions(this.prototype.subscriptions);
      }
      this._subscriptionsPrepared = false;
      if (hotReloaded) {
        this._prepareSubscriptions();
      }
      return FluxComponent.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
    };

    return FluxComponent;

  })(ArtModelSubscriptionsMixin(Component)));

}).call(this);

//# sourceMappingURL=FluxComponent.js.map
