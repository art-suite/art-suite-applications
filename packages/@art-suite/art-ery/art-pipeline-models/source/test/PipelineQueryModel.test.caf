import &StandardImport


describe
  noop: -> test "noop" -> assert.eq 1, 1
  pre2020Style: ->
    {pipelineRegistry, modelRegistry: {models}, defineModelsForAllPipelines} = newRegistries()
    class Post extends Pipeline
      @registry pipelineRegistry
      @query postsByUserId: (request) ->
        []
          userId: request.key, message: "Hi!"
          userId: request.key, message: "Really?"

      @publicRequestTypes :postsByUserId

      @filter after: all: (response) ->
        response.withData
          array record in response.data
            merge record, message: "#{record.message} :)"

    defineModelsForAllPipelines()

    test "query model defined", ->
      assert.instanceOf
        models.postsByUserId
        PipelineQueryModel
        formattedInspect
          definedModels: Object.keys models
          lookingForModel: :postsByUserId

    test "query loadData goes through pipeline", ->
      models.postsByUserId.loadData "abc123"
      .then (res) ->
        assert.eq res, []
          userId: "abc123", message: "Hi! :)"
          userId: "abc123", message: "Really? :)"

  2020Style:
    basic: ->
      messagesByUserId = null
      {pipelineRegistry, modelRegistry, models, defineModelsForAllPipelines} = newRegistries()
      class Message extends Pipeline
        @registry pipelineRegistry

        @query
          byUserId:
            query: (request) ->
              []
                userId: request.key, message: "Hi!"
                userId: request.key, message: "Really?"
            keyFields: [] :userId

        @publicRequestTypes :byUserId

        @filter after: all: (response) ->
          response.withData
            array record in response.data
              merge record, message: "#{record.message} :)"

      {messagesByUserId} = defineModelsForAllPipelines()

      test "query model defined", ->
        assert.instanceOf messagesByUserId, PipelineQueryModel

      test "query loadData goes through pipeline", ->
        messagesByUserId.loadData "abc123"
        .then (res) ->
          assert.eq res, []
            userId: "abc123", message: "Hi! :)"
            userId: "abc123", message: "Really? :)"

      test "queryModel.propsToKey" ->
        assert.eq :user1    messagesByUserId.propsToKey user: id: :user1
        # assert.eq :user2    user.propsToKey userId: :user2
        # assert.eq :user3    user.propsToKey(user: {id: :user3}, userId: :user4), "" whole object has precidence
        # assert.eq undefined user.propsToKey {}

    codeReuse: ->
      {pipelineRegistry, modelRegistry, models, defineModelsForAllPipelines} = newRegistries()

      class UserOwned extends Pipeline
        @registry pipelineRegistry
        @query byUserId: (request) ->
          []
            userId: request.key, message: "Hi!"
            userId: request.key, message: "Really?"

        @publicRequestTypes :byUserId

        @filter after: all: (response) ->
          response.withData
            array record in response.data
              merge record, message: "#{response.pipeline.name}: #{record.message} :)"

      class Email extends UserOwned
      class Photo extends UserOwned

      defineModelsForAllPipelines()

      test "query model defined", ->
        assert.instanceOf models.emailsByUserId, PipelineQueryModel
        assert.instanceOf models.photosByUserId, PipelineQueryModel

      test "query loadData goes through pipeline", ->
        models.emailsByUserId.loadData "abc123"
        .then (res) ->
          assert.eq res, []
            userId: "abc123", message: "email: Hi! :)"
            userId: "abc123", message: "email: Really? :)"
