"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["compactFlatten", "Validator", "present", "isPlainObject", "isString", "log", "Error"], [global, require('art-standard-lib'), require('art-validation')], (compactFlatten, Validator, present, isPlainObject, isString, log, Error) => {return {KeyFieldsMixin: function(superClass) {let KeyFieldsMixin; return KeyFieldsMixin = Caf.defClass(class KeyFieldsMixin extends superClass {}, function(KeyFieldsMixin, classSuper, instanceSuper) {let defaultKeyFieldsString, keyFields; this.abstractClass(); this.getKeyFields = function() {return this._keyFields;}; this.getKeyFieldsString = function() {return this._keyFieldsString;}; this._keyFieldsString = defaultKeyFieldsString = "id"; this._keyFields = [defaultKeyFieldsString]; this.primaryKey = keyFields = function(...args) {return this._keyFieldsString = (this._keyFields = compactFlatten(Caf.array(compactFlatten(args), (v) => v.split("/")))).join("/");}; this.keyFields = keyFields; this.classGetter({keyValidator: function() {let fields, temp; return ((temp = this._keyValidator) != null ? temp : this._keyValidator = new Validator((fields = Caf.isF(this.getFields) && this.getFields()) ? Caf.object(this.getKeyFields(), (fieldName) => fields[fieldName], (fieldName) => fields[fieldName]) : Caf.object(this.getKeyFields(), (fieldName) => "required string")));}}); this.getter({keyFieldsString: function() {return this.class._keyFieldsString;}, keyFields: function() {return this.class._keyFields;}, keyValidator: function() {return this.class.keyValidator;}}); this.prototype.allKeyFieldsPresent = function(data) {let temp; return ((temp = Caf.find(this.keyFields, (keyField) => false, (keyField) => !present(data[keyField]))) != null ? temp : true);}; this.prototype.isRecord = function(data) {return isPlainObject(data) && this.allKeyFieldsPresent(data);}; this.prototype.dataToKeyString = function(a) {this.validateKey(a); return Caf.array(this.keyFields, (field) => a[field]).join("/");}; this.getter({propsToKey: function() {let fMap, temp; return ((temp = this._propsToKey) != null ? temp : this._propsToKey = (this.keyFields.length === 1) ? this._createPropsToKeyFunction(this.keyFields[0]) : (fMap = Caf.object(this.keyFields, (v) => this._createPropsToKeyFunction(v)), (props) => Caf.object(fMap, (f) => f(props))));}}); this.prototype.toKeyObject = function(a) {let splitInput, keyObject; return this.validateKey(isPlainObject(a) ? Caf.object(this.keyFields, (v) => a[v]) : isString(a) ? (this.keyFields.length > 1) ? (splitInput = a.split("/"), keyObject = Caf.object(this.keyFields, (v, i) => splitInput[i]), (splitInput.length !== this.keyFields.length) ? log.warn({KeyFieldsMixin_toKeyObject: {message: "wrong number of /-delimited fields in key-string", pipelineName: this.pipelineName, input: a, splitInput, keyFields: this.keyFields, usingKeyObject: keyObject}}) : undefined, keyObject) : {[this.keyFields[0]]: a} : (() => {throw new Error("Expecting string or plain object");})());}; this.prototype.dataWithoutKeyFields = function(data) {return data && Caf.object(data, null, (v, k) => !(Caf.in(k, this.keyFields)));}; this.prototype.preprocessKey = function(key) {return this.keyValidator.preprocess(key);}; this.prototype.validateKey = function(key) {return this.keyValidator.validate(key);}; this.prototype._createPropsToKeyFunction = function(keyField) {let recordName, matches, propsIdField, propsField; return (keyField === "id") ? (recordName = this.recordName, (props, stateField) => {let temp, base; propsField = stateField != null ? stateField : recordName; return ((temp = Caf.exists(base = props[propsField]) && base.id) != null ? temp : props[propsField + "Id"]);}) : (matches = keyField.match(/^(.+)Id$/)) ? (([propsIdField, propsField] = matches), (props) => {let temp, base; return ((temp = Caf.exists(base = props[propsField]) && base.id) != null ? temp : props[propsIdField]);}) : (props) => props[keyField];};});}};});});
//# sourceMappingURL=KeyFieldsMixin.js.map
