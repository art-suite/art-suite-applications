"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "ApplicationState", "Object", "String", "test", "formattedInspect", "Promise", "FluxComponent", "assert", "success", "models", "Element", "setup", "FluxModel", "timeout"], [global, require('./StandardImport')], (describe, ApplicationState, Object, String, test, formattedInspect, Promise, FluxComponent, assert, success, models, Element, setup, FluxModel, timeout) => {let resetAll, myModelSetup, testSubscriptionDefinition; resetAll = function() {return require('../')._reset();}; myModelSetup = function() {return resetAll().then(() => {let MyModel; return MyModel = Caf.defClass(class MyModel extends ApplicationState {}, function(MyModel, classSuper, instanceSuper) {this.stateFields({myField: null, myField2: null});});});}; testSubscriptionDefinition = function(description, subscriptionDefinition, expected = "alice") {let stateField, a, b, statusField; stateField = (Caf.is(subscriptionDefinition, Object)) ? Object.keys(subscriptionDefinition)[0] : (Caf.is(subscriptionDefinition, String)) ? (([a, b] = subscriptionDefinition.split(".")), b != null ? b : subscriptionDefinition) : undefined; statusField = `${Caf.toString(stateField)}Status`; return test(`${Caf.toString(description)}: ${Caf.toString(formattedInspect(subscriptionDefinition))}`, () => new Promise((resolve, reject) => {let MyComponent, myComponent; MyComponent = MyComponent = Caf.defClass(class MyComponent extends FluxComponent {}, function(MyComponent, classSuper, instanceSuper) {this.subscriptions(subscriptionDefinition); this.prototype.componentWillUpdate = function(newProps, newState) {return newState[stateField] ? Promise.then(() => assert.eq(newState[stateField], expected)).then(resolve, reject) : undefined;}; this.prototype.render = function() {return Element({});};}); (myComponent = MyComponent({myModelId: "myField", myModelId2: "myField2", myCustomNameId: "myField2", myCustomName2: {id: "myField2"}, myModelName: "myModel"}))._instantiate(); assert.eq(myComponent.state[statusField], success); models.myModel.myField = "alice"; return models.myModel.myField2 = "bob";}));}; return describe({getters: function() {setup(myModelSetup); test("models getter", () => new Promise((resolve) => {let MyComponent; MyComponent = MyComponent = Caf.defClass(class MyComponent extends FluxComponent {}, function(MyComponent, classSuper, instanceSuper) {this.subscriptions("myModel.myField"); this.prototype.test = function() {return this.models.myModel.myField = "honor";}; this.prototype.render = function() {if (this.state.myField === "honor") {resolve();}; return Element();};}); return MyComponent()._instantiate().test();})); return test("subscription field getters", () => new Promise((resolve) => {let MyComponent; MyComponent = MyComponent = Caf.defClass(class MyComponent extends FluxComponent {}, function(MyComponent, classSuper, instanceSuper) {this.subscriptions("myModel.myField"); this.prototype.render = function() {if (this.myField === "bob") {resolve();}; return Element({});};}); MyComponent()._instantiate(); return models.myModel.myField = "bob";}));}, initialValues: function() {setup(resetAll); test("subscriptions - component with subscription to model with immediate result only renders once", () => new Promise((resolve) => {let MyModel, renderCount, MyComponent, myComponent; MyModel = Caf.defClass(class MyModel extends FluxModel {}, function(MyModel, classSuper, instanceSuper) {this.prototype.load = function(key) {return {data: key, status: success};};}); renderCount = 0; MyComponent = MyComponent = Caf.defClass(class MyComponent extends FluxComponent {}, function(MyComponent, classSuper, instanceSuper) {this.subscriptions({myModel: function() {return "hi";}}); this.prototype.render = function() {renderCount++; assert.eq(renderCount, 1); timeout(50, () => resolve()); return Element({});};}); return (myComponent = MyComponent())._instantiate();})); test("subscription with initial value passed in as prop should not trigger load", () => new Promise((resolve) => {let User, MyComponent; User = Caf.defClass(class User extends FluxModel {}, function(User, classSuper, instanceSuper) {this.prototype.load = function() {return assert.fail("not expecting model.load");};}); MyComponent = MyComponent = Caf.defClass(class MyComponent extends FluxComponent {}, function(MyComponent, classSuper, instanceSuper) {this.subscriptions("user"); this.prototype.render = function() {assert.eq(this.state.user, {name: "george", id: "124"}); timeout(50, () => resolve()); return Element({});};}); return MyComponent({user: {id: "124", name: "george"}})._instantiate();})); return test("subscriptions - post - declarative subscriptions", () => new Promise((resolve) => myModelSetup().then(() => {let MyComponent; MyComponent = MyComponent = Caf.defClass(class MyComponent extends FluxComponent {}, function(MyComponent, classSuper, instanceSuper) {this.subscriptions("myModel.myField"); this.prototype.render = function() {if (this.myField === "bob") {resolve();}; return Element({});};}); models.myModel.myField = "bob"; return models.myModel.onNextReady(() => MyComponent()._instantiate());})));}, "subscriptions declaration types": {"stateFields == modelName": function() {setup(myModelSetup); testSubscriptionDefinition("simplest", "myModel", {myField: "alice", myField2: "bob"}); testSubscriptionDefinition("dot-hard-coded key", "myModel.myField2", "bob"); testSubscriptionDefinition("hard-coded key", {myModel: "myField2"}, "bob"); testSubscriptionDefinition("custom propsToKey", {myModel: () => "myField2"}, "bob"); return testSubscriptionDefinition("custom modelToKey", {myModel: ({myModelId}) => myModelId});}, "custom stateField name": function() {setup(myModelSetup); testSubscriptionDefinition("explicit model and key", {anyName: {key: "myField", model: "myModel"}}); testSubscriptionDefinition("custom modelToKey", {anyName: {key: "myField", model: ({myModelName}) => myModelName}}); testSubscriptionDefinition("custom propsToKey and modelToKey", {anyName: {model: ({myModelName}) => myModelName, key: ({myModelId2}) => myModelId2}}, "bob"); return testSubscriptionDefinition("test stateField is passed as second argument", {myCustomName: {model: (props, stateField) => {assert.eq(stateField, "myCustomName"); return "myModel";}, key: (props, stateField) => {assert.eq(stateField, "myCustomName"); return "myField";}}});}, "two fields, one model": function() {setup(myModelSetup); return test("two fields with the same model", () => new Promise((resolve) => {let MyComponent, myComponent; MyComponent = MyComponent = Caf.defClass(class MyComponent extends FluxComponent {}, function(MyComponent, classSuper, instanceSuper) {this.subscriptions("myModel.myField myModel.myField2"); this.prototype.preprocessState = function(newState) {if (newState.myField && newState.myField2 && newState.myFieldStatus === success && newState.myField2Status === success) {assert.eq(newState.myField, {name: "bill"}); assert.eq(newState.myField2, {name: "alice"}); resolve();}; return newState;}; this.prototype.render = function() {return Element({});};}); (myComponent = MyComponent())._instantiate(); models.myModel.myField = {name: "bill"}; return models.myModel.myField2 = {name: "alice"};}));}}});});});
//# sourceMappingURL=ModelComponent.test1disabled.js.map
