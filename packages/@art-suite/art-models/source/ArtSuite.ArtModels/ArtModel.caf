import &StandardImport, &@ArtSuite/InstanceFunctionBindingMixin, &ModelStore, &ModelRegistry

class ArtModel extends InstanceFunctionBindingMixin BaseObject
  @abstractClass()

  @extendableProperty
    modelRegistry: modelRegistry

  @declarable
    staleDataReloadSeconds:         null      # if >0, reload stale data as soon as its older than this number in seconds
    minNetworkFailureReloadSeconds: null      # if >0, and isFailure(modelRecord.status) is true, that record well get a model.reload(key) call within this number of seconds after the failure
    maxNetworkFailureReloadSeconds: Infinity  # repeated failed reloads retry with exponential fall offs; this caps the max interval for retrying
    minServerFailureReloadSeconds:  null      # if >0, and isFailure(modelRecord.status) is true, that record well get a model.reload(key) call within this number of seconds after the failure
    maxServerFailureReloadSeconds:  Infinity  # repeated failed reloads retry with exponential fall offs; this caps the max interval for retrying

  @getter
    autoReloadEnabled: ->
      @getStaleDataReloadSeconds() > 0 ||
      @getMinNetworkFailureReloadSeconds() > 0 ||
      @getMinServerFailureReloadSeconds() > 0

  # must call register to make model accessable to RestComponents
  # NOTE: @fields calls register for you, so if you use @fields, you don't need to call @register
  @register: ->
    @singletonClass()
    @getModelRegistry().register @

  @postCreateConcreteClass: ({hotReloaded}) ->
    if hotReloaded
      @singleton.bindFunctionsToInstance()
    else
      @register()
    super

  ## @aliases
    INPUT: zero or more strings or arrays of strings
      - arbitrary nesting of arrays is OK
      - nulls are OK, they are ignored
    OUTPUT: null

    NOTE: @aliases can be called multiple times.

    example:
      class Post extends ArtModel
        @aliases "chapterPost"

    purpose:
      - declare alternative names to access this model.
      - allows you to use the shortest form of Components subscriptions for each alias:
          @subscriptions "chapterPost"
        in addition to the model's class name:
          @subscriptions "post"
  @aliases: (args...) ->
    @_aliases = compactFlatten [args, @_aliases]
    null

  @_aliases: []

  onNextReady: (f) -> @modelStore.onNextReady f

  constructor: (name)->
    @_name = name || decapitalize @class.getName()
    @bindFunctionsToInstance()
    @_activeLoadingRequests = {}

  register: ->
    log.warn "DEPRICATED: ArtModel#register is no longer used. Instead, the class is registered automatically post-create."

  @classGetter
    models: -> @getModelRegistry().models
    modelStore: -> @getModelRegistry().modelStore

  @getter
    models: -> @modelRegistry.models
    modelStore: -> @getModelRegistry().modelStore
    singlesModel: -> @_singlesModel || @
    modelStoreEntries: -> @modelStore.getEntriesForModel @name

  # DEPRICATED
  subscribe: (modelKey, subscriptionFunction) ->
    log.error "DEPRICATED - mix ArtModelSubscriptionsMixin into your class, and use it's methods to subscribe to models"
    @modelStore.subscribe @_name, modelKey, subscriptionFunction

  @getter
    :name
    modelName: -> @_name

  ## load:
    load the requested data for the given key and update the modelStore

    required:
      Should ALWAYS call modelStore.update immediately OR once the data is available.
      Clients will assume that a call to "load" forces a reload of the data in the modelStore.

    optional:
      If the data is immediately available, you can return the modelRecord instead of "null"
      If load was called because of a new Component being mounted and its subscriptions initialized,
        returning the modelRecord immediately will guarantee the Component has valid data for its
        first render.

    Note:
      Typically called automatically by the modelStore when a Component subscribes to
      data from this model with the given key.

    The simplest possible load function:
      load: (key) -> @updateModelRecord key, {}

    The "load" function below is:
      Simplest "load" with immediate modelRecord return.
      Immediate return means:
      - modelStore.subscribe() will return the modelRecord returned from this "load"
      - Components subscriptions will update state in time for the inital render.

    inputs:
      key: string

    side effects:
      expected to call modelStore.update @_name, key, modelRecord
        - when modelRecord.status is no longer pending
        - optionally as progress is made loading the modelRecord.data

    returns: null OR modelRecord if the value is immediately available
      NOTE: load can return null or modelRecord as it chooses. The client shouldn't
        rely on the fact that it returned a modelRecord with a set of inputs, it might not
        the next time.

    Optionally, you can implement one of two altenative load functions with Promise support:

      loadData:       (key) ->
                        promise.then (data) ->
                          if data is null or undefined, status will be set to missing
                          otherwise, status will be success
                        promise.catch (a validStatus or error info, status becomes failure) ->
      loadModelRecord: (key) -> promise.then (modelRecord) ->

      @load will take care of updating ModelStore.
  load: (key) ->
    # ensure modelStore is updated in case this is not beind called from the modelStore itself
    # returns {status: missing} since updateModelRecord returns the last argument,
    #   this makes the results immediately available to subscribers.
    if @loadData || @loadModelRecord
      @loadPromise key
      null
    else
      @updateModelRecord key, status: missing

  ## loadPromise:
    NOTE: @loadData or @loadModelRecord should be implemented.
    @loadPromise is an alternative to @load

    Unlike @load, @loadPromise returns a promise that resolves when the load is done.

    The down-side is @loadPromise cannot immediately update the ModelStore. If you have
    a model which stores its data locally, like ApplicationState, then override @load
    for immediate modelStore updates.

    However, if your model always has to get the data asynchronously, override @loadData
    or @loadModelRecord and use @loadPromise anytime you need to manually trigger a load.

    EFFECTS:
    - Triggers loadData or loadModelRecord.
    - Puts the results in the modelStore.
    - Elegently reduces multiple in-flight requests with the same key to one Promise.
      @loadData or @loadModelRecord will only be invoked once per key while their
      returned promises are unresolved.
      NOTE: the block actually extends all the way through to the modelStore being updated.
      That means you can immediately call @getModelRecord and get the latest data - when
      the promise resolves.

    OUT: promise.then (modelRecord) ->
      modelRecord: the latest, just-loaded data
      ERRORS: errors are encoded into the modelRecord. The promise should always resolve.
  loadPromise: (key) ->
    @_activeLoadingRequests[key] ?=
      if @loadData
        Promise.then    -> @loadingRecord key
        .then           -> @loadData key
        .then (data)    -> @updateModelRecord key, if data? then {data, status: success} else status: missing
        .catch (error)  ->
          status = if validStatus status = error?.info?.status || error
            status
          else failure
          info = error?.info
          error = null unless error instanceof Error
          @updateModelRecord key, {status, info, error}

      else if @loadModelRecord
        @loadModelRecord key
        .then (modelRecord) -> @updateModelRecord key, modelRecord
        .catch (error)     -> @updateModelRecord key, status: failure, error: error
      else
        Promise.resolve @updateModelRecord key, status: missing

      .tap -> @onNextReady()
      .then (result) -> @_activeLoadingRequests[key] = null; result

  # load is not required to updateModelRecord
  # reload guarantees modelStore is updated
  # override reload if your load does not always updateModelRecord (eventually)
  reload: (key) ->
    if @loadData || @loadModelRecord
          @loadPromise key
    else  @load key

  # called before actually calling @loadData within @loadPromise
  # EFFECT: marks record status as pending if it was previously a failure
  #   If it was previously a success, subscribers should keep showing the previously
  #   successful load until the new one completes.
  loadingRecord: (key) ->
    if isFailure (modelRecord = @getModelRecord key)?.status
      @updateModelRecord key, merge modelRecord, status: pending

  getModelRecord:     (key) -> @modelStore.get @_name, @toKeyString key
  updateModelRecord:  (key, modelRecord) -> @modelStore.update @_name, key, modelRecord

  onModelRegistered: (modelName) -> @modelRegistry.onModelRegistered modelName

  # IN: key
  # OUT: promise.then data
  # EFFECT: if already loaded in modelStore, just returns what's in ModelStore
  get: (key) ->
    key = @toKeyString key
    Promise.then ->
      if (currentModelRecord = @getModelRecord(key))?.status == pending
        currentModelRecord = null

      currentModelRecord ? @loadPromise key

    .then (modelRecord)->
      modelRecord extract status, data
      unless status == success
        throw new ErrorWithInfo "ArtModel#get: Error getting data. Status: #{status}." {} status, modelRecord

      data

  ###################################################
  # OVERRIDES - Non-String Keys
  ###################################################
  # Override to support non-string keys
  # return: string representation of key
  toKeyString: (key) ->
    if isPlainObject key then @dataToKeyString key
    else if isString key then key
    else
      throw new Error "ArtModel #{@name}: Must implement
        custom toKeyString for
        non-string keys like: #{formattedInspect key}"

  dataToKeyString: (obj) ->
    throw new Error "ArtModel #{@name}: must override dataToKeyString for converting objects to key-strings."

  @getRecordPropsToKeyFunction: (recordType) ->
    (props, stateField) ->
      propsField = stateField ? recordType
      props[propsField]?.id ? props[propsField + "Id"]

  @getter
    propsToKey: -> @_propsToKey ?= ArtModel.getRecordPropsToKeyFunction @modelName

  ###################################################
  # OVERRIDES - Events
  ###################################################
  # Override to respond to entries being added or removed from the ModelStore

  # called when an entry is updated OR added OR if it is about to be removed
  # this is called before modelStoreEntryAdded or modelStoreEntryRemoved
  modelStoreEntryUpdated: (entry) ->

  # called only when an entry is added
  modelStoreEntryAdded: (entry) ->

  # called when an entry was moved (when subscriber count goes to 0)
  modelStoreEntryRemoved: (entry) ->

  # called after the model has been registered
  modelRegistered: ->
