import &StandardImport, {} &ApplicationState


newRegistry = ->
  modelRegistry = new ModelRegistry
  class MyModel extends ApplicationState
    @modelRegistry modelRegistry
  modelRegistry

describe
  subscribeOnModelRegistered: ->

    test "subscribeOnModelRegistered" ->
      new Promise (resolve, reject) ->
        {models} = modelRegistry = newRegistry()
        class MyModelB extends Model
          @modelRegistry modelRegistry

        class MyModelA extends ModelSubscriptionsMixin Model
          @modelRegistry modelRegistry

          constructor: ->
            @subscribeOnModelRegistered :mySubscriptionKey :myModelB :myModelKey updatesCallback: ->
            .then resolve, reject

  "subscribe and initialModelRecord": ->

    test "with stateField and initialModelRecord" ->
      {models, modelStore} = modelRegistry = newRegistry()

      new class MyObject extends ModelSubscriptionsMixin BaseObject
        @modelRegistry modelRegistry

        constructor: ->
          @subscribe :mySubscriptionKey :myModel :myModelKey,
            initialModelRecord: data: :myInitialData
            stateField: :myStateField

      assert.selectedEq
        status:         pending
        data:           :myInitialData
        key:            :myModelKey
        modelName:      :myModel
        modelStore.get  :myModel :myModelKey

      modelStore.onNextReady()

    test "with stateField and no initialModelRecord" ->
      {models, modelStore} = modelRegistry = newRegistry()

      new class MyObject extends ModelSubscriptionsMixin BaseObject
        @modelRegistry modelRegistry

        constructor: -> @subscribe :mySubscriptionKey :myModel :myModelKey, stateField: :myStateField

      assert.selectedEq
        status:     missing
        key:        "myModelKey"
        modelName:  "myModel"
        modelStore.get "myModel", "myModelKey"
