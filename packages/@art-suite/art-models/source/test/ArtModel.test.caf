import &StandardImport

newRegistry = -> new ArtModelRegistry

describe
  load: ->
    test "model with async load" ->
      {modelStore} = registry = newRegistry()
      new Promise (resolve) ->
        class MyBasicModel extends ArtModel
          @registry registry
          load: (key) ->
            modelStore.onNextReady => @updateModelRecord key, status: missing
            null

        res = modelStore.subscribe :myBasicModel :123 (modelRecord) ->
          return unless modelRecord.status != pending
          assert.selectedEq
            status: missing, key: :123 modelName: :myBasicModel
            modelRecord

          resolve()

        assert.selectedEq
          status: pending, key: :123 modelName: :myBasicModel
          res

    test "model with @loadModelRecord" ->
      {modelStore} = registry = newRegistry()
      new Promise (resolve) ->
        class MyBasicModel extends ArtModel
          @registry registry
          loadModelRecord: (key) -> timeout(20).then -> status: missing

        res = modelStore.subscribe :myBasicModel :123 (modelRecord) ->
          return unless modelRecord.status != pending
          assert.selectedEq
            status: missing, key: :123 modelName: :myBasicModel
            modelRecord
          resolve()
        assert.selectedEq
          status: pending, key: :123 modelName: :myBasicModel
          res

    test "model with custom load - delayed" ->
      {modelStore} = registry = newRegistry()
      class MyBasicModel extends ArtModel
        @registry registry
        load: (key, callback) ->
          @updateModelRecord key, -> status: success, data: theKeyIs:key
          null

      new Promise (resolve) ->
        res = modelStore.subscribe :myBasicModel :123 (modelRecord) ->
          assert.selectedEq
            status: success, key: :123 modelName: :myBasicModel data: theKeyIs: :123
            modelRecord
          resolve()
        assert.selectedEq
          status: pending, key: :123 modelName: :myBasicModel
          res

      .then ->
        new Promise (resolve) ->
          modelStore.subscribe :myBasicModel :456 (modelRecord) ->
            assert.selectedEq
              status: success, key: :456 modelName: :myBasicModel data: theKeyIs: :456
              modelRecord
            resolve()

    test "model with custom load - immediate" ->
      {modelStore} = registry = newRegistry()
      class MyBasicModel extends ArtModel
        @registry registry
        load: (key, callback) -> @updateModelRecord key, status: success, data: theKeyIs:key

      new Promise (resolve, reject) ->
        res = modelStore.subscribe :myBasicModel :123 (modelRecord) ->
          log.error "THIS SHOULDN'T HAPPEN!"
          reject()

        assert.selectedEq
          status: success, key: :123 modelName: :myBasicModel data: theKeyIs: :123
          res

        modelStore.onNextReady resolve

    test "model with @loadData" ->
      {modelStore} = registry = newRegistry()
      class MyBasicModel extends ArtModel
        @registry registry
        loadData: (key) -> Promise.resolve theKeyIs:key

      new Promise (resolve) ->
        modelStore.subscribe :myBasicModel :123 (modelRecord) ->
          assert.selectedEq
            status: success, key: :123 modelName: :myBasicModel data: theKeyIs: :123
            modelRecord

          resolve()

      .then ->
        new Promise (resolve) ->
          modelStore.subscribe :myBasicModel :456 (modelRecord) ->
            assert.selectedEq
              status: success, key: :456 modelName: :myBasicModel data: theKeyIs: :456
              modelRecord

            resolve()

  simultanious: ->
    test "two simultantious ArtModel requests on the same key only triggers one modelStore request" ->
      {modelStore} = registry = newRegistry()
      counts =
        load:          0
        subscription1: 0
        subscription2: 0
      class MyBasicModel extends ArtModel
        @registry registry
        load: (key, callback) ->
          counts.load++
          @updateModelRecord key, status: success, data: theKeyIs:key

      modelStore.subscribe :myBasicModel :123 (modelRecord) -> assert.eq(modelRecord.count, 2);counts.subscription1++
      modelStore.subscribe :myBasicModel :123 (modelRecord) -> assert.eq(modelRecord.count, 2);counts.subscription2++

      modelStore.update    :myBasicModel :123 (modelRecord) -> count: (modelRecord.count || 0)+ 1
      modelStore.update    :myBasicModel :123 (modelRecord) -> count: (modelRecord.count || 0)+ 1

      modelStore.onNextReady ->
        assert.eq counts, load: 1, subscription1: 1, subscription2: 1

    test "two simultantious ArtModel requests on the different keys triggers two modelStore requests", ->
      {modelStore} = registry = newRegistry()
      counts =
        load: 0
        sub1: 0
        sub2: 0

      class MyBasicModel extends ArtModel
        @registry registry
        load: (key, callback) ->
          counts.load++
          @updateModelRecord key, status: success, data: theKeyIs:key

      modelStore.subscribe :myBasicModel :123 (modelRecord) -> assert.eq(modelRecord.count, 1); counts.sub1++
      modelStore.subscribe :myBasicModel :456 (modelRecord) -> assert.eq(modelRecord.count, 1); counts.sub2++

      modelStore.update    :myBasicModel :123 (modelRecord) -> count: (modelRecord.count ? 0)+ 1
      modelStore.update    :myBasicModel :456 (modelRecord) -> count: (modelRecord.count ? 0)+ 1

      modelStore.onNextReady ->
        assert.eq counts, load: 2, sub1: 1, sub2: 1

  loadPromise: ->
    test "multiple loadPromises with the same key only load once" ->
      {modelStore} = registry = newRegistry()
      loadCount = 0
      {user} = class User extends ArtModel
        loadData: (key) ->
          timeout 10
          .then ->
            loadCount++
            id: key
            userName: :fred

      p1 = user.loadPromise :abc
      p2 = user.loadPromise :abc
      p3 = user.loadPromise :def
      Promise.all [p1, p2, p3]
      .then ->
        assert.eq loadCount, 2
        assert.eq p1, p2
        assert.neq p1, p3

  aliases: ->
    test "@aliases adds aliases to the model registry" ->
      {modelStore, models} = registry = newRegistry()
      {user} = class User extends ArtModel
        @registry registry
        @aliases :owner :sister

      assert.eq user.class, User
      assert.eq user, models.owner
      assert.eq user, models.sister

  functionsBoundToInstances: ->
    test "use bound function" ->
      {modelStore} = registry = newRegistry()
      {user} = class User extends ArtModel
        @registry registry
        foo: -> @_foo =
          @_foo ? 0
          + 1

      user.foo(); assert.eq user._foo, 1
      user.foo(); assert.eq user._foo, 2
