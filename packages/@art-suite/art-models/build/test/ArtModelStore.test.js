"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["chainedTest", "test", "ArtModelRegistry", "ArtModel", "assert", "pending", "merge", "Promise", "missing"], [global, require('./StandardImport')], (chainedTest, test, ArtModelRegistry, ArtModel, assert, pending, merge, Promise, missing) => {let newRegistry; newRegistry = function() {let registry, MyModel; registry = new ArtModelRegistry; MyModel = Caf.defClass(class MyModel extends ArtModel {}, function(MyModel, classSuper, instanceSuper) {this.registry(registry);}); return registry;}; chainedTest("modelStore.update basic", function() {let modelStore; ({modelStore} = newRegistry()); modelStore.subscribe("myModel", "myKey", () => {}); modelStore.update("myModel", "myKey", {bar: 1}); return modelStore.onNextReady(() => {let modelRecord; assert.eq(modelStore.length, 1); assert.selectedEq({entryCount: 1, entrySubscribers: 1, modelCount: 1}, modelStore.status); assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, modelRecord = modelStore.get("myModel", "myKey")); assert.isNumber(modelRecord.updatedAt); assert.isNumber(modelRecord.createdAt); assert.lt(modelRecord.createdAt, modelRecord.updatedAt); return modelStore;});}).tapTest(["modelStoreEntry._getAndLogErrorMessage", function(modelStore) {let logged, myLog, error, message; logged = []; myLog = (a) => logged.push(a); error = {}; message = modelStore._entriesByModelName.myModel.myKey._getAndLogErrorMessage(error, "giggle", myLog); assert.isString(message); assert.true(Caf.in("giggle", message)); return assert.eq(logged.length, 1);}], ["modelStore.inspectedObjects", function(modelStore) {let inspectedObjects, myKey, createdAt, updatedAt; inspectedObjects = modelStore.inspectedObjects; myKey = inspectedObjects.myModel.myKey; createdAt = myKey.createdAt; updatedAt = myKey.updatedAt; assert.isNumber(createdAt); assert.isNumber(updatedAt); return assert.eq(inspectedObjects, {myModel: {myKey: {modelName: "myModel", key: "myKey", status: "pending", createdAt, updatedAt, subscriberCount: 1}}});}]); test("modelStore.update with no subscriber is noop", function() {let modelStore; ({modelStore} = newRegistry()); modelStore.update("myModel", "myKey", {bar: 1}); return modelStore.onNextReady(() => {assert.eq(modelStore.length, 0); return assert.eq(!!modelStore._getEntry("myModel", "myKey"), false);});}); test("modelStore.update twice replaces old value", function() {let modelStore; ({modelStore} = newRegistry()); modelStore.subscribe("myModel", "myKey", () => {}); modelStore.update("myModel", "myKey", {bar: 1}); modelStore.update("myModel", "myKey", {baz: 2}); return modelStore.onNextReady(() => {assert.eq(modelStore.length, 1); return assert.selectedEq({status: pending, baz: 2, key: "myKey", modelName: "myModel"}, modelStore.get("myModel", "myKey"));});}); test("modelStore.update with update function can merge", function() {let modelStore; ({modelStore} = newRegistry()); modelStore.subscribe("myModel", "myKey", () => {}); modelStore.update("myModel", "myKey", {bar: 1}); modelStore.update("myModel", "myKey", (old) => merge(old, {baz: 2})); return modelStore.onNextReady(() => {assert.eq(modelStore.length, 1); return assert.selectedEq({status: pending, bar: 1, baz: 2, key: "myKey", modelName: "myModel"}, modelStore.get("myModel", "myKey"));});}); test("modelStore.update cant set key", function() {let modelStore; ({modelStore} = newRegistry()); modelStore.subscribe("myModel", "myKey", () => {}); modelStore.update("myModel", "myKey", {bar: 1, key: "boggle"}); return modelStore.onNextReady(() => {assert.doesNotExist(modelStore.get("myModel", "boggle")); return assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, modelStore.get("myModel", "myKey"));});}); test("modelStore.update cant update key", function() {let modelStore; ({modelStore} = newRegistry()); modelStore.subscribe("myModel", "myKey", () => {}); modelStore.update("myModel", "myKey", {bar: 1}); return modelStore.onNextReady(() => {modelStore.update("myModel", "myKey", {bar: 1, key: "boggle2"}); return modelStore.onNextReady(() => assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, modelStore.get("myModel", "myKey")));});}); test("modelStore.subscribe basic", function() {let modelStore; ({modelStore} = newRegistry()); return new Promise((resolve) => {modelStore.subscribe("myModel", "myKey", (modelRecord, previousModelRecord) => {assert.selectedEq({status: missing, key: "myKey", modelName: "myModel"}, previousModelRecord); assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, modelRecord); return resolve();}); return modelStore.update("myModel", "myKey", {bar: 1});});}); test("modelStore.unsubscribe", function() {let modelStore, count1, count2, subscriber1, subscriber2; ({modelStore} = newRegistry()); count1 = 0; count2 = 0; subscriber1 = (modelRecord) => count1++; subscriber2 = (modelRecord) => count2++; modelStore.subscribe("myModel", "myKey", subscriber1); modelStore.subscribe("myModel", "myKey", subscriber2); modelStore.update("myModel", "myKey", {bar: 1}); return modelStore.onNextReady(() => {assert.eq(count1, 1); assert.eq(count2, 1); modelStore.unsubscribe("myModel", "myKey", subscriber2); modelStore.update("myModel", "myKey", {bar: 2}); return modelStore.onNextReady(() => {assert.eq(count1, 2); return assert.eq(count2, 1);});});}); test("modelStore model callbacks: modelStoreEntryUpdated, modelStoreEntryAdded, modelStoreEntryRemoved", function() {return new Promise((resolve) => {let modelStore, registry, updateCount, addedCount, removedCount, MyModel2, mySubscription; ({modelStore} = registry = newRegistry()); updateCount = addedCount = removedCount = 0; MyModel2 = Caf.defClass(class MyModel2 extends ArtModel {}, function(MyModel2, classSuper, instanceSuper) {this.registry(registry); this.prototype.modelStoreEntryUpdated = function(entry) {return updateCount++;}; this.prototype.modelStoreEntryAdded = function(entry) {return addedCount++;}; this.prototype.modelStoreEntryRemoved = function(entry) {assert.eq(2, updateCount); assert.eq(1, addedCount); assert.eq(1, ++removedCount); return resolve();};}); modelStore.subscribe("myModel2", "myKey", mySubscription = () => 123); return modelStore.onNextReady(() => modelStore.unsubscribe("myModel2", "myKey", mySubscription));});}); test("subscribe triggers load on model", function() {let modelStore, registry; ({modelStore} = registry = newRegistry()); return new Promise((resolve) => {let MyBasicModel; MyBasicModel = Caf.defClass(class MyBasicModel extends ArtModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.registry(registry); this.prototype.load = resolve;}); return modelStore.subscribe("myBasicModel", "123", (modelRecord) => null);});}); return test("subscribe with initial value does not trigger load on model nor subscription callback", function() {let modelStore, registry, MyBasicModel; ({modelStore} = registry = newRegistry()); MyBasicModel = Caf.defClass(class MyBasicModel extends ArtModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.registry(registry); this.prototype.load = function(key) {return assert.fail();};}); modelStore.subscribe("myBasicModel", "123", (modelRecord) => assert.fail(), {data: {foo: 1, bar: 2}}); return modelStore.onNextReady(() => {});});});});
//# sourceMappingURL=ArtModelStore.test.js.map
