"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "ArtModelRegistry", "test", "Promise", "ArtModel", "assert", "pending", "missing", "timeout", "success", "log"], [global, require('./StandardImport')], (describe, ArtModelRegistry, test, Promise, ArtModel, assert, pending, missing, timeout, success, log) => {let newRegistry; newRegistry = function() {return new ArtModelRegistry;}; return describe({load: function() {test("model with async load", () => {let modelStore, registry; ({modelStore} = registry = newRegistry()); return new Promise((resolve) => {let MyBasicModel, res; MyBasicModel = Caf.defClass(class MyBasicModel extends ArtModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.registry(registry); this.prototype.load = function(key) {modelStore.onNextReady(() => this.updateModelRecord(key, {status: missing})); return null;};}); res = modelStore.subscribe("myBasicModel", "123", (modelRecord) => {if (!(modelRecord.status !== pending)) {return;}; assert.selectedEq({status: missing, key: "123", modelName: "myBasicModel"}, modelRecord); return resolve();}); return assert.selectedEq({status: pending, key: "123", modelName: "myBasicModel"}, res);});}); test("model with @loadModelRecord", () => {let modelStore, registry; ({modelStore} = registry = newRegistry()); return new Promise((resolve) => {let MyBasicModel, res; MyBasicModel = Caf.defClass(class MyBasicModel extends ArtModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.registry(registry); this.prototype.loadModelRecord = function(key) {return timeout(20).then(() => {return {status: missing};});};}); res = modelStore.subscribe("myBasicModel", "123", (modelRecord) => {if (!(modelRecord.status !== pending)) {return;}; assert.selectedEq({status: missing, key: "123", modelName: "myBasicModel"}, modelRecord); return resolve();}); return assert.selectedEq({status: pending, key: "123", modelName: "myBasicModel"}, res);});}); test("model with custom load - delayed", () => {let modelStore, registry, MyBasicModel; ({modelStore} = registry = newRegistry()); MyBasicModel = Caf.defClass(class MyBasicModel extends ArtModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.registry(registry); this.prototype.load = function(key, callback) {this.updateModelRecord(key, () => {return {status: success, data: {theKeyIs: key}};}); return null;};}); return (new Promise((resolve) => {let res; res = modelStore.subscribe("myBasicModel", "123", (modelRecord) => {assert.selectedEq({status: success, key: "123", modelName: "myBasicModel", data: {theKeyIs: "123"}}, modelRecord); return resolve();}); return assert.selectedEq({status: pending, key: "123", modelName: "myBasicModel"}, res);})).then(() => new Promise((resolve) => modelStore.subscribe("myBasicModel", "456", (modelRecord) => {assert.selectedEq({status: success, key: "456", modelName: "myBasicModel", data: {theKeyIs: "456"}}, modelRecord); return resolve();})));}); test("model with custom load - immediate", () => {let modelStore, registry, MyBasicModel; ({modelStore} = registry = newRegistry()); MyBasicModel = Caf.defClass(class MyBasicModel extends ArtModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.registry(registry); this.prototype.load = function(key, callback) {return this.updateModelRecord(key, {status: success, data: {theKeyIs: key}});};}); return new Promise((resolve, reject) => {let res; res = modelStore.subscribe("myBasicModel", "123", (modelRecord) => {log.error("THIS SHOULDN'T HAPPEN!"); return reject();}); assert.selectedEq({status: success, key: "123", modelName: "myBasicModel", data: {theKeyIs: "123"}}, res); return modelStore.onNextReady(resolve);});}); return test("model with @loadData", () => {let modelStore, registry, MyBasicModel; ({modelStore} = registry = newRegistry()); MyBasicModel = Caf.defClass(class MyBasicModel extends ArtModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.registry(registry); this.prototype.loadData = function(key) {return Promise.resolve({theKeyIs: key});};}); return (new Promise((resolve) => modelStore.subscribe("myBasicModel", "123", (modelRecord) => {assert.selectedEq({status: success, key: "123", modelName: "myBasicModel", data: {theKeyIs: "123"}}, modelRecord); return resolve();}))).then(() => new Promise((resolve) => modelStore.subscribe("myBasicModel", "456", (modelRecord) => {assert.selectedEq({status: success, key: "456", modelName: "myBasicModel", data: {theKeyIs: "456"}}, modelRecord); return resolve();})));});}, simultanious: function() {test("two simultantious ArtModel requests on the same key only triggers one modelStore request", () => {let modelStore, registry, counts, MyBasicModel; ({modelStore} = registry = newRegistry()); counts = {load: 0, subscription1: 0, subscription2: 0}; MyBasicModel = Caf.defClass(class MyBasicModel extends ArtModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.registry(registry); this.prototype.load = function(key, callback) {counts.load++; return this.updateModelRecord(key, {status: success, data: {theKeyIs: key}});};}); modelStore.subscribe("myBasicModel", "123", (modelRecord) => {assert.eq(modelRecord.count, 2); return counts.subscription1++;}); modelStore.subscribe("myBasicModel", "123", (modelRecord) => {assert.eq(modelRecord.count, 2); return counts.subscription2++;}); modelStore.update("myBasicModel", "123", (modelRecord) => {return {count: (modelRecord.count || 0) + 1};}); modelStore.update("myBasicModel", "123", (modelRecord) => {return {count: (modelRecord.count || 0) + 1};}); return modelStore.onNextReady(() => assert.eq(counts, {load: 1, subscription1: 1, subscription2: 1}));}); return test("two simultantious ArtModel requests on the different keys triggers two modelStore requests", () => {let modelStore, registry, counts, MyBasicModel; ({modelStore} = registry = newRegistry()); counts = {load: 0, sub1: 0, sub2: 0}; MyBasicModel = Caf.defClass(class MyBasicModel extends ArtModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.registry(registry); this.prototype.load = function(key, callback) {counts.load++; return this.updateModelRecord(key, {status: success, data: {theKeyIs: key}});};}); modelStore.subscribe("myBasicModel", "123", (modelRecord) => {assert.eq(modelRecord.count, 1); return counts.sub1++;}); modelStore.subscribe("myBasicModel", "456", (modelRecord) => {assert.eq(modelRecord.count, 1); return counts.sub2++;}); modelStore.update("myBasicModel", "123", (modelRecord) => {let temp; return {count: (((temp = modelRecord.count) != null ? temp : 0)) + 1};}); modelStore.update("myBasicModel", "456", (modelRecord) => {let temp; return {count: (((temp = modelRecord.count) != null ? temp : 0)) + 1};}); return modelStore.onNextReady(() => assert.eq(counts, {load: 2, sub1: 1, sub2: 1}));});}, loadPromise: function() {return test("multiple loadPromises with the same key only load once", () => {let modelStore, registry, loadCount, user, User, p1, p2, p3; ({modelStore} = registry = newRegistry()); loadCount = 0; ({user} = User = Caf.defClass(class User extends ArtModel {}, function(User, classSuper, instanceSuper) {this.prototype.loadData = function(key) {return timeout(10).then(() => {loadCount++; return {id: key, userName: "fred"};});};})); p1 = user.loadPromise("abc"); p2 = user.loadPromise("abc"); p3 = user.loadPromise("def"); return Promise.all([p1, p2, p3]).then(() => {assert.eq(loadCount, 2); assert.eq(p1, p2); return assert.neq(p1, p3);});});}, aliases: function() {return test("@aliases adds aliases to the model registry", () => {let modelStore, models, registry, user, User; ({modelStore, models} = registry = newRegistry()); ({user} = User = Caf.defClass(class User extends ArtModel {}, function(User, classSuper, instanceSuper) {this.registry(registry); this.aliases("owner", "sister");})); assert.eq(user.class, User); assert.eq(user, models.owner); return assert.eq(user, models.sister);});}, functionsBoundToInstances: function() {return test("use bound function", () => {let modelStore, registry, user, User; ({modelStore} = registry = newRegistry()); ({user} = User = Caf.defClass(class User extends ArtModel {}, function(User, classSuper, instanceSuper) {this.registry(registry); this.prototype.foo = function() {let temp; return this._foo = (((temp = this._foo) != null ? temp : 0)) + 1;};})); user.foo(); assert.eq(user._foo, 1); user.foo(); return assert.eq(user._foo, 2);});}});});});
//# sourceMappingURL=ArtModel.test.js.map
