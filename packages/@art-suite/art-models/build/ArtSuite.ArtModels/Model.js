"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["InstanceFunctionBindingMixin", "BaseObject", "modelRegistry", "Infinity", "compactFlatten", "log", "missing", "Promise", "success", "validStatus", "failure", "Error", "isFailure", "merge", "pending", "ErrorWithInfo", "isPlainObject", "isString", "formattedInspect", "decapitalize"], [global, require('./StandardImport'), require('@art-suite/instance-function-binding-mixin'), require('./ModelStore'), require('./ModelRegistry')], (InstanceFunctionBindingMixin, BaseObject, modelRegistry, Infinity, compactFlatten, log, missing, Promise, success, validStatus, failure, Error, isFailure, merge, pending, ErrorWithInfo, isPlainObject, isString, formattedInspect, decapitalize) => {let Model; return Model = Caf.defClass(class Model extends InstanceFunctionBindingMixin(BaseObject) {constructor(name) {super(...arguments); this._name = name || decapitalize(this.class.getName()); this.bindFunctionsToInstance(); this._activeLoadingRequests = {};};}, function(Model, classSuper, instanceSuper) {this.abstractClass(); this.extendableProperty({modelRegistry}); this.declarable({staleDataReloadSeconds: null, minNetworkFailureReloadSeconds: null, maxNetworkFailureReloadSeconds: Infinity, minServerFailureReloadSeconds: null, maxServerFailureReloadSeconds: Infinity}); this.getter({autoReloadEnabled: function() {return this.getStaleDataReloadSeconds() > 0 || this.getMinNetworkFailureReloadSeconds() > 0 || this.getMinServerFailureReloadSeconds() > 0;}}); this.register = function() {this.singletonClass(); return this.getModelRegistry().register(this);}; this.postCreateConcreteClass = function({hotReloaded}) {if (hotReloaded) {this.singleton.bindFunctionsToInstance();} else {this.register();}; return classSuper.postCreateConcreteClass.apply(this, arguments);}; this.aliases = function(...args) {this._aliases = compactFlatten([args, this._aliases]); return null;}; this._aliases = []; this.prototype.onNextReady = function(f) {return this.modelStore.onNextReady(f);}; this.prototype.register = function() {return log.warn("DEPRICATED: Model#register is no longer used. Instead, the class is registered automatically post-create.");}; this.classGetter({models: function() {return this.getModelRegistry().models;}, modelStore: function() {return this.getModelRegistry().modelStore;}}); this.getter({models: function() {return this.modelRegistry.models;}, modelStore: function() {return this.getModelRegistry().modelStore;}, singlesModel: function() {return this._singlesModel || this;}, modelStoreEntries: function() {return this.modelStore.getEntriesForModel(this.name);}}); this.prototype.subscribe = function(modelKey, subscriptionFunction) {log.error("DEPRICATED - mix ModelSubscriptionsMixin into your class, and use it's methods to subscribe to models"); return this.modelStore.subscribe(this._name, modelKey, subscriptionFunction);}; this.getter("name", {modelName: function() {return this._name;}}); this.prototype.load = function(key) {return (this.loadData || this.loadModelRecord) ? (this.loadPromise(key), null) : this.updateModelRecord(key, {status: missing});}; this.prototype.loadPromise = function(key) {let temp, base; return ((temp = (base = this._activeLoadingRequests)[key]) != null ? temp : base[key] = (this.loadData ? Promise.then(() => this.loadingRecord(key)).then(() => this.loadData(key)).then((data) => this.updateModelRecord(key, (data != null) ? {data, status: success} : {status: missing})).catch((error) => {let status, info, base1; status = validStatus(status = Caf.exists(error) && (Caf.exists(base1 = error.info) && base1.status) || error) ? status : failure; info = Caf.exists(error) && error.info; if (!(error instanceof Error)) {error = null;}; return this.updateModelRecord(key, {status, info, error});}) : this.loadModelRecord ? this.loadModelRecord(key).then((modelRecord) => this.updateModelRecord(key, modelRecord)).catch((error) => this.updateModelRecord(key, {status: failure, error})) : Promise.resolve(this.updateModelRecord(key, {status: missing}))).tap(() => this.onNextReady()).then((result) => {this._activeLoadingRequests[key] = null; return result;}));}; this.prototype.reload = function(key) {return (this.loadData || this.loadModelRecord) ? this.loadPromise(key) : this.load(key);}; this.prototype.loadingRecord = function(key) {let modelRecord, base; return isFailure(Caf.exists(base = modelRecord = this.getModelRecord(key)) && base.status) ? this.updateModelRecord(key, merge(modelRecord, {status: pending})) : undefined;}; this.prototype.getModelRecord = function(key) {return this.modelStore.get(this._name, this.toKeyString(key));}; this.prototype.updateModelRecord = function(key, modelRecord) {return this.modelStore.update(this._name, key, modelRecord);}; this.prototype.onModelRegistered = function(modelName) {return this.modelRegistry.onModelRegistered(modelName);}; this.prototype.get = function(key) {key = this.toKeyString(key); return Promise.then(() => {let currentModelRecord, base; if ((Caf.exists(base = currentModelRecord = this.getModelRecord(key)) && base.status) === pending) {currentModelRecord = null;}; return currentModelRecord != null ? currentModelRecord : this.loadPromise(key);}).then((modelRecord) => {let status, data; status = modelRecord.status; data = modelRecord.data; if (!(status === success)) {throw new ErrorWithInfo(`Model#get: Error getting data. Status: ${Caf.toString(status)}.`, {status, modelRecord});}; return data;});}; this.prototype.toKeyString = function(key) {return isPlainObject(key) ? this.dataToKeyString(key) : isString(key) ? key : (() => {throw new Error(`Model ${Caf.toString(this.name)}: Must implement custom toKeyString for non-string keys like: ${Caf.toString(formattedInspect(key))}`);})();}; this.prototype.dataToKeyString = function(obj) {return (() => {throw new Error(`Model ${Caf.toString(this.name)}: must override dataToKeyString for converting objects to key-strings.`);})();}; this.getRecordPropsToKeyFunction = function(recordType) {return (props, stateField) => {let propsField, temp, base; propsField = stateField != null ? stateField : recordType; return ((temp = Caf.exists(base = props[propsField]) && base.id) != null ? temp : props[propsField + "Id"]);};}; this.getter({propsToKey: function() {let temp; return ((temp = this._propsToKey) != null ? temp : this._propsToKey = Model.getRecordPropsToKeyFunction(this.modelName));}}); this.prototype.modelStoreEntryUpdated = function(entry) {}; this.prototype.modelStoreEntryAdded = function(entry) {}; this.prototype.modelStoreEntryRemoved = function(entry) {}; this.prototype.modelRegistered = function() {};});});});
//# sourceMappingURL=Model.js.map
