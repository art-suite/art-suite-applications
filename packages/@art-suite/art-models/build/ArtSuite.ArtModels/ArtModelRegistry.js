"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseObject", "Promise", "Error", "formattedInspect", "Object"], [global, require('art-standard-lib'), require('art-class-system')], (BaseObject, Promise, Error, formattedInspect, Object) => {let ArtModelRegistry; return ArtModelRegistry = Caf.defClass(class ArtModelRegistry extends BaseObject {}, function(ArtModelRegistry, classSuper, instanceSuper) {let temp, base; this.models = ((temp = (base = global).artModels) != null ? temp : base.artModels = {}); this._modelRegistrationPromiseResolvers = {}; this._modelRegistrationPromises = {}; this.register = (model) => {this._addAliasesToRegistry(model); this._addModelToRegistry(model.modelName, model); return this._modelRegistered(model);}; this.onModelRegistered = (modelName) => {let temp1, base1; return ((temp1 = (base1 = this._modelRegistrationPromises)[modelName]) != null ? temp1 : base1[modelName] = Promise.then(() => {let temp2; return ((temp2 = this.models[modelName]) != null ? temp2 : new Promise((resolve) => this._modelRegistrationPromiseResolvers[modelName] = resolve));}));}; this._addModelToRegistry = (name, model) => {if (this.models[name]) {throw new Error(`${Caf.toString(ArtModelRegistry.namespacePath)}: model already registered with same name\n${Caf.toString(formattedInspect({name, model, previouslyRegisteredModel: this.models[name]}))}`);}; this.models[name] = model; return model;}; this._addAliasesToRegistry = (model) => Caf.each2(model.class._aliases, (alias) => this._addModelToRegistry(alias, model)); this._modelRegistered = (model) => {let base1; model.modelRegistered(); Caf.isF((base1 = this._modelRegistrationPromiseResolvers)[model.modelName]) && base1[model.modelName](model); return model;}; this._reset = function() {return Caf.each2(Object.keys(this.models), (k) => delete this.models[k]);};});});});
//# sourceMappingURL=ArtModelRegistry.js.map
