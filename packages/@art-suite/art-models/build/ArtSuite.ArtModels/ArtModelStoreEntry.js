"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseObject", "hardDeprecatedFunctionsAsMap", "merge", "min", "Math", "validateInputs", "Object", "pending", "toSeconds", "max", "timeoutAt", "failure", "isSuccess", "isFailure", "networkFailure", "serverFailure", "formattedInspect", "log", "propsEq", "pushIfNotPresent", "removeFirstMatch", "models"], [global, require('./StandardImport'), require('./ArtModelRegistry'), require('./Lib')], (BaseObject, hardDeprecatedFunctionsAsMap, merge, min, Math, validateInputs, Object, pending, toSeconds, max, timeoutAt, failure, isSuccess, isFailure, networkFailure, serverFailure, formattedInspect, log, propsEq, pushIfNotPresent, removeFirstMatch, models) => {let getModelStore, retryExponent, ArtModelStoreEntry; getModelStore = function() {let _modelStore; return _modelStore != null ? _modelStore : _modelStore = require('./ArtModelStore').artModelStore;}; retryExponent = 2; return ArtModelStoreEntry = Caf.defClass(class ArtModelStoreEntry extends BaseObject {constructor(modelName, key, initialModelRecord = {}) {let temp, temp1; super(...arguments); this._model = models[modelName]; this._autoReload = this._model.autoReloadEnabled; this._currentPendingReload = null; ((temp = initialModelRecord.key) != null ? temp : initialModelRecord.key = key); ((temp1 = initialModelRecord.modelName) != null ? temp1 : initialModelRecord.modelName = modelName); this.setModelRecord(initialModelRecord); this._subscribers = []; this._previousModelRecord = null;};}, function(ArtModelStoreEntry, classSuper, instanceSuper) {this.getter("previousModelRecord", "modelRecord", "subscribers", "model", "autoReload"); this.getter({subscriberCount: function() {return this._subscribers.length;}, key: function() {return this._modelRecord.key;}, modelName: function() {return this._modelRecord.modelName;}, status: function() {return this._modelRecord.status;}, inspectedObjects: function() {return merge({modelName: this.modelName, key: this.key, status: this.status, createdAt: this.createdAt, updatedAt: this.updatedAt, reloadAt: this.reloadAt, data: this.modelRecord.data, message: this.modelRecord.message, error: this.modelRecord.error, subscriberCount: this.subscriberCount});}, nextNetworkFailureRetryDelay: function() {let m, temp; return (0 < (m = this.model.getMinNetworkFailureReloadSeconds())) ? min(m * Math.pow(((temp = this.tryCount) != null ? temp : 1), retryExponent), this.model.getMaxNetworkFailureReloadSeconds()) : undefined;}, nextServerFailureRetryDelay: function() {let m, temp; return (0 < (m = this.model.getMinServerFailureReloadSeconds())) ? min(m * Math.pow(((temp = this.tryCount) != null ? temp : 1), retryExponent), this.model.getMaxServerFailureReloadSeconds()) : undefined;}}); this.getter(hardDeprecatedFunctionsAsMap("dataChanged", "modelRecordChanged", "age", "plainStructure", "hasSubscribers")); Caf.each2(["tryCount", "reloadAt", "updatedAt", "createdAt"], (modelRecordSetter) => {this.getter({[modelRecordSetter]: function() {return this._modelRecord[modelRecordSetter];}}); return this.setter({[modelRecordSetter]: function(v) {return this._modelRecord[modelRecordSetter] = v;}});}); this.setter({modelRecord: function(newModelRecord) {let key, modelName, createdAt, now, temp, temp1, temp2; validateInputs(Caf.is(newModelRecord, Object), "New modelRecord must be an object.", newModelRecord); temp = ((temp1 = this._modelRecord) != null ? temp1 : newModelRecord); key = temp.key; modelName = temp.modelName; createdAt = temp.createdAt; this._modelRecord = newModelRecord; newModelRecord.key = key; newModelRecord.modelName = modelName; ((temp2 = newModelRecord.status) != null ? temp2 : newModelRecord.status = pending); newModelRecord.updatedAt = now = toSeconds(); newModelRecord.createdAt = createdAt != null ? createdAt : now; return this._autoReload ? this._updateAutoReloadFields() : undefined;}}); this.prototype.scheduleReload = function(reloadDelta) {let reloadAt, delta, now, rangePerterbation, rangeMin, rangeMax, modelName, key, thisPendingReload, temp; return (reloadDelta > 0) ? (reloadAt = this.updatedAt + reloadDelta, delta = max(1, reloadAt - (now = toSeconds())), rangePerterbation = (delta < 80) ? 1 : 15, rangeMin = delta - rangePerterbation, rangeMax = delta + rangePerterbation, !(this.reloadAt < now + rangeMax) ? (this.reloadAt = now + rangeMin + (rangeMax - rangeMin) * Math.random(), (temp = this, modelName = temp.modelName, key = temp.key), this._currentPendingReload = thisPendingReload = timeoutAt(this.reloadAt, function() {let entry; entry = getModelStore()._getEntry(modelName, key); return (thisPendingReload === (Caf.exists(entry) && entry._currentPendingReload)) ? (entry._resetAutoReload(), entry.reload()) : undefined;})) : undefined) : undefined;}; this.prototype.reload = function() {return this.model.reload(this.key);}; this.prototype.load = function() {let modelRecord, error; try {if (modelRecord = this.model.load(this.key)) {this.setModelRecord(modelRecord);};} catch (error1) {error = error1; this.setModelRecord({error, status: failure, message: this._getAndLogErrorMessage(error, "loading")});}; return this;}; this.prototype.added = function() {return this.model.modelStoreEntryAdded(this);}; this.prototype.removed = function() {return this.model.modelStoreEntryRemoved(this);}; this.prototype.updated = function() {this.model.modelStoreEntryUpdated(this); return this._notifySubscribers();}; this.prototype._resetAutoReload = function() {this._currentPendingReload = this.reloadAt = null; return this.tryCount = 0;}; this.prototype._updateAutoReloadFields = function() {return isSuccess(this.status) ? (this.tryCount = 1, this.scheduleReload(this.model.getStaleDataReloadSeconds())) : isFailure(this.status) ? (this.tryCount += 1, (() => {switch (this.status) {case networkFailure: return this.scheduleReload(this.nextNetworkFailureRetryDelay); case serverFailure: case failure: return this.scheduleReload(this.nextServerFailureRetryDelay);};})()) : undefined;}; this.prototype._getAndLogErrorMessage = function(error, failedAction, _log = log.error) {let message; _log({error, message: message = `Error ${Caf.toString(failedAction)} Entry for model: ${Caf.toString(this.modelName)}, key: ${Caf.toString(formattedInspect(this.key))}`}); return message;}; this.prototype._updateModelRecord = function(updateFunction) {let error, temp; ((temp = this._previousModelRecord) != null ? temp : this._previousModelRecord = this._modelRecord); try {this.setModelRecord(Caf.isF(updateFunction) && updateFunction(this._modelRecord) || {});} catch (error1) {error = error1; this._getAndLogErrorMessage(error, "updating");}; return propsEq(this._modelRecord, this._previousModelRecord) ? this._previousModelRecord = null : undefined;}; this.prototype._notifySubscribers = function() {let from, into, to, i, temp; return this._previousModelRecord ? ((from = this._subscribers, into = from, (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let subscriber; subscriber = from[i]; subscriber(this._modelRecord, this._previousModelRecord); temp = i++;}; return temp;})()) : undefined, into), this._previousModelRecord = null) : undefined;}; this.prototype._subscribe = function(subscriber) {return pushIfNotPresent(this._subscribers, subscriber);}; this.prototype._unsubscribe = function(subscriber) {return removeFirstMatch(this._subscribers, subscriber);};});});});
//# sourceMappingURL=ArtModelStoreEntry.js.map
