"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["EpochClass", "hardDeprecatedFunctionsAsMap", "toInspectedObjects", "Infinity", "toSeconds", "Math", "min", "isFunction", "Error", "formattedInspect", "Object", "String", "ArtModelStoreEntry", "success", "pushIfNotPresent"], [global, require('./StandardImport'), require('art-epoched-state'), require('./Lib'), {ArtModelStoreEntry: require('./ArtModelStoreEntry'), ModelRegistry: require('./ModelRegistry')}], (EpochClass, hardDeprecatedFunctionsAsMap, toInspectedObjects, Infinity, toSeconds, Math, min, isFunction, Error, formattedInspect, Object, String, ArtModelStoreEntry, success, pushIfNotPresent) => {let ArtModelStore; return ArtModelStore = Caf.defClass(class ArtModelStore extends EpochClass {constructor(_modelRegistry) {super(...arguments); this._modelRegistry = _modelRegistry; if (!(this._modelRegistry instanceof require('./ModelRegistry'))) {throw new Error("missing modelRegistry");}; this._length = 0; this._entriesByModelName = {}; this._addedEntries = [];};}, function(ArtModelStore, classSuper, instanceSuper) {this.getter("modelRegistry", "length", {models: function() {return this.modelRegistry.models;}, inspectedObjects: function() {return toInspectedObjects(this._entriesByModelName);}, status: function() {let entrySubscribers, modelCount, entryCount, reloadsPending, nextReload, now; entrySubscribers = 0; modelCount = 0; entryCount = 0; reloadsPending = 0; nextReload = Infinity; now = toSeconds(); Caf.each2(this._entriesByModelName, (entries) => {modelCount++; return Caf.each2(entries, (entry) => {entryCount++; entrySubscribers += entry.subscriberCount; return (entry.reloadAt > now) ? (reloadsPending++, nextReload = Math.ceil(min(nextReload, entry.reloadAt - now))) : undefined;});}); return {entryCount, entrySubscribers, modelCount, reloadsPending, nextReload};}}); this.prototype.get = function(modelName, key) {let base; this._validateModelNameAndKey(modelName, key); return Caf.exists(base = this._getEntry(modelName, key)) && base.modelRecord;}; this.prototype.getSubscribers = function(modelName, key) {let base; this._validateModelNameAndKey(modelName, key); return Caf.exists(base = this._getEntry(modelName, key)) && base.subscribers;}; this.prototype.getEntriesForModel = function(modelName) {this._validateModelNameAndKey(modelName); return this._entriesByModelName[modelName];}; this.getter(hardDeprecatedFunctionsAsMap("hasSubscribers")); this.prototype.subscribe = function(modelName, key, subscriber, initialModelRecord) {this._queueChange({modelName, key, addSubscriber: subscriber}); return this._vivifyAndLoadEntry(modelName, key, initialModelRecord).modelRecord;}; this.prototype.unsubscribe = function(modelName, key, subscriber) {return this._queueChange({modelName, key, removeSubscriber: subscriber});}; this.prototype.update = function(modelName, key, updateFunctionOrNewModelRecord) {this._queueChange({modelName, key, updateFunction: isFunction(updateFunctionOrNewModelRecord) ? updateFunctionOrNewModelRecord : () => updateFunctionOrNewModelRecord}); return updateFunctionOrNewModelRecord;}; this.prototype._getEntriesForModelName = function(modelName) {let temp, base; return ((temp = (base = this._entriesByModelName)[modelName]) != null ? temp : base[modelName] = {});}; this.prototype._validateModelNameAndKey = function(modelName, key) {return (!!this.models[modelName] || (() => {throw new Error(`Expected valid model name. Inputs: ${Caf.toString(formattedInspect({modelName, key}))}\nValid models: ${Caf.toString(Object.keys(this.models).join("\n") || "(no models registered)")}`);})()) && (!(key != null) || Caf.is(key, String)) || (() => {throw new Error(`Expected 'key' to be a String. Inputs: ${Caf.toString(formattedInspect({modelName, key}))}`);})();}; this.prototype._getEntry = function(modelName, key) {return this._getEntriesForModelName(modelName)[key];}; this.prototype._addEntry = function(modelName, key, initialModelRecord) {let entry; this._length++; this._addedEntries.push(entry = this._getEntriesForModelName(modelName)[key] = new ArtModelStoreEntry(this.models[modelName], key, initialModelRecord)); return entry;}; this.prototype._removeEntry = function(entry) {this._length--; delete this._getEntriesForModelName(entry.modelRecord.modelName)[entry.modelRecord.key]; return entry;}; this.prototype._vivifyEntry = function(modelName, key) {let temp; return ((temp = this._getEntry(modelName, key)) != null ? temp : this._addEntry(modelName, key));}; this.prototype._vivifyAndLoadEntry = function(modelName, key, initialModelRecord) {let temp; return ((temp = this._getEntry(modelName, key)) != null ? temp : this._createAndInitEntry(modelName, key, initialModelRecord));}; this.prototype._getGlobalInitialModelRecordForEntry = function(modelName, key) {let data, initialModelRecord, base, base1; return (data = Caf.exists(base = global.artSuiteModelsInit) && (Caf.exists(base1 = base[modelName]) && base1[key])) ? initialModelRecord = {data, status: success} : undefined;}; this.prototype._createAndInitEntry = function(modelName, key, initialModelRecord) {let entry; entry = this._addEntry(modelName, key, initialModelRecord != null ? initialModelRecord : initialModelRecord = this._getGlobalInitialModelRecordForEntry(modelName, key)); if (!initialModelRecord) {entry.load();}; return entry;}; this.prototype._queueChange = function(change) {let modelName, key; modelName = change.modelName; key = change.key; this._validateModelNameAndKey(modelName, key); this.queueItem(change); return null;}; this.prototype.processEpochItems = function(changes) {let updatedEntries, removedEntries, from, into, to, i, from1, into1, to1, i1, from2, into2, to2, i2, from3, into3, to3, i3; updatedEntries = []; removedEntries = []; from = changes; into = from; if (from != null) {to = from.length; i = 0; while (i < to) {let modelName, key, addSubscriber, removeSubscriber, updateFunction, entry; ({modelName, key, addSubscriber, removeSubscriber, updateFunction} = from[i]); this._validateModelNameAndKey(modelName, key); pushIfNotPresent(updatedEntries, entry = this._vivifyEntry(modelName, key)); if (updateFunction) {entry._updateModelRecord(updateFunction);} else {if (addSubscriber) {entry._subscribe(addSubscriber);} else {if (removeSubscriber) {entry._unsubscribe(removeSubscriber);};};}; i++;};}; into; from1 = updatedEntries; into1 = from1; if (from1 != null) {to1 = from1.length; i1 = 0; while (i1 < to1) {let entry; entry = from1[i1]; entry.updated(); if (entry.subscribers.length === 0) {pushIfNotPresent(removedEntries, this._removeEntry(entry));}; i1++;};}; into1; from2 = this._addedEntries; into2 = from2; if (from2 != null) {to2 = from2.length; i2 = 0; while (i2 < to2) {let entry; entry = from2[i2]; entry.added(); i2++;};}; into2; from3 = removedEntries; into3 = from3; if (from3 != null) {to3 = from3.length; i3 = 0; while (i3 < to3) {let entry; entry = from3[i3]; entry.removed(); i3++;};}; into3; this._addedEntries = []; return null;};});});});
//# sourceMappingURL=ArtModelStore.js.map
