"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["modelRegistry", "isPlainObject", "isString", "Error", "isFunction", "rubyTrue", "success", "Object", "isFailure"], [global, require('./StandardImport'), require('./ModelStore'), require('./ModelRegistry')], (modelRegistry, isPlainObject, isString, Error, isFunction, rubyTrue, success, Object, isFailure) => {return function(superClass) {let ModelSubscriptionsMixin; return ModelSubscriptionsMixin = Caf.defClass(class ModelSubscriptionsMixin extends superClass {constructor() {super(...arguments); this._subscriptions = {};};}, function(ModelSubscriptionsMixin, classSuper, instanceSuper) {let _getRetryNow; if (superClass.getIsAbstractClass()) {this.abstractClass();}; this.extendableProperty({modelRegistry}); this.getter({models: function() {return this.modelRegistry.models;}, modelStore: function() {return this.modelRegistry.modelStore;}, subscriptions: function() {return this._subscriptions;}}); this.prototype.subscribe = function(subscriptionKey, modelName, key, options) {let allOptions, stateField, initialModelRecord, updatesCallback, callback, model, modelKey, subscriptionFunction; if (isPlainObject(allOptions = subscriptionKey)) {subscriptionKey = allOptions.subscriptionKey; modelName = allOptions.modelName; key = allOptions.key; stateField = allOptions.stateField; initialModelRecord = allOptions.initialModelRecord; updatesCallback = allOptions.updatesCallback; callback = allOptions.callback; updatesCallback != null ? updatesCallback : updatesCallback = callback; subscriptionKey != null ? subscriptionKey : subscriptionKey = stateField || `${Caf.toString(modelName)} ${Caf.toString(key)}`;} else {stateField = options.stateField; initialModelRecord = options.initialModelRecord; updatesCallback = options.updatesCallback;}; if (!isString(subscriptionKey)) {throw new Error("REQUIRED: subscriptionKey");}; if (!(isString(stateField) || isFunction(updatesCallback))) {throw new Error("REQUIRED: updatesCallback or stateField");}; this.unsubscribe(subscriptionKey); if (!(rubyTrue(key) && modelName)) {return this._setStateFromModelRecord(stateField, initialModelRecord || {status: success}, null, key);}; if (!(model = this.models[modelName])) {throw new Error(`No model registered with the name: ${Caf.toString(modelName)}. Registered models:\n  ${Caf.toString(Object.keys(this.models).join("\n  "))}`);}; modelKey = model.toKeyString(key); subscriptionFunction = (modelRecord) => {Caf.isF(updatesCallback) && updatesCallback(modelRecord); return this._setStateFromModelRecord(stateField, modelRecord, null, key);}; this._subscriptions[subscriptionKey] = {modelName, modelKey, subscriptionFunction}; return this._setStateFromModelRecord(stateField, this.modelStore.subscribe(modelName, modelKey, subscriptionFunction, initialModelRecord), initialModelRecord, key);}; this.prototype.subscribeOnModelRegistered = function(subscriptionKeyOrOptions, modelName, modelKey, options) {if (isPlainObject(subscriptionKeyOrOptions)) {modelName = subscriptionKeyOrOptions.modelName;}; return this.modelRegistry.onModelRegistered(modelName).then(() => this.subscribe(subscriptionKeyOrOptions, modelName, modelKey, options));}; this.prototype.unsubscribe = function(subscriptionKey) {let subscription, subscriptionFunction, modelName, modelKey; if (subscription = this._subscriptions[subscriptionKey]) {subscriptionFunction = subscription.subscriptionFunction; modelName = subscription.modelName; modelKey = subscription.modelKey; this.modelStore.unsubscribe(modelName, modelKey, subscriptionFunction); delete this._subscriptions[subscriptionKey];}; return null;}; this.prototype.unsubscribeAll = function() {Caf.each2(this._subscriptions, (__, subscriptionKey) => this.unsubscribe(subscriptionKey)); return null;}; _getRetryNow = function(modelName, key) {return () => this.modelStore._getEntry(modelName, key).reload();}; this.prototype._setStateFromModelRecord = function(stateField, modelRecord, initialModelRecord, key) {let status, progress, data, reloadAt, tryCount, modelName; if ((Caf.exists(modelRecord) && modelRecord.status) !== success && (Caf.exists(initialModelRecord) && initialModelRecord.status) === success) {modelRecord = initialModelRecord;}; if (stateField && isFunction(this.setState)) {if (modelRecord) {({status = null, progress = null, data = null} = modelRecord);}; this.setState(stateField, data); this.setState(stateField + "Key", key != null ? key : modelRecord.key); this.setState(stateField + "Status", status); this.setState(stateField + "Progress", progress); this.setState(stateField + "FailureInfo", (modelRecord && isFailure(status)) ? (({reloadAt, tryCount, modelName, key} = modelRecord), {reloadAt, tryCount, status, retryNow: _getRetryNow(modelName, key)}) : null);}; return modelRecord;};});};});});
//# sourceMappingURL=ModelSubscriptionsMixin.js.map
