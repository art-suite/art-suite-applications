"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["KeyFieldsMixin", "ArtModel", "models", "upperCamelCase", "log", "PipelineRegistry", "modelRegistry", "pluralize", "merge", "success", "missing", "fastBind", "isFunction"], [global, require('./StandardImport')], (KeyFieldsMixin, ArtModel, models, upperCamelCase, log, PipelineRegistry, modelRegistry, pluralize, merge, success, missing, fastBind, isFunction) => {let PipelineModel; return PipelineModel = Caf.defClass(class PipelineModel extends KeyFieldsMixin(ArtModel) {constructor() {super(...arguments); this._updateSerializers = {}; this._pipeline = this.class._pipeline; this._defineQueryModels(); this._bindPipelineMethods();};}, function(PipelineModel, classSuper, instanceSuper) {this.abstractClass(); this.createModel = function(pipeline, modelRegistry) {let aliases, name, hotReloadKey, AnonymousArtPipelineModel; ({aliases} = pipeline); name = pipeline.getName(); if (models[name]) {return;}; hotReloadKey = `PipelineModel:${Caf.toString(name)}`; return AnonymousArtPipelineModel = Caf.defClass(class AnonymousArtPipelineModel extends PipelineModel {}, function(AnonymousArtPipelineModel, classSuper, instanceSuper) {let ucName; this.modelRegistry(modelRegistry); this._name = ucName = upperCamelCase(name); if (pipeline.keyFields) {this.keyFields(pipeline.keyFields);}; this.pipeline(pipeline); if (aliases) {this.aliases(aliases);}; this.getHotReloadKey = function() {return hotReloadKey;};});}; this.defineModelsForAllPipelines = (pipelineRegistry = pipelineRegistry, modelRegistry = modelRegistry) => {Caf.each2(pipelineRegistry.pipelines, (pipeline) => this.createModel(pipeline, modelRegistry)); return modelRegistry.models;}; this.bindWithArtEry = () => {log.warn("DEPRECATED: bindWithArtEry - ArtEry should handle this itself"); PipelineRegistry.on({register: ({name, pipeline}) => this.createModel(pipeline, modelRegistry)}); return this.defineModelsForAllPipelines();}; this.pipeline = function(_pipeline) {this._pipeline = _pipeline; return this._pipeline;}; this.getter({pipelineName: function() {return this._pipeline.getName();}}, "pipeline", {propsToKey: function() {return this._pipeline.propsToKey;}}); this.prototype.modelStoreEntryUpdated = function({key, subscribers}) {let temp; if (subscribers.length > 0) {this._pipeline.subscribe(key, ((temp = this._sharedSubscriptionFunction) != null ? temp : this._sharedSubscriptionFunction = (eventType, key, data) => (() => {switch (eventType) {case "update": return this.dataUpdated(key, data); case "delete": return this.dataDeleted(key, data);};})()));}; return instanceSuper.modelStoreEntryUpdated.apply(this, arguments);}; this.prototype.modelStoreEntryRemoved = function({key}) {this._pipeline.unsubscribe(key, this._sharedSubscriptionFunction); return instanceSuper.modelStoreEntryRemoved.apply(this, arguments);}; this.prototype._defineQueryModels = function() {return this._queryModels = Caf.array(this._pipeline.queries, (pipelineQuery) => this._createQueryModel(pipelineQuery));}; this.prototype._createQueryModel = function({options, queryName}) {let localMerge, localSort, dataToKeyString, keyFields, recordsModel, pipeline, modelRegistry, ArtEryQueryModelChild; localMerge = options.localMerge; localSort = options.localSort; dataToKeyString = options.dataToKeyString; keyFields = options.keyFields; recordsModel = this; pipeline = this._pipeline; modelRegistry = this.modelRegistry; return (ArtEryQueryModelChild = Caf.defClass(class ArtEryQueryModelChild extends require('./PipelineQueryModel') {}, function(ArtEryQueryModelChild, classSuper, instanceSuper) {this.modelRegistry(modelRegistry); this._name = upperCamelCase(/^by/.test(queryName) ? `${Caf.toString(pluralize(pipeline.name))} ${Caf.toString(queryName)}` : queryName); this.prototype._pipeline = pipeline; this.prototype._recordsModel = recordsModel; this.prototype._queryName = queryName; this.getter("queryName", "pipeline", "recordsModel"); if (keyFields) {this.keyFields(keyFields);}; Caf.each2(merge({localMerge, localSort, dataToKeyString}), (v, k) => this.prototype[k] = v);})).singleton;}; this.prototype.loadData = function(key) {return this._pipeline.get({key, returnNullIfMissing: true, props: {include: "auto"}});}; this.prototype.dataUpdated = function(key, data) {return this.updateModelRecord(key, (oldRecord) => merge(oldRecord, {status: success, data: merge(oldRecord.data, data)}));}; this.prototype.dataDeleted = function(key, dataOrKey) {return this.updateModelRecord(key, {status: missing});}; this.prototype._bindPipelineMethods = function() {let abstractPrototype; abstractPrototype = this._pipeline.class.getAbstractPrototype(); return Caf.each2(this._pipeline, (v, k) => this[k] = fastBind(v, this._pipeline), (v, k) => !this[k] && !abstractPrototype[k] && isFunction(v));};});});});
//# sourceMappingURL=PipelineModel.js.map
