import &StandardImport

class PipelineModel extends KeyFieldsMixin ArtModel
  @abstractClass()

  ## createModel
    ALIASES
      both pipelines and models will have the same set of aliases
      This skips the aliases in pipelines and calls createModel only once
      which will in turn create all the model aliases.
      It's important that all the model aliases are the same model-instance object.

    OUT: singleton for new AnonymousArtEryModel class
  @createModel: (pipeline, modelRegistry) ->
    {aliases} = pipeline
    name = pipeline.getName()
    return if models[name]

    hotReloadKey = "PipelineModel:#{name}"

    class AnonymousArtPipelineModel extends PipelineModel
      @modelRegistry modelRegistry

      @_name: ucName = upperCamelCase name
      @keyFields pipeline.keyFields if pipeline.keyFields
      @pipeline pipeline
      @aliases aliases if aliases
      @getHotReloadKey: -> hotReloadKey

  @defineModelsForAllPipelines: (_pipelineRegistry, _modelRegistry = modelRegistry) =>
    each pipeline in _pipelineRegistry.pipelines
      @createModel pipeline, _modelRegistry

    _modelRegistry.models

  @bindWithArtEry: =>
    log.warn "" DEPRECATED: bindWithArtEry - ArtEry should handle this itself
    PipelineRegistry.on register: ({name, pipeline}) -> @createModel pipeline, modelRegistry

    @defineModelsForAllPipelines()

  @pipeline: (@_pipeline) -> @_pipeline
  @getter
    pipelineName: -> @_pipeline.getName()
    :pipeline
    propsToKey: -> @_pipeline.propsToKey

  ########################
  # Constructor
  ########################
  constructor: ->
    @_updateSerializers = {}
    @_pipeline = @class._pipeline
    @_defineQueryModels()
    @_bindPipelineMethods()

  ####################
  # ArtModel Overrides
  ####################
  modelStoreEntryUpdated: ({key, subscribers}) ->
    if subscribers.length > 0  # have local subscribers
      @_pipeline.subscribe
        key
        @_sharedSubscriptionFunction ?= (eventType, key, data) ->
          switch eventType
          when :update then @dataUpdated key, data
          when :delete then @dataDeleted key, data

    super

  modelStoreEntryRemoved: ({key}) ->
    @_pipeline.unsubscribe key, @_sharedSubscriptionFunction
    super

  ########################
  # Queries
  ########################
  _defineQueryModels: ->
    @_queryModels = array pipelineQuery in @_pipeline.queries with @_createQueryModel pipelineQuery

  ## _createQueryModel
    IN: {options, queryName}
    queryName can either be
      pre2020-style:
        format: pluralized pipeline name - by - fields
        e.g. postsByUserId

      2020-style-naming:
        format: by - fields
        e.g. byUserId

      Either way, the art-model will be named:
        format: pluralized pipeline name - by - fields
        e.g. postsByUserId

    Benefits of 2020-style query names:
      By dropping the pipeline-name as part of the queryName, we get several advantages:

        DRY:
          Pipeline definitions:
            2020 version:
              class Message extends Pipeline
                @query byUserId: (request) -> ...
                @publicRequestTypes :byUserId

            instead of pre2020:
              class Message extends Pipeline
                @query messagesByUserId: (request) -> ...
                @publicRequestTypes :messagesByUserId

          The REST api becomes:
            2020 version:       /post/byUserId/abc123
            instead of pre2020: /post/postsByUserId/abc123

        And all the DRY means an objective improvement:

          It is now possible to re-use pipeline query definitions across pipelines:

            class UserOwned extends Pipeline
              @query byUserId: (request) -> ...
              @publicRequestTypes :byUserId

            class Message extends UserOwned
            class Post extends UserOwned

          NOTE: I actually haven't tested that the inheritance part works yet...
  _createQueryModel: ({options, queryName}) ->
    options extract localMerge, localSort, dataToKeyString, keyFields

    recordsModel = @
    pipeline = @_pipeline
    @ extract modelRegistry

    class ArtEryQueryModelChild extends &PipelineQueryModel
      @modelRegistry modelRegistry
      @_name: upperCamelCase
        if /^by/.test queryName
          "#{pluralize pipeline.name} #{queryName}"
        else
          queryName

      _pipeline:      pipeline
      _recordsModel:  recordsModel
      _queryName:     queryName

      @getter :queryName, :pipeline, :recordsModel
      @keyFields keyFields if keyFields

      # Overrides
      # TODO: add propsToKey
      each v, k in merge {} localMerge, localSort, dataToKeyString
        @prototype[k] = v

    .singleton

  ########################
  # ArtModel Overrides
  ########################
  loadData: (key) ->
    @_pipeline.get {} key, returnNullIfMissing: true, props: include: "auto"  # include: :auto is for LinkFieldsFilterV1

  ################################################
  # DataUpdatesFilter callbacks
  ################################################
  ## dataUpdated
  dataUpdated: (key, data) -> @updateModelRecord key, (oldRecord) -> merge oldRecord, status: success, data: merge oldRecord.data, data
  dataDeleted: (key, dataOrKey) -> @updateModelRecord key, status: missing

  ##########################
  # PRIVATE
  ##########################

  ## _bindPipelineMethods
    Bind all concrete methods defined on @_pipeline
    and set them on the model prototype
    as long as there isn't already a model-prototype method with that name.

    Specifically: create & update are already defined above
      since they need to do extra work to ensure the ModelStore is
      updated properly.
  _bindPipelineMethods: ->
    abstractPrototype = @_pipeline.class.getAbstractPrototype()
    each v, k in @_pipeline when !@[k] && !abstractPrototype[k] && isFunction v
      @[k] = fastBind v, @_pipeline
