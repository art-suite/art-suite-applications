"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseObject", "Promise", "neq", "dashCase", "log", "Request", "isFailure", "isJsonType", "formattedInspect", "Error"], [global, require('./StandardImport'), require('./PipelineRegistry'), {Request: require('./Request')}], (BaseObject, Promise, neq, dashCase, log, Request, isFailure, isJsonType, formattedInspect, Error) => {let RequestHandler; return RequestHandler = Caf.defClass(class RequestHandler extends BaseObject {}, function(RequestHandler, classSuper, instanceSuper) {this.abstractClass(); this.extendableProperty({pipelineRegistry: null}); this.registry = this.extendPipelineRegistry; this.getRegistry = function() {return this.getPipelineRegistry();}; this.getter({registry: function() {return this.pipelineRegistry;}}); this.getter({registry: function() {return this.class.getRegistry();}, pipelines: function() {return this.registry.pipelines;}}); this.prototype.applyHandler = function(request, handlerFunction, context) {let resultPromise; if (!handlerFunction) {return Promise.resolve(request);}; resultPromise = this._applyHandler(request, handlerFunction, context).then((response) => {let base; return (Caf.exists(response) && response.isFailure && !(Caf.exists(base = response.errorProps) && base.failedIn)) ? response.withMergedErrorProps({failedIn: {context, handler: this, response}}) : response;}); return request.verbose ? resultPromise.tap((result) => {let content; return (result !== request && neq(request.summary, result.summary)) ? (content = {[`ArtPipelines-applyHandler-Verbose ${Caf.toString(request.requestString)} - ${Caf.toString(dashCase(context))} ${Caf.toString(this.getLogName(this.type))}`]: {before: request.summary, after: result.summary}}, (result.isError && !request.isError) ? log.error(content) : log(content)) : log({[`ArtPipelines-applyHandler-Verbose ${Caf.toString(request.requestString)} - ${Caf.toString(dashCase(context))} ${Caf.toString(this.getLogName(this.type))}`]: "no-change"});}) : resultPromise;}; this.prototype._applyHandler = function(request, handlerFunction, context) {let newFilterLog; newFilterLog = null; return Promise.then(() => {newFilterLog = request.addFilterLog(this, context); return handlerFunction.call(this, request);}).then((data) => !(data != null) ? request.missing() : (data instanceof Request) ? (isFailure(data.status) ? newFilterLog.stack = data.creationStack : undefined, data) : isJsonType(data) ? request.success({data}) : request.failure(`Invalid response data returned from handler: ${Caf.toString(this.name)} context: ${Caf.toString(context)}\n\n${Caf.toString(formattedInspect({data}))}`), (error) => {let status, base, base1, base2; newFilterLog.exception = error || new Error("there was no error"); return (Caf.exists(base = error.props) && (Caf.exists(base1 = base.response) && base1.isResponse)) ? error.props.response : isFailure(status = Caf.exists(base2 = error.info) && base2.status) ? request.toResponse(status, {error: error.info}) : request.failure({errorProps: {exception: error, source: {this: this, function: handlerFunction}}});}).tap((requestResponse) => newFilterLog.status = requestResponse.status);};});});});
//# sourceMappingURL=RequestHandler.js.map
