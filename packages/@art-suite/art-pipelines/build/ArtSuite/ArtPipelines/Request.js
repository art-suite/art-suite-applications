"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseObject", "Validator", "merge", "failure", "serverFailure", "clientFailure", "pending", "Error", "success", "missing", "isFailure", "isPlainObject", "objectKeyCount", "isPlainArray", "config", "peek", "compactFlatten", "objectWithout", "isString", "currentSecond", "arrayWith", "JSON", "toInspectedObjects", "formattedInspect", "Promise", "log", "networkFailure", "timeout", "Math", "present", "getDetailedRequestTracingEnabled", "isFunction", "mergeWithoutNulls", "isArray", "isClientFailure", "isJsonType", "clientFailureNotAuthorized", "RequestError", "cleanStackTrace", "getDetailedRequestTracingExplanation", "cleanStackTraceWarnings", "Object", "validateLocation", "neq"], [global, require('./StandardImport'), require('./Config')], (BaseObject, Validator, merge, failure, serverFailure, clientFailure, pending, Error, success, missing, isFailure, isPlainObject, objectKeyCount, isPlainArray, config, peek, compactFlatten, objectWithout, isString, currentSecond, arrayWith, JSON, toInspectedObjects, formattedInspect, Promise, log, networkFailure, timeout, Math, present, getDetailedRequestTracingEnabled, isFunction, mergeWithoutNulls, isArray, isClientFailure, isJsonType, clientFailureNotAuthorized, RequestError, cleanStackTrace, getDetailedRequestTracingExplanation, cleanStackTraceWarnings, Object, validateLocation, neq) => {let responseValidator, requestValidator, createValidators, Request; responseValidator = requestValidator = null; createValidators = function() {responseValidator != null ? responseValidator : responseValidator = new Validator({request: ["required", {instanceof: Request}], status: ["required", "communicationStatus"], session: "object", props: "object"}); return requestValidator != null ? requestValidator : requestValidator = new Validator({type: {required: {fieldType: "string"}}, session: {required: {fieldType: "object"}}, parentRequest: {instanceof: Request}, originatedOnServer: "boolean", props: "object", key: "string"});}; return Request = Caf.defClass(class Request extends BaseObject {constructor(options) {let key, temp, temp1, temp2, temp3, temp4, base, temp5, base1, temp6, temp7, base2, temp8, temp9, base3, temp10, temp11; super(...arguments); this._type = options.type; this._props = ((temp = options.props) != null ? temp : {}); if (options.data != null) {this._props.data = options.data;}; this._pipeline = ((temp1 = options.pipeline) != null ? temp1 : options.request.pipeline); this._session = options.session; this._location = validateLocation(((temp2 = options.location) != null ? temp2 : this._pipeline.location)); this._context = options.context; this._request = options.request; this._status = options.status; this._verbose = options.verbose; this._creationTime = currentSecond(); this._afterFilterLog = options.afterFilterLog; this._beforeFilterLog = options.beforeFilterLog; this._errorProps = options.errorProps; this._creationStack = options.creationStack; this._originalRequest = ((temp3 = ((temp4 = options.originalRequest) != null ? temp4 : Caf.exists(base = this._request) && base.originalRequest)) != null ? temp3 : this); this._parentRequest = ((temp5 = options.parentRequest) != null ? temp5 : Caf.exists(base1 = this._request) && base1.parentRequest); this._rootRequest = ((temp6 = ((temp7 = Caf.exists(base2 = this._parentRequest) && base2.rootRequest) != null ? temp7 : this._request)) != null ? temp6 : this); this._remoteRequest = options.remoteRequest; this._remoteResponse = options.remoteResponse; this._originatedOnServer = ((temp8 = ((temp9 = options.originatedOnServer) != null ? temp9 : Caf.exists(base3 = this._parentRequest) && base3.originatedOnServer)) != null ? temp8 : this._location === "server"); createValidators(); if (this.isRequest) {key = ((temp10 = options.key) != null ? temp10 : this._props.key); if (key != null) {options.key = this._props.key = this.pipeline.toKeyString(key);}; requestValidator.validate(options, {logErrors: true}); if (!this._beforeFilterLog) {this.addFilterLog(undefined, "created");};} else {responseValidator.validate(options, {logErrors: true}); ((temp11 = this._session) != null ? temp11 : this._session = neq(this.request.session, this.request.originalRequest.session) ? this.request.session : undefined); if (this.type === "create" || this.type === "get") {this.setGetCache();};}; if (getDetailedRequestTracingEnabled() && !this._creationStack) {this._creationStack = (new Error).stack;};};}, function(Request, classSuper, instanceSuper) {let cachedGet, createRequirementNotMetRequestProps, resolveRequireTestValue, defaultWhenTest; this.getter({pipelines: function() {return this.pipeline.pipelines;}, pipelineRegistry: function() {return this.pipeline.pipelineRegistry;}}); this.getter("pipeline", "location", "props", {session: function() {let temp; return ((temp = this._session) != null ? temp : this.request.session);}, originatedOnServer: function() {return this.isRequest ? this._originatedOnServer : this.request.originatedOnServer;}, type: function() {let temp; return ((temp = this._type) != null ? temp : this.request.type);}, key: function() {let temp, base; return this.isRequest ? this._props.key : ((temp = this.request.key) != null ? temp : Caf.exists(base = this.responseData) && base.id);}, data: function() {return this._props.data;}}, "errorProps", "creationTime", "creationStack", "request", "originalRequest", "parentRequest", "rootRequest", "remoteResponse", "remoteRequest", {context: function() {let temp; return this.isRequest ? ((temp = this._context) != null ? temp : this._context = {}) : this.request.context;}}); this.getter({isRequest: function() {return !(this._request != null);}, isResponse: function() {return this._request != null;}, isRootRequest: function() {return !this.parentRequest;}, isSubrequest: function() {return !this.isRootRequest;}, isUpdateRequest: function() {return this.pipeline.isUpdateRequestType(this.type);}, isDeleteRequest: function() {return this.pipeline.isDeleteRequestType(this.type);}, verbose: function() {let base, base1; return this._verbose || Caf.exists(base = this.originalRequest) && base._verbose || Caf.exists(base1 = this.rootRequest) && base1._verbose;}, requestType: function() {return this.type;}, pipelineName: function() {return this.pipeline.getName();}, requestDataWithKey: function() {return merge(this.requestData, this.keyObject);}, keyObject: function() {return this.pipeline.toKeyObject(this.key);}, propsForClone: function() {return this.isRequest ? {originalRequest: this.originalRequest, location: this.location, pipeline: this.pipeline, type: this.type, props: this.props, session: this.session, parentRequest: this.parentRequest, beforeFilterLog: this.beforeFilterLog, originatedOnServer: this.originatedOnServer, context: this._context, verbose: this.verbose, remoteRequest: this.remoteRequest} : {request: this.request, location: this.location, status: this.status, props: this.props, session: this._session, beforeFilterLog: this.beforeFilterLog, afterFilterLog: this.afterFilterLog, remoteRequest: this.remoteRequest, remoteResponse: this.remoteResponse, errorProps: this.errorProps};}, propsForResponse: function() {return {beforeFilterLog: this.beforeFilterLog, afterFilterLog: this.afterFilterLog, request: this.request, location: this.location, remoteRequest: this.remoteRequest, remoteResponse: this.remoteResponse};}, startTime: function() {return this.rootRequest.creationTime;}, endTime: function() {return this.creationTime;}, wallTime: function() {return this.startTime - this.endTime;}, status: function() {let temp, temp1; return ((temp = (this._status === failure) ? (() => {switch (this.location) {case "server": return serverFailure; case "client": return clientFailure;};})() : undefined) != null ? temp : ((temp1 = this._status) != null ? temp1 : pending));}, isError: function() {return this._status === failure || this._status === serverFailure || this._status === clientFailure;}, failed: function() {return (() => {throw new Error(".failed is DEPRECATED - use .isError or .isFailure");})();}, isSuccessful: function() {return this._status === success;}, isMissing: function() {return this._status === missing;}, isFailure: function() {return isFailure(this._status);}, notSuccessful: function() {return this.isFailure;}, requestSession: function() {let temp; return (((temp = this._request) != null ? temp : this)).session;}, requestProps: function() {let temp; return (((temp = this._request) != null ? temp : this)).props;}, requestData: function() {let temp; return (((temp = this._request) != null ? temp : this)).props.data;}, responseSession: function() {return this.isResponse ? this._session : undefined;}, responseProps: function() {return this.isResponse ? this._props : undefined;}, responseData: function() {return this.isResponse ? this._props.data : undefined;}, plainObjectsResponse: function(fields) {return Caf.object(fields || {status: this.status, props: this.props, beforeFilterLog: this.beforeFilterLog, afterFilterLog: this.afterFilterLog, session: this._session}, null, (v) => (() => {switch (false) {case !isPlainObject(v): return objectKeyCount(v) > 0; case !isPlainArray(v): return v.length > 0; default: return v !== undefined;};})());}, responseForRemoteRequest: function() {return this.getPlainObjectsResponse(!config.returnProcessingInfoToClient ? {status: this.status, props: this.props, session: this._session} : undefined);}}); this.getter({lastFilterLogEntry: function() {let temp; return ((temp = peek(this.afterFilterLog)) != null ? temp : peek(this.beforeFilterLog));}, beforeFilterLog: function() {let temp; return ((temp = this._beforeFilterLog) != null ? temp : []);}, afterFilterLog: function() {let temp; return ((temp = this._afterFilterLog) != null ? temp : []);}, firstFailingLogEntry: function() {let from, into, to, i, temp, from1, into1, to1, i1, temp1; return (from = this.beforeFilterLog, into = null, (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let entry; entry = from[i]; if (isFailure(entry.status)) {into = entry; break;}; temp = i++;}; return temp;})()) : undefined, into) || (from1 = this.afterFilterLog, into1 = null, (from1 != null) ? (to1 = from1.length, i1 = 0, (() => {while (i1 < to1) {let entry; entry = from1[i1]; if (isFailure(entry.status)) {into1 = entry; break;}; temp1 = i1++;}; return temp1;})()) : undefined, into1);}, activeFilterLog: function() {return this.isRequest ? this._beforeFilterLog : this._afterFilterLog;}, filterLog: function() {return Caf.array(compactFlatten([this.beforeFilterLog, this.afterFilterLog]), (entry) => (entry.exception || isFailure(entry.status)) ? entry : objectWithout(entry, "stack", "exception"));}}); this.prototype.createFilterLog = function(filter, context, status = pending) {let base, base1; return {name: isString(filter) ? filter : Caf.exists(filter) && filter.name, context, status, location: this.location, time: currentSecond(), stack: Caf.exists(base = this.originalRequest) && base.creationStack, exception: Caf.exists(base1 = this.errorProps) && base1.exception};}; this.prototype.addFilterLog = function(filter, context, status = this.status) {let newFilterLog; this._setActiveFitlerLog(arrayWith(this.activeFilterLog, newFilterLog = this.createFilterLog(filter, context, status))); return newFilterLog;}; this.prototype._setActiveFitlerLog = function(newFilterLog) {return this.isRequest ? this._beforeFilterLog = newFilterLog : this._afterFilterLog = newFilterLog;}; this.getter({pipelineAndType: function() {return `${Caf.toString(this.pipelineName)}.${Caf.toString(this.type)}`;}, requestString: function() {return this.key ? this.pipelineAndType + `(${Caf.toString(JSON.stringify(this.key))})` : this.pipelineAndType;}, description: function() {return this.isRequest ? `${Caf.toString(this.requestString)} request` : `${Caf.toString(this.requestString)}: ${Caf.toString(this.status)}`;}, requestChain: function() {let base; return compactFlatten([this.isResponse ? this.request.requestChain : Caf.exists(base = this.parentRequest) && base.requestChain, this]);}, handledBy: function() {return (this.isResponse && !this.isError) ? peek(this.beforeFilterLog) : undefined;}, failedIn: function() {return (this.isResponse && this.isError) ? Caf.find(this.filterLog, null, (entry) => entry.exception || isFailure(entry.status)) : undefined;}, requestTrace: function() {let base; return compactFlatten([Caf.exists(base = this.parentRequest || this.remoteRequest) && base.requestTrace, this]);}, requestPathArray: function(_into) {let localInto, base; localInto = _into != null ? _into : []; Caf.exists(base = this.parentRequest) && base.getRequestPathArray(localInto); localInto.push(this); return localInto;}, requestPath: function() {return Caf.array(this.requestPathArray, (r) => r.requestString).join(" >> ");}, simpleInspectedObjects: function() {let props, raw; props = objectWithout(this.props, "key", "data"); if (!(0 < objectKeyCount(props))) {props = null;}; raw = {[`${Caf.toString(this.isResponse ? "response" : "request")}`]: this.requestString, originatedOnServer: this.originatedOnServer, data: this.data, status: this.status, location: this.location, props, errorProps: this.errorProps, session: this.session}; return toInspectedObjects(Caf.object(raw, null, (v) => v != null));}, inspectedObjects: function() {return {"Art.Pipelines.Request": Caf.array(this.requestChain, (request) => request.simpleInspectedObjects)};}, summary: function() {return this.isRequest ? {request: {props: this.props}} : {response: merge({status: this.status, props: this.props, errorProps: this.errorProps})};}}); this.prototype.toStringCore = function() {return `ArtPipeline-${Caf.toString(this.isResponse ? "Response" : "Request")} ${Caf.toString(this.pipelineName)}.${Caf.toString(this.type)}${Caf.toString(this.key ? ` key: ${Caf.toString(this.key)}` : "")}`;}; this.prototype.toString = function() {return `<${Caf.toString(this.toStringCore())}>`;}; this.prototype.toJSON = function() {return this.inspectedObjects;}; this.getter({requestCache: function() {let temp, base; return ((temp = (base = this.context).requestCache) != null ? temp : base.requestCache = {});}, subrequestCount: function() {let temp, base; return ((temp = (base = this.context).subrequestCount) != null ? temp : base.subrequestCount = 0);}}); this.prototype.incrementSubrequestCount = function() {return this.context.subrequestCount = (this.context.subrequestCount | 0) + 1;}; this.prototype.createSubRequest = function(pipelineName, type, requestOptions) {let pipeline, temp, temp1; if (requestOptions && !isPlainObject(requestOptions)) {throw new Error("requestOptions must be an object");}; pipeline = this.pipelines[pipelineName]; if (!pipeline) {throw new Error(`Pipeline not registered: ${Caf.toString(formattedInspect(pipelineName))}`);}; return new Request(merge({location: this.location, originatedOnServer: ((temp = Caf.exists(requestOptions) && requestOptions.originatedOnServer) != null ? temp : true)}, requestOptions, {type, pipeline, verbose: this.verbose, session: Caf.exists(requestOptions) && requestOptions.session || this.session, parentRequest: ((temp1 = this._request) != null ? temp1 : this), context: this.context}));}; this.prototype.subrequest = function(pipelineOrPipelineName, type, requestOptionsOrKey, requestOptionsAfterKey) {let requestOptions, subrequest, pipelineName, temp; requestOptions = isString(requestOptionsOrKey) ? merge(requestOptionsAfterKey, {key: requestOptionsOrKey}) : requestOptionsOrKey; subrequest = this.createSubRequest(pipelineName = ((temp = pipelineOrPipelineName.pipelineName) != null ? temp : pipelineOrPipelineName), type, requestOptions); this.incrementSubrequestCount(); return subrequest.pipeline._processRequest(subrequest).then((response) => response.toPromise(requestOptions));}; this.prototype.nonblockingSubrequest = function(pipelineName, type, requestOptions) {this.subrequest(pipelineName, type, requestOptions).then((result) => config.verbose ? log({ArtPipelines: {Request: {nonblockingSubrequest: {status: "success", pipelineName, type, requestOptions, parentRequest: {pipelineName: this.pipelineName, type: this.type, key: this.key}, result}}}}) : undefined).catch((error) => log({ArtPipelines: {Request: {nonblockingSubrequest: {status: "failure", pipelineName, type, requestOptions, parentRequest: {pipelineName: this.pipelineName, type: this.type, key: this.key}, error}}}})); return Promise.resolve();}; this.prototype._getPipelineTypeCache = function(pipelineName, type) {let temp, base, temp1, base1; return ((temp = (base = ((temp1 = (base1 = this.requestCache)[pipelineName]) != null ? temp1 : base1[pipelineName] = {}))[type]) != null ? temp : base[type] = {});}; this.prototype.cachedSubrequest = function(pipelineName, requestType, keyOrRequestProps, d) {if (d !== undefined) {throw new Error("DEPRICATED: 4-param cachedSubrequest");}; return this._cachedSubrequest(pipelineName, requestType, requestType, keyOrRequestProps);}; this.prototype._cachedSubrequest = function(pipelineName, cacheType, requestType, keyOrRequestProps) {let key, temp, base; key = isString(keyOrRequestProps) ? keyOrRequestProps : keyOrRequestProps.key; if (!isString(key)) {throw new Error(`_cachedSubrequest: key must be a string (${Caf.toString(formattedInspect({key}))})`);}; return ((temp = (base = this._getPipelineTypeCache(pipelineName, cacheType))[key]) != null ? temp : base[key] = this.subrequest(pipelineName, requestType, keyOrRequestProps).catch((error) => (error.status === networkFailure && requestType === "get") ? timeout(20 + 10 * Math.random()).then(() => this.subrequest(pipelineName, requestType, keyOrRequestProps)) : (() => {throw error;})()));}; this.prototype.setGetCache = function() {return (this.status === success && present(this.key) && this.responseData != null) ? this._getPipelineTypeCache(this.pipelineName, "get")[this.key] = Promise.then(() => this.responseData) : undefined;}; this.prototype.cachedGet = cachedGet = function(pipelineName, key) {if (isPlainObject(key)) {key = this.pipelines[pipelineName].dataToKeyString(key);}; if (!isString(key)) {throw new Error(`cachedGet: key must be a string OR object when pipeline supports dataToKeyString (${Caf.toString(formattedInspect({key}))})`);}; return this.cachedSubrequest(pipelineName, "get", key);}; this.prototype.cachedGetWithoutInclude = function(pipelineName, key) {let temp; if (!isString(key)) {throw new Error(`cachedGetWithoutInclude: key must be a string (${Caf.toString(formattedInspect({key}))})`);}; return ((temp = this._getPipelineTypeCache(pipelineName, "get")[key]) != null ? temp : this._cachedSubrequest(pipelineName, "get-no-include", "get", {key, props: {include: false}}));}; this.prototype.cachedPipelineGet = cachedGet; this.prototype.cachedGetIfExists = function(pipelineName, key) {if (!(key != null)) {return Promise.resolve(null);}; return this.cachedGet(pipelineName, key).catch((error) => (error.status === missing) ? Promise.resolve(null) : (() => {throw error;})());}; createRequirementNotMetRequestProps = function(pipelineAndType, errors, stackException) {let data; return {data: data = {details: compactFlatten([pipelineAndType, "requirement not met", errors]).join(" - "), message: "Request requirement not met: " + compactFlatten([errors]).join(" - ")}, errorProps: getDetailedRequestTracingEnabled() ? {exception: stackException != null ? stackException : new Error(data.message)} : undefined};}; this.prototype.rejectIfErrors = function(errors, stackException) {return errors ? this.clientFailure(createRequirementNotMetRequestProps(this.pipelineAndType, errors, stackException)).then((response) => response.toPromise()) : Promise.resolve(this);}; this.prototype.rejectNotAuthorizedIfErrors = function(errors) {return errors ? this.clientFailureNotAuthorized(createRequirementNotMetRequestProps(this.pipelineAndType, errors)).then((response) => response.toPromise()) : Promise.resolve(this);}; this._resolveRequireTestValue = resolveRequireTestValue = function(testValue) {if (isFunction(testValue)) {testValue = testValue();}; return Promise.resolve(testValue);}; this.prototype.require = function(test, context) {let stackException; if (getDetailedRequestTracingEnabled()) {stackException = new Error(context);}; return resolveRequireTestValue(test).then((test) => this.rejectIfErrors(!test ? context != null ? context : [] : undefined, stackException));}; this.prototype.requiredFields = function(fields, context) {let missingFields; missingFields = null; Caf.each2(fields, (v, k) => (missingFields != null ? missingFields : missingFields = []).push(k), (v, k) => !(v != null)); return this.rejectIfErrors(missingFields ? ["missing fields: " + missingFields.join(", "), context] : undefined).then(() => fields);}; this.prototype.rejectIf = function(testValue, context) {return resolveRequireTestValue(testValue).then((testValue) => this.require(!testValue, context));}; this.prototype.requireServerOrigin = function(context) {return this.requireServerOriginOr(false, context);}; this.prototype.requireServerOriginOr = function(testValue, context) {if (this.originatedOnServer) {return Promise.resolve(this);}; return resolveRequireTestValue(testValue).then((testValue) => this.rejectNotAuthorizedIfErrors(!testValue ? "originatedOnServer required " + ((Caf.exists(context) && context.match(/\s*to\s/)) ? context : context ? `to ${Caf.toString(context)}` : "") : undefined));}; this.prototype.requireServerOriginIf = function(testValue, context) {if (this.originatedOnServer) {return Promise.resolve(this);}; return resolveRequireTestValue(testValue).then((testValue) => this.requireServerOriginOr(!testValue, context));}; this.prototype.with = function(constructorOptions) {return Promise.resolve(constructorOptions).then((constructorOptions) => this._with(constructorOptions));}; this.prototype._with = function(o) {return new this.class(merge(this.propsForClone, o));}; this.prototype.withData = function(data) {return Promise.resolve(data).then((data) => this._with({data}));}; this.prototype.withMergedData = function(data) {return Promise.resolve(data).then((data) => this._with({data: merge(this.data, data)}));}; this.prototype.withKey = function(data) {return Promise.resolve(data).then((key) => this._with({key}));}; this.prototype.withProps = function(props) {return Promise.resolve(props).then((props) => this._with({props, key: props.key, data: props.data}));}; this.prototype.withMergedProps = function(props) {return Promise.resolve(props).then((props) => this._with({key: props.key, data: props.data, props: merge(this.props, props)}));}; this.prototype.withMergedPropsWithoutNulls = function(props) {return Promise.resolve(props).then((props) => this._with({key: props.key, data: props.data, props: mergeWithoutNulls(this.props, props)}));}; this.prototype.withMergedErrorProps = function(errorProps) {return Promise.resolve(errorProps).then((errorProps) => this._with({errorProps: merge(this.errorProps, errorProps)}));}; this.prototype.withSession = function(session) {return Promise.resolve(session).then((session) => this._with({session}));}; this.prototype.withMergedSession = function(session) {return Promise.resolve(session).then((session) => this._with({session: merge(this.session, session)}));}; this.prototype.respondWithSession = function(session) {return this.success({session});}; this.prototype.respondWithMergedSession = function(session) {return this.success({session: merge(this.session, session)});}; defaultWhenTest = function(data, request) {return request.pipeline.isRecord(data);}; this.prototype.withTransformedRecords = function(withFunction, whenFunction = defaultWhenTest) {let options, firstFailure, transformedRecords, temp; if (isPlainObject(options = withFunction)) {withFunction = options.with; whenFunction = ((temp = options.when) != null ? temp : defaultWhenTest);}; return isPlainObject(this.data) ? Promise.resolve(whenFunction(this.data, this) ? this.next(withFunction(this.data, this)) : this) : isArray(this.data) ? (firstFailure = null, transformedRecords = Caf.array(this.data, (record) => Promise.then(() => whenFunction(record, this) ? withFunction(record, this) : record).catch((error) => {let response, base; return (() => {switch (false) {case !(error.status === "missing"): return null; case !(response = Caf.exists(error) && (Caf.exists(base = error.props) && base.response)): return response; default: return (() => {throw error;})();};})();}).then((out) => (Caf.exists(out) && out.status && out instanceof Request) ? isClientFailure(out.status) ? (Caf.isF(out._clearErrorStack) && out._clearErrorStack(), null) : firstFailure != null ? firstFailure : firstFailure = out : out)), Promise.all(transformedRecords).then((records) => firstFailure != null ? firstFailure : this.withData(compactFlatten(records)))) : Promise.resolve(this);}; this.prototype.next = function(data) {return Promise.resolve(data).then((data) => {if (data instanceof Request) {return data;}; return (() => {switch (false) {case !(!(data != null)): return this.missing(); case !isJsonType(data): return this.success({data}); default: return (() => {throw new Error("invalid response data passed to RequestResponseBaseNext");})();};})();}, (error) => {let base, base1; return (Caf.exists(base = error.props) && (Caf.exists(base1 = base.response) && base1.isResponse)) ? error.props.response : this.failure({error});});}; this.prototype.success = function(responseProps) {return this.toResponse(success, responseProps);}; this.prototype.missing = function(responseProps) {return this.toResponse(missing, responseProps);}; this.prototype.clientFailure = function(responseProps) {return this.toResponse(clientFailure, responseProps);}; this.prototype.clientFailureNotAuthorized = function(responseProps) {return this.toResponse(clientFailureNotAuthorized, responseProps);}; this.prototype.failure = function(responseProps) {return this.toResponse(failure, responseProps);}; this.prototype.rejectWithMissing = function(responseProps) {return this.toResponse(missing, responseProps, true);}; this.prototype.rejectWithClientFailure = function(responseProps) {return this.toResponse(clientFailure, responseProps, true);}; this.prototype.rejectWithClientFailureNotAuthorized = function(responseProps) {return this.toResponse(clientFailureNotAuthorized, responseProps, true);}; this.prototype.rejectWithFailure = function(responseProps) {return this.toResponse(failure, responseProps, true);}; this.prototype.toResponse = function(status, responseProps, returnRejectedPromiseOnFailure = false) {let creationStack; if (!isString(status)) {throw new Error("missing status");}; if (getDetailedRequestTracingEnabled() && isFailure(status)) {creationStack = (new Error()).stack;}; return Promise.resolve(responseProps).then((responseProps = {}) => {let temp; return (() => {switch (false) {case !(responseProps instanceof Request): log.warn("DEPRICATED: toResponse is instanceof Request"); return responseProps; case !isString(responseProps): return this.toResponse(status, {creationStack, data: {message: responseProps}}); case !isPlainObject(responseProps): return new Request(merge(this.propsForResponse, {creationStack}, responseProps, {status, request: ((temp = this._request) != null ? temp : this)})); default: return this.toResponse(failure, merge(this._toErrorResponseProps(responseProps), {creationStack}));};})();}).then((response) => returnRejectedPromiseOnFailure ? response.toPromise() : response);}; this.prototype._toErrorResponseProps = function(responseProps) {return log.error(this, {responseProps}, {data: {message: (responseProps instanceof Error) ? `Internal Error: ArtPipelines.Request#toResponse received Error instance: ${Caf.toString(formattedInspect(responseProps))}` : "Internal Error: ArtPipelines.Request#toResponse received unsupported type"}});}; this.prototype.toPromise = function(options) {let returnNullIfMissing, returnResponse, returnResponseObject, data, isSuccessful, isMissing, temp; if (!this.isResponse) {throw new Error("ArtPipelines.Request: toPromise can only be called on Response objects.");}; if (Caf.exists(options)) {returnNullIfMissing = options.returnNullIfMissing; returnResponse = options.returnResponse; returnResponseObject = options.returnResponseObject;}; temp = this; data = temp.data; isSuccessful = temp.isSuccessful; isMissing = temp.isMissing; returnResponse != null ? returnResponse : returnResponse = returnResponseObject; if (isMissing && returnNullIfMissing) {data = null; isSuccessful = true;}; return isSuccessful ? Promise.resolve(returnResponse ? this : data) : Promise.reject(this._getRejectionError());}; this.prototype._getRejectionError = function() {let message, exception, temp, temp1, base, base1, base2, base3, temp2, temp3, base4, base5, base6, base7, base8, base9, from, into, i1, temp4; if (!this._preparedRejectionError) {this._preparedRejectionError = new RequestError({message: compactFlatten([((temp = ((temp1 = Caf.exists(base = this.responseData) && base.message) != null ? temp1 : Caf.exists(base1 = this.responseProps) && base1.message)) != null ? temp : Caf.exists(base2 = this.errorProps) && (Caf.exists(base3 = base2.exception) && base3.message)), "", `request: ${Caf.toString(this.pipeline)}.${Caf.toString(this.type)}`, formattedInspect({status: this.status, session: this.session, props: this.requestProps})]).join("\n"), type: this.type, status: this.status, requestProps: this.requestProps, responseProps: this.responseProps, sourceLib: "ArtPipelines", stack: compactFlatten([((message = ((temp2 = ((temp3 = Caf.exists(base4 = this.responseData) && base4.message) != null ? temp3 : Caf.exists(base5 = this.responseProps) && base5.message)) != null ? temp2 : Caf.exists(base6 = this.errorProps) && (Caf.exists(base7 = base6.exception) && base7.message))) && !message.match(Caf.exists(exception) && (Caf.exists(base8 = exception.stack) && base8[0]))) ? message : undefined, (exception = Caf.exists(base9 = this.errorProps) && base9.exception) ? cleanStackTrace(exception.stack, {keepErrorLines: true, quiet: true}) : undefined, (from = this.requestTrace, into = [], (from != null) ? (i1 = from.length - 1, (() => {while (i1 >= 0) {let request, i, requestString, filterLog, location, rootRequest, creationStack, name, time, context, stack, compactFilterLog, temp5; request = from[i1]; i = i1; into.push(((requestString = request.requestString, filterLog = request.filterLog, location = request.location, rootRequest = request.rootRequest, creationStack = rootRequest.creationStack), Caf.exists(temp5 = request.firstFailingLogEntry || request.lastFilterLogEntry) ? (name = temp5.name, time = temp5.time, context = temp5.context, stack = temp5.stack, exception = temp5.exception) : undefined, time -= this.startTime, compactFilterLog = (filterLog != null) ? Caf.array(filterLog, ({name, context}) => compactFlatten([name, context]).join("-"), ({name, context}) => context !== "created" && context !== "completed").join(" -> ") : `${Caf.toString(context)} ${Caf.toString(name)}`, `request ${Caf.toString(request)}: ${Caf.toString(compactFilterLog)} (status: ${Caf.toString(this.status)}, location: ${Caf.toString(location)}, request-depth: ${Caf.toString(i + 1)}, start-time: ${Caf.toString(time * 1000 | 0)}ms)\n${Caf.toString(stack ? `${Caf.toString(cleanStackTrace(stack, {quiet: true}))}\n` : "")}\n${Caf.toString((creationStack && creationStack !== stack) ? `${Caf.toString(cleanStackTrace(creationStack, {quiet: true}))}\n` : "")}`)); temp4 = i1--;}; return temp4;})()) : undefined, into).join("\n\n"), getDetailedRequestTracingExplanation(), cleanStackTraceWarnings]).join("\n").replace(/\n\s*\n\s*[\n+]/g, "\n\n")}); Object.defineProperty(this._preparedRejectionError.props, "response", {value: this, writable: false});}; return this._preparedRejectionError;};});});});
//# sourceMappingURL=Request.js.map
