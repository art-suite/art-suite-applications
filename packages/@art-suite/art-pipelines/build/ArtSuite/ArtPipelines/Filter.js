"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Validator", "isPlainArray", "compactFlatten", "isClass", "isFunction", "Error", "isPlainObject", "inspect", "merge", "filterLocations", "objectHasKeys", "Object"], [global, require('./StandardImport')], (Validator, isPlainArray, compactFlatten, isClass, isFunction, Error, isPlainObject, inspect, merge, filterLocations, objectHasKeys, Object) => {let normalizeFields, Filter; normalizeFields = Validator.normalizeFields; return Filter = Caf.defClass(class Filter extends require('./RequestHandler') {constructor(options = {}) {let requestTypes, temp, temp1, temp2; super(...arguments); this.serverSideOnly = options.serverSideOnly; this.clientSideOnly = options.clientSideOnly; this.name = ((temp = options.name) != null ? temp : this.class.getName()); this.location = ((temp1 = options.location) != null ? temp1 : this.class.getLocation()); this.fields = options.fields; this.group = options.group; this.filterFailures = options.filterFailures; this.after = options.after; this.before = options.before; if (requestTypes = ((temp2 = options.requestType) != null ? temp2 : options.requestTypes)) {this.extendRequestTypes(requestTypes);};};}, function(Filter, classSuper, instanceSuper) {this.preprocessFilters = (filter) => isPlainArray(filter) ? Caf.array(compactFlatten(filter), (f) => this.preprocessFilter(f), (f) => f) : this.preprocessFilter(filter); this.preprocessFilter = function(filter) {return isClass(filter) ? new filter : isFunction(filter) ? (() => {throw new Error("Passing a function for Filter definition is DEPRICATED");})() : (filter instanceof Filter) ? filter : isPlainObject(filter) ? new Filter(filter) : (() => {throw `invalid filter: ${Caf.toString(inspect(filter))} ${Caf.toString(filter instanceof Filter)}`;})();}; this.extendableProperty({before: {}, after: {}}); this.extendableProperty({fields: {}}, {extend: function(oldFields, addFields) {return merge(oldFields, normalizeFields(addFields));}}); this.field = this.extendFields; this.extendableProperty({requestTypes: {}}); this.requestType = this.extendRequestTypes; this.extendableProperty({filterFailures: false}); this.extendableProperty({location: "server"}, {extend: function(__, v) {if (!filterLocations[v]) {throw new Error(`invalid location: ${Caf.toString(v)}`);}; return v;}}); this.groupNames = {loggers: 3, authorization: 2, outer: 1, middle: 0, inner: -1, handler: -2}; this.extendableProperty({group: this.groupNames.middle}, {extend: function(__, v) {let value; return (v != null) ? (!((value = Filter.groupNames[v]) != null) ? (() => {throw new Error(`invalid Filter group: ${Caf.toString(v)}`);})() : undefined, value) : 0;}}); this.getter({priority: function() {return this.group;}, props: function() {return {location: this.location};}, inspectedObjects: function() {return {filter: merge({name: this.name, location: this.location, group: this.group}, {before: objectHasKeys(this.before) ? Object.keys(this.before) : undefined, after: objectHasKeys(this.after) ? Object.keys(this.after) : undefined})};}}); this.property("name"); this.prototype.shouldFilter = function(processingLocation) {return (() => {switch (this.location) {case "server": return processingLocation !== "client"; case "client": return processingLocation !== "server"; case "both": return true; default: return (() => {throw new Error(`Filter ${Caf.toString(this.getName())}: invalid filter location: ${Caf.toString(this.location)}`);})();};})();}; this.prototype.toString = function() {return this.getName();}; this.prototype.getBeforeFilter = function({requestType, location}) {return this.shouldFilter(location) && (this.before[requestType] || this.before.all);}; this.prototype.getAfterFilter = function({requestType, location}) {return this.shouldFilter(location) && (this.after[requestType] || this.after.all);}; this.prototype.processBefore = function(request) {return this.applyHandler(request, this.getBeforeFilter(request), "beforeFilter");}; this.prototype.processAfter = function(request) {return this.applyHandler(request, this.getAfterFilter(request), "afterFilter");}; this.prototype.handleRequest = function(request, filterChain, currentFilterChainIndex) {return this.processBefore(request).then((request) => {let nextHandler, nextIndex; return request.isResponse ? request : ((nextHandler = filterChain[nextIndex = currentFilterChainIndex + 1]) ? nextHandler.handleRequest(request, filterChain, nextIndex) : request.failure(`INTERNAL-ERROR: no nextHandler for request type: ${Caf.toString(request.type)}`)).then((response) => (response.isSuccessful || this.filterFailures) ? this.processAfter(response) : response);});};});});});
//# sourceMappingURL=Filter.js.map
