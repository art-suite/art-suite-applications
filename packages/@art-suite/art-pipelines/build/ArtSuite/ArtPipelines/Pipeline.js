"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["w", "compactFlatten", "Object", "Filter", "lowerCamelCase", "decapitalize", "getCodeWords", "pluralize", "normalizeFieldProps", "isString", "isPlainObject", "Error", "formattedInspect", "objectHasKeys", "Array", "objectKeyCount", "merge", "mergeInto", "String", "validateLocation", "log", "inspectedObjectLiteral", "isFunction", "pushIfNotPresent", "getDetailedRequestTracingEnabled", "Promise", "Request", "cleanStackTrace", "push", "removeFirstMatch", "isArray", "currentSecond", "present"], [global, require('./StandardImport'), require('art-validation'), require('./Config'), {Filter: require('./Filter'), Session: require('./Session'), Request: require('./Request')}], (w, compactFlatten, Object, Filter, lowerCamelCase, decapitalize, getCodeWords, pluralize, normalizeFieldProps, isString, isPlainObject, Error, formattedInspect, objectHasKeys, Array, objectKeyCount, merge, mergeInto, String, validateLocation, log, inspectedObjectLiteral, isFunction, pushIfNotPresent, getDetailedRequestTracingEnabled, Promise, Request, cleanStackTrace, push, removeFirstMatch, isArray, currentSecond, present) => {let Pipeline; return Pipeline = Caf.defClass(class Pipeline extends require('./RequestHandler') {constructor(_deprecatedOptions) {super(...arguments); this._subscribers = {}; this._querySubscribers = {}; this._filtersForLocation = {}; this._groupedFiltersForLocation = {}; this._filterChainsForLocation = {}; if (_deprecatedOptions) {throw new Error("DEPRECATED: constructor options. For custom session, use: @registry new PipelineRegistry");};};}, function(Pipeline, classSuper, instanceSuper) {let publicHandlers, normalizeFieldsProps, normalizeQuery, noOptions, mostRecentSessionUpdatedAt; this.abstractClass(); this.register = function() {this.singletonClass(); return this.getRegistry().register(this);}; this.postCreateConcreteClass = function({hotReloaded}) {this._defineQueryHandlers(); this._defineClientHandlerMethods(); this._initFilters(); if (!hotReloaded) {this.register();}; return classSuper.postCreateConcreteClass.apply(this, arguments);}; this.classGetter({pipelines: function() {return this.getRegistry().pipelines;}}); this.getAliases = function() {return this._aliases || {};}; this.extendableProperty({requestTypes: {}}); this.requestType = this.extendRequestTypes; this.extendableProperty({fields: {}}); this.field = this.extendFields; this.extendableProperty({publicRequestTypes: {}}, {extend: function(publicRequestTypes, ...values) {return Caf.object(w(compactFlatten(values).join(" ")), () => true, null, publicRequestTypes);}}); this.publicRequestType = this.extendPublicRequestTypes; this.publicHandlers = publicHandlers = function(...maps) {return Caf.each2(maps, (map) => {this.handlers(map); return this.publicRequestTypes(Object.keys(map));});}; this.publicHandler = publicHandlers; this.extendableProperty({filters: []}, {extend: function(filters, ...addFilters) {return filters.concat(Filter.preprocessFilters(addFilters));}}); this.filter = this.extendFilters; this.extendableProperty({handlers: {}}); this.handler = this.extendHandlers; this.extendableProperty({queries: {}}, {extend: function(queries, newQueries) {return Caf.object(newQueries, (options, queryName) => normalizeQuery(queryName, options), null, queries);}}); this.query = this.extendQueries; this.aliases = function(...args) {this._aliases = Caf.object(args, (v, k) => true, null, null, (v, k) => lowerCamelCase(v)); return this;}; this.alias = this.extendAliases; this.classGetter("clientApiMethodList", {pipelineName: function() {let temp; return ((temp = this._pipelineName) != null ? temp : decapitalize(this.getName()));}, recordName: function() {return this.pipelineName;}, pluralPipelineName: function() {let parts; if (this._pluralPipelineName) {return this._pluralPipelineName;}; parts = getCodeWords(this.getPipelineName()); parts.push(pluralize(parts.pop())); return this._pluralPipelineName = lowerCamelCase(parts);}}); normalizeFieldsProps = function(fieldsProps, fields) {return fieldsProps ? normalizeFieldProps((() => {switch (false) {case !isString(fieldsProps): return fieldsProps; case !isPlainObject(fieldsProps): return {fields: fieldsProps}; default: return (() => {throw new Error(`expecting Object of fields, or string for singleton. Got: ${Caf.toString(formattedInspect(fieldsProps))}`);})();};})(), {record: {fields}}) : undefined;}; this._normalizeRequestResponseProps = function(requestType, requestResponseProps, fields) {let key, keyFields, data, props, keyArray, keyCount; return requestResponseProps ? ((key = requestResponseProps.key, keyFields = requestResponseProps.keyFields, data = requestResponseProps.data, props = requestResponseProps.props), (key === true) ? (keyFields = this.keyFields, key = Caf.object(fields, null, (v, k) => Caf.in(k, keyFields)), !objectHasKeys(key) ? (() => {throw new Error(`Error defining requestType '${Caf.toString(this.name)}.${Caf.toString(requestType)}': One or more keyFields (${Caf.toString(formattedInspect(keyFields))}) are missing from the pipeline's fields definitions: ${Caf.toString(Object.keys(this.fields).join(", "))}`);})() : undefined) : key ? ((Caf.is(keyArray = key, Array)) ? Caf.each2(keyArray, (v) => {let def; return (Caf.is(v, Object)) ? mergeInto(key, v) : (Caf.is(v, String)) ? !(key[v] = def = this.fields[v]) ? (() => {throw new Error(`Error defining requestType '${Caf.toString(this.name)}.${Caf.toString(requestType)}': Key's field (${Caf.toString(v)}) was not found in the pipeline's fields definitions: ${Caf.toString(Object.keys(this.fields).join(", "))}`);})() : undefined : undefined;}, null, key = {}) : undefined, (Caf.is(key, Object)) ? (keyCount = objectKeyCount(key), (keyCount > 1 && (Caf.exists(keyFields) && keyFields.length) !== keyCount) ? (() => {throw new Error(`Error defining requestType '${Caf.toString(this.name)}.${Caf.toString(requestType)}': Key's definition (${Caf.toString(formattedInspect(key))}) must have a matching keyFields (${Caf.toString(formattedInspect(keyFields))}) for serialization purposes`);})() : undefined) : undefined) : undefined, merge({keyFields, key: normalizeFieldsProps(key, fields), data: normalizeFieldsProps(data, fields), props: normalizeFieldsProps(props, fields)})) : undefined;}; this.classGetter({normalizedRequestTypes: function() {let temp; return ((temp = this._normalizedRequestTypes) != null ? temp : this._normalizedRequestTypes = Caf.object(this.getRequestTypes(), ({request, response}, k) => merge({request: request ? this._normalizeRequestResponseProps(k, request, this.getFields()) : undefined, response: response ? this._normalizeRequestResponseProps(k, response, this.getFields()) : undefined})));}}); this.getter({keyFields: function() {return ["id"];}, name: function() {return this.class.pipelineName;}, pipelineName: function() {return this.class.pipelineName;}, recordName: function() {return this.class.recordName;}, normalizedRequestTypes: function() {return this.class.normalizedRequestTypes;}, session: function() {return this.registry.session;}, defaultLocation: function() {return this.registry.defaultLocation;}, clientApiMethodList: function() {return this.class.clientApiMethodList;}, normalizedFields: function() {return Caf.object(this.fields, (v) => normalizeFieldProps(v));}, aliases: function() {let temp; return ((temp = this._aliases) != null ? temp : this._aliases = Object.keys(this.class.getAliases()));}, groupedFilters: function() {let temp; return ((temp = this._groupedFilters) != null ? temp : this._groupedFilters = Pipeline.groupFilters(this.filters));}, beforeFilters: function() {let temp; return ((temp = this._beforeFilters) != null ? temp : this._beforeFilters = this.groupedFilters.slice().reverse());}, afterFilters: function() {return this.groupedFilters;}, filterChain: function() {let temp; return ((temp = this._filterChain) != null ? temp : this._filterChain = compactFlatten([this, this.groupedFilters]).reverse());}}); this.prototype.getFiltersForLocation = function(location) {let temp, base; return ((temp = (base = this._filtersForLocation)[location]) != null ? temp : base[location] = Caf.array(this.filters, null, (filter) => filter.location === location || filter.location === "both"));}; this.prototype.getGroupedFiltersForLocation = function(location) {let temp, base; if (location === "both") {throw new Error("'both' not supported here");}; return ((temp = (base = this._groupedFiltersForLocation)[location]) != null ? temp : base[location] = Pipeline.groupFilters(this.getFiltersForLocation(location)));}; this.prototype.getFilterChainForLocation = function(location) {let temp, base; validateLocation(location); return ((temp = (base = this._filterChainsForLocation)[location]) != null ? temp : base[location] = compactFlatten([this, (location === "both") ? [this.getGroupedFiltersForLocation("server"), this.getGroupedFiltersForLocation("client")] : this.getGroupedFiltersForLocation(location)]).reverse());}; this.prototype.toString = function() {return this.pipelineName;}; this.prototype.getLogName = function(requestType) {return `${Caf.toString(requestType)}-handler`;}; this.prototype.getRequestProcessingReport = function(location = this.location) {return Caf.object(log(this.requestTypes), (requestType) => compactFlatten([Caf.array(this.getBeforeFilters({requestType, location}), (filter) => inspectedObjectLiteral(filter.getName())), inspectedObjectLiteral((location === "client") ? "[remote request]" : "[local handler]"), Caf.array(this.getAfterFilters({requestType, location}), (filter) => inspectedObjectLiteral(filter.getName()))]));}; this.getter({pipelineReport: function(processingLocation) {let out; out = {tableName: this.tableName, fields: Caf.object(this.fields, (fieldProps) => {let out2; return Caf.each2(Object.keys(fieldProps).sort(), (k) => {let v; v = fieldProps[k]; return !isFunction(v) ? out2[k] = v : undefined;}, null, out2 = {});})}; if (processingLocation) {out[`${Caf.toString(processingLocation)}Processing`] = this.getRequestProcessingReport("client");} else {out.clientSideRequestProcessing = this.getRequestProcessingReport("client"); out.serverSideRequestProcessing = this.getRequestProcessingReport("server"); out.serverlessDevelopmentRequestProcessing = this.getRequestProcessingReport("both");}; return out;}, inspectedObjects: function() {return {name: this.name, publicRequestTypes: Object.keys(this.publicRequestTypes).sort(), requestTypes: Caf.array(this.requestTypes).sort(), subscriberCounts: Caf.object(this._subscribers, (subscribers) => subscribers.length), querySubscriberCounts: Caf.object(this._querySubscribers, (querySubs) => Caf.object(querySubs, (subscribers) => subscribers.length))};}}); this.prototype.toJSON = function() {return this.inspectedObjects;}; this.groupFilters = function(filters) {let priorityLevels, sortedFilters; priorityLevels = []; Caf.each2(filters, ({priority}) => pushIfNotPresent(priorityLevels, priority)); sortedFilters = []; Caf.each2(priorityLevels.sort((a, b) => a - b), (priorityLevels) => Caf.each2(filters, (filter) => sortedFilters.push(filter), (filter) => priorityLevels === filter.priority)); return sortedFilters;}; this.prototype.getBeforeFilters = function(request) {return Caf.array(this.beforeFilters, null, (filter) => filter.getBeforeFilter(request));}; this.prototype.getAfterFilters = function(request) {return Caf.array(this.afterFilters, null, (filter) => filter.getAfterFilter(request));}; this.prototype.cachedGet = function(request, key) {return request.cachedGet(this.pipelineName, key != null ? key : request.key);}; this.prototype.createRequest = function(type, options) {let stack; if (getDetailedRequestTracingEnabled()) {stack = (new Error).stack;}; return Promise.then(() => options.session || this.session.loadedDataPromise).tapCatch((error) => log.error({Pipeline_createRequest: {message: "Error getting session", info: {pipelineName: this.pipelineName, type, options}, error}})).then((sessionData) => new Request(merge(options, {type, pipeline: this, session: sessionData, creationStack: stack}))).catch((error) => {if (stack != null) {error.stack = cleanStackTrace(stack);}; error.message += `\n\ninside ${Caf.toString(this.name)}.` + formattedInspect({createRequest: {type, options}}); return (() => {throw error;})();});}; this.prototype.subscribe = function(key, subscriber, queryName) {let subscribersForKey, temp, base; return !(Caf.in(subscriber, subscribersForKey = ((temp = (base = this._getSubscribers(queryName))[key]) != null ? temp : base[key] = []))) ? (push(subscribersForKey, subscriber), this.subscriberAdded(key, subscriber, queryName), subscriber) : undefined;}; this.prototype.unsubscribe = function(key, subscriber, queryName) {let subscribers, subscribersForKey; subscribers = this._getSubscribers(queryName); return (Caf.in(subscriber, subscribersForKey = subscribers[key])) ? (removeFirstMatch(subscribersForKey, subscriber), (subscribersForKey.length === 0) ? delete subscribers[key] : undefined, this.subscriberRemoved(key, subscriber, queryName), subscriber) : undefined;}; this.prototype._getSubscribers = function(queryName) {let temp, base; return queryName ? (!this.queries[queryName] ? (() => {throw new Error(`Query does not exist. Model: ${Caf.toString(this.name)}. Query: ${Caf.toString(queryName)}. Existing queries: ${Caf.toString(Object.keys(this.queries).join(", "))}`);})() : undefined, ((temp = (base = this._querySubscribers)[queryName]) != null ? temp : base[queryName] = {})) : this._subscribers;}; this.prototype.subscriberAdded = function(key, subscriber, queryName) {}; this.prototype.subscriberRemoved = function(key, subscriber, queryName) {}; this.prototype.dataUpdated = function(key, data) {return this._sendDataSubscriptionEvent("update", key, data);}; this.prototype.dataDeleted = function(key, data) {return this._sendDataSubscriptionEvent("delete", key, data);}; this.prototype._sendDataSubscriptionEvent = function(eventType, key, data) {let dataArray; return isArray(dataArray = data) ? Caf.each2(dataArray, (data) => this._sendDataSubscriptionEventSingle(eventType, key, data)) : this._sendDataSubscriptionEventSingle(eventType, key, data);}; this.prototype._sendDataSubscriptionEventSingle = function(eventType, key, data) {Caf.each2(this._subscribers[key], (subscriber) => subscriber(eventType, key, data)); return data && Caf.each2(this._querySubscribers, (querySubscribers, queryName) => {let queryKey; queryKey = this.queries[queryName].toKeyString(data); return Caf.each2(querySubscribers[queryKey], (subscriber) => subscriber(eventType, key, data, queryKey));});}; this.prototype.isUpdateRequestType = function(actionType) {return /^(create|update)/.test(actionType);}; this.prototype.isDeleteRequestType = function(actionType) {return /^delete/.test(actionType);}; this._defineQueryHandlers = function() {let handlers; handlers = this.getHandlers(); return Caf.each2(this.getQueries(), (pipelineQuery, k) => handlers = this.extendHandlers(k, pipelineQuery.options.query), (pipelineQuery, k) => !handlers[k]);}; this._normalizeQuery = normalizeQuery = function(queryName, options) {let dataToKeyString, toKeyString; if (isFunction(options)) {options = {query: options};}; if (!(isFunction(options.query) && options.query.length > 0)) {throw new Error(`query function must have at least one argument:\n\n${Caf.toString(formattedInspect({queryName, options}))}"`);}; ({dataToKeyString} = options); toKeyString = dataToKeyString ? (dataOrKey) => isPlainObject(dataOrKey) ? dataToKeyString(dataOrKey) : dataOrKey : (key) => (key != null) ? key.toString() : key; return {queryName, options, toKeyString};}; this._defineClientRequestMethod = function(requestType) {let temp, base; if (!(Caf.in(requestType, this.clientApiMethodList))) {this.clientApiMethodList.push(requestType);}; return ((temp = (base = this.prototype)[requestType]) != null ? temp : base[requestType] = function(a, b, c) {return this._processClientRequest(requestType, a, b, c);});}; this._defineClientHandlerMethods = function() {this._clientApiMethodList = []; Caf.each2(this.getHandlers(), (__, name) => this._defineClientRequestMethod(name)); return Caf.each2(this.getPublicRequestTypes(), (__, name) => this._defineClientRequestMethod(name));}; this._initFilters = function() {Caf.each2(this.getFilters(), (filter) => this.extendFields(merge(filter.fields, this.getFields())), (filter) => objectHasKeys(filter.fields)); Caf.each2(this.getFilters(), (filter) => this.extendRequestTypes(merge(filter.requestTypes, this.getRequestTypes())), (filter) => objectHasKeys(filter.requestTypes)); Caf.each2(this.getHandlers(), (_, name) => this.extendRequestTypes({[name]: {}})); Caf.each2(this.getFilters(), (filter) => Caf.each2(filter.before, (_, name) => this.extendRequestTypes({[name]: {}}))); return this.getNormalizedRequestTypes();}; this.prototype.handleRequest = function(request) {let handler; if (request.isResponse) {throw new Error("HARD DEPRICATED");}; return (handler = this.handlers[request.type]) ? this.applyHandler(request, handler, "handler").then((response) => !response.isResponse ? request.failure(`${Caf.toString(this.pipelineName)}.${Caf.toString(request.type)} request was not handled`) : response) : request.failure(`${Caf.toString(this.pipelineName)}: No handler for request type: ${Caf.toString(formattedInspect(request.type))}`);}; this.prototype._processRequest = function(request) {let haveHandler, isPublicRequestType, filterChain; haveHandler = !!this.handlers[request.type]; isPublicRequestType = !!this.getPublicRequestTypes()[request.type]; return !(haveHandler || isPublicRequestType) ? Promise.then(() => request.clientFailure({data: {message: `'${Caf.toString(request.type)}' is an invalid request type`, validRequestTypes: Object.keys(this.handlers)}})) : (filterChain = this.getFilterChainForLocation(request.location), request.requireServerOriginOr(isPublicRequestType, "to issue non-public requests").then(() => filterChain[0].handleRequest(request, filterChain, 0)).tap((response) => !response.isResponse ? log.error({"not response!": response}) : undefined));}; noOptions = {}; this.prototype._processClientRequest = function(type, a, b, c) {let parentRequest, options, requestStartTime; if (!(a != null)) {a = b; b = c;}; if (a != null && a instanceof Request) {parentRequest = a; a = b; b = c;}; options = isString(a) ? merge({key: a}, b) : a != null ? a : noOptions; return parentRequest ? parentRequest.subrequest(this, type, (options !== noOptions) ? options : {props: parentRequest.props}) : (requestStartTime = currentSecond(), this.createRequest(type, options).then((request) => this._processRequest(request)).then((response) => this._processResponseSession(response, requestStartTime)).then((response) => response.toPromise(options)));}; mostRecentSessionUpdatedAt = 0; this.prototype._processResponseSession = function(response, requestStartTime) {let responseSession, currentSession, message; if (responseSession = response.responseSession) {currentSession = this.session.data; message = (requestStartTime > mostRecentSessionUpdatedAt) ? (mostRecentSessionUpdatedAt = requestStartTime, this.session.data = responseSession, "updated") : "out-of-order update blocked";}; return response;}; this.prototype.toKeyString = function(key) {return (() => {switch (false) {case !(!(key != null) || isString(key)): return key; case !(this.dataToKeyString && isPlainObject(key)): return this.dataToKeyString(key); default: return (() => {throw new Error(`override toKeyString or dataToKeyString for non-string-keys like: ${Caf.toString(formattedInspect(key))}`);})();};})();}; this.getter({propsToKey: function() {let temp; return ((temp = this._propsToKey) != null ? temp : this._propsToKey = (() => {let recordType; recordType = this.pipelineName; return (props, stateField) => {let propsField, temp1, base; propsField = stateField != null ? stateField : recordType; return ((temp1 = Caf.exists(base = props[propsField]) && base.id) != null ? temp1 : props[propsField + "Id"]);};})());}}); this.prototype.isRecord = function(data) {return isPlainObject(data) && present(Caf.exists(data) && data.id);}; this.prototype.getFieldsRequestWillModify = function(request) {let temp; return ((temp = request.data) != null ? temp : {});};});});});
//# sourceMappingURL=Pipeline.js.map
