"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["getEnv", "compactFlatten", "isNode", "Error", "String", "compactFlattenAll"], [global, require('art-standard-lib')], (getEnv, compactFlatten, isNode, Error, String, compactFlattenAll) => {let removeFromCleanStackTraceRegExp, notFalseOrFalse, detectStackTracePathRegEx, shouldCleanStackTrace, shouldRepathStackTrace, cleanStackTraceWarnings, repathStackTraceLine, path, cwd, replaceFunc, cleanStackTrace; removeFromCleanStackTraceRegExp = /^\s+at\s+processImmediate|Art.Ery\/(Pipeline|Request|Filter\b)|source\/ArtSuite\/ArtPipelines|<anonymous>|node:internal|node_modules\/.*(mocha|bluebird|jest|art-testbench|@art-suite\/|caffeine-script-runtime)/; notFalseOrFalse = function(v) {return v !== false && v !== "false";}; detectStackTracePathRegEx = /([^ (]+)(?=:\d+)/; return {shouldCleanStackTrace: shouldCleanStackTrace = notFalseOrFalse(getEnv().ART_PIPELINES_CLEAN_STACK_TRACE), shouldRepathStackTrace: shouldRepathStackTrace = notFalseOrFalse(getEnv().ART_PIPELINES_REPATH_STACK_TRACE), cleanStackTraceWarnings: cleanStackTraceWarnings = compactFlatten([shouldCleanStackTrace ? "NOTE: cleanStackTrace applied. (set ART_PIPELINES_CLEAN_STACK_TRACE=false to disable)" : undefined, shouldRepathStackTrace ? "NOTE: repathStackTraceLine(s) applied. (set ART_PIPELINES_REPATH_STACK_TRACE=false to disable)" : undefined]).join("\n"), repathStackTraceLine: repathStackTraceLine = (isNode && shouldRepathStackTrace) ? (path = eval("require")("path"), cwd = global.process.cwd(), replaceFunc = function(filePath) {return path.relative(cwd, filePath);}, function(line) {return line.replace(detectStackTracePathRegEx, replaceFunc);}) : function(line) {return line;}, cleanStackTrace: cleanStackTrace = function(stack, options = {}) {let keepErrorLines, quiet, outputAtLeastOnePathLine, error, pathLineKeepCount, prePathLines, firstPathLine, outLines, out; if (!shouldCleanStackTrace) {return stack;}; keepErrorLines = options.keepErrorLines; quiet = options.quiet; outputAtLeastOnePathLine = options.outputAtLeastOnePathLine; return ((error = stack) instanceof Error) ? (error.stack = cleanStackTrace(error.stack, options), error) : (Caf.is(stack, String)) ? (pathLineKeepCount = 0, prePathLines = [], firstPathLine = null, outLines = [], Caf.each2(stack.split("\n"), null, (line, i) => detectStackTracePathRegEx.test(line) ? (pathLineKeepCount++, firstPathLine != null ? firstPathLine : firstPathLine = line, !removeFromCleanStackTraceRegExp.test(line) ? outLines.push(repathStackTraceLine(line)) : undefined) : (!firstPathLine) ? prePathLines.push(line) : undefined), (outputAtLeastOnePathLine && pathLineKeepCount === 0) ? outLines = [firstPathLine] : undefined, keepErrorLines ? outLines = compactFlattenAll(prePathLines, outLines) : undefined, out = outLines.join("\n"), quiet ? out : out + (/\n\s*$/.test(out) ? "" : "\n") + cleanStackTraceWarnings) : stack;}};});});
//# sourceMappingURL=Stack.js.map
