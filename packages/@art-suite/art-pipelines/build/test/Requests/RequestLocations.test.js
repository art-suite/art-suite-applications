"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "test", "Pipeline", "PipelineRegistry", "assert", "Promise", "Filter", "JSON", "isFailure"], [global, require('../StandardImport')], (describe, test, Pipeline, PipelineRegistry, assert, Promise, Filter, JSON, isFailure) => {require('art-config').configure(); return describe({trueDefault: function() {return test("in tests, server is the default", () => {let myPipeline, MyPipeline; ({myPipeline} = MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.registry(new PipelineRegistry); this.publicHandler({get: function(request) {return `${Caf.toString(request.location)}-handler`;}});})); return myPipeline.get("bar").then((data) => assert.eq(data, "server-handler"));});}, defaultLocation_client: function() {let myPipeline, MyPipeline; ({myPipeline} = MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.registry(new PipelineRegistry({defaultLocation: "client"})); this.filter({name: "server-filter", location: "server", after: {get: function({data}) {return `${Caf.toString(data)}/server-filter`;}}}); this.filter({name: "client-filter", location: "client", after: {get: function({data}) {return `${Caf.toString(data)}/client-filter`;}}}); this.publicHandler({get: function(request) {return `${Caf.toString(request.location)}-handler`;}});})); test("client (default)", () => myPipeline.get("bar").then((data) => assert.eq(data, "client-handler/client-filter"))); return test("server (override)", () => myPipeline.get("bar", {location: "server"}).then((data) => assert.eq(data, "server-handler/server-filter")));}, clientAndServerHandlers: function() {test("we can fake a client-side-only handler using a client-side only before-filter", () => {let myPipeline, MyPipeline; ({myPipeline} = MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.registry(new PipelineRegistry({defaultLocation: "client"})); this.filter({name: "client-filter-handler", location: "client", before: {get: function({data}) {return `${Caf.toString(data)}client-filter-handler`;}}}); this.filter({name: "server-filter", location: "server", after: {get: function({data}) {return `${Caf.toString(data)}/server-filter`;}}}); this.filter({name: "client-filter", location: "client", after: {get: function({data}) {return `${Caf.toString(data)}/client-filter`;}}}); this.publicHandler({get: function(request) {return `${Caf.toString(request.location)}-handler`;}});})); return Promise.all([myPipeline.get("bar").then((data) => assert.eq(data, "client-filter-handler/client-filter")), myPipeline.get("bar", {location: "server"}).then((data) => assert.eq(data, "server-handler/server-filter"))]);}); return test("now, what if the client-side handler fires off a server-side request - faking like it's a remote request?", () => {let BothMode, myPipeline, MyPipeline; BothMode = Caf.defClass(class BothMode extends Filter {}, function(BothMode, classSuper, instanceSuper) {this.location("client"); this.group("handler"); this.before({all: function(request) {return request.pipeline.get(request.key, {location: "server", props: JSON.parse(JSON.stringify(request.props)), returnResponse: true, remoteRequest: request, filterLog: request.filterLog}).then((remoteResponse) => request.toResponse(isFailure(remoteResponse.status) ? "serverFailure" : remoteResponse.status, {remoteResponse, remoteRequest: remoteResponse.remoteRequest, filterLog: remoteResponse.filterLog, props: JSON.parse(JSON.stringify(remoteResponse.props))}));}});}); ({myPipeline} = MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.registry(new PipelineRegistry({defaultLocation: "client"})); this.filter({name: "server-filter", location: "server", after: {get: function({data}) {return `${Caf.toString(data)}/server-filter`;}}}); this.filter({name: "client-filter", location: "client", after: {get: function({data}) {return `${Caf.toString(data)}/client-filter`;}}}); this.filter(BothMode); this.publicHandler({get: function(request) {return `${Caf.toString(request.data)}/${Caf.toString(request.location)}-handler`;}});})); return Promise.all([myPipeline.get("bar", {data: "requestData"}).then((data) => assert.eq(data, "requestData/server-handler/server-filter/client-filter")), myPipeline.get("bar", {data: "requestData", location: "server"}).then((data) => assert.eq(data, "requestData/server-handler/server-filter"))]);});}});});});
//# sourceMappingURL=RequestLocations.test.js.map
