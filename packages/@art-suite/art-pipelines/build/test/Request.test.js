"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["getEnv", "describe", "Request", "merge", "Pipeline", "success", "test", "assert", "Promise", "JSON", "randomString", "failure", "missing", "clientFailure", "clientFailureNotAuthorized", "serverFailure"], [global, require('./StandardImport'), require('./PipelineWithRegistryAtClient')], (getEnv, describe, Request, merge, Pipeline, success, test, assert, Promise, JSON, randomString, failure, missing, clientFailure, clientFailureNotAuthorized, serverFailure) => {let newRequest, newResponse; newRequest = function(options) {return new Request(merge({type: "get", pipeline: new Pipeline, session: {}}, options));}; newResponse = function(responseOptions, requestOptions) {return new Request(merge({status: Caf.exists(responseOptions) && responseOptions.status || success, request: newRequest(requestOptions)}, responseOptions));}; require('art-config').configure(); getEnv().ART_PIPELINES_ATTACH_RESPONSE_TO_ERRORS = true; return describe({common: {requireHelpers: {rejectIfErrors: function() {test("not clientFailure", () => newRequest().rejectIfErrors(null)); test("clientFailure with string", () => assert.clientFailure(newRequest().rejectIfErrors("my error"))); test("clientFailure with []", () => assert.clientFailure(newRequest().rejectIfErrors([]))); return test("clientFailure with [string]", () => assert.clientFailure(newRequest().rejectIfErrors(["my error"])));}, resolveRequireTestValue: function() {let resolveRequireTestValue; resolveRequireTestValue = Request._resolveRequireTestValue; test("resolveRequireTestValue true", () => resolveRequireTestValue(true).then((v) => assert.true(v))); test("resolveRequireTestValue false", () => resolveRequireTestValue(false).then((v) => assert.false(v))); test("resolveRequireTestValue -> true", () => resolveRequireTestValue(() => true).then((v) => assert.true(v))); test("resolveRequireTestValue -> false", () => resolveRequireTestValue(() => false).then((v) => assert.false(v))); test("resolveRequireTestValue -> Promise.resolve true", () => resolveRequireTestValue(() => Promise.resolve(true)).then((v) => assert.true(v))); test("resolveRequireTestValue -> Promise.resolve false", () => resolveRequireTestValue(() => Promise.resolve(false)).then((v) => assert.false(v))); test("resolveRequireTestValue Promise.resolve true", () => resolveRequireTestValue(Promise.resolve(true)).then((v) => assert.true(v))); return test("resolveRequireTestValue Promise.resolve false", () => resolveRequireTestValue(Promise.resolve(false)).then((v) => assert.false(v)));}, requires: {require: function() {test("true - resolved", () => newRequest().require(true)); test("Promise.resolve(true) - resolved", () => newRequest().require(Promise.resolve(true))); return test("clientFailure", () => assert.clientFailure(newRequest().require(false)));}, rejectIf: function() {test("false - resolved", () => newRequest().rejectIf(false)); test("Promise.resolve(false) - resolved", () => newRequest().rejectIf(Promise.resolve(false))); return test("clientFailure", () => assert.clientFailure(newRequest().rejectIf(true)));}, requiredFields: function() {test("a: true, b: false >>> resolved", () => newRequest().requiredFields({a: true, b: false}).then((out) => assert.eq(out, {a: true, b: false}))); return test("a: null, b: false >>> clientFailure", () => assert.clientFailure(newRequest().requiredFields({alpha: null, beta: false})).then((rejectsWith) => assert.match(rejectsWith.info.response.data.message, /missing.*alpha/)));}}, requireServerOrigins: {requireServerOrigin: function() {test("originatedOnServer: true >>> resolved", () => newRequest({originatedOnServer: true}).requireServerOrigin()); return test("originatedOnServer: false >>> clientFailureNotAuthorized", () => assert.clientFailureNotAuthorized(newRequest().requireServerOrigin()));}, requireServerOriginIf: function() {test("true,   originatedOnServer: true >>> resolved", () => newRequest({originatedOnServer: true}).requireServerOriginIf(true)); test("false,  originatedOnServer: true >>> resolved", () => newRequest({originatedOnServer: true}).requireServerOriginIf(false)); test("true,   originatedOnServer: false >>> clientFailureNotAuthorized", () => assert.clientFailureNotAuthorized(newRequest().requireServerOriginIf(true))); test("false,  originatedOnServer: false >>> resolved", () => newRequest().requireServerOriginIf(false)); test("Promise.resolve(true ),  originatedOnServer: true >>> resolved", () => newRequest({originatedOnServer: true}).requireServerOriginIf(Promise.resolve(true))); test("Promise.resolve(false),  originatedOnServer: true >>> resolved", () => newRequest({originatedOnServer: true}).requireServerOriginIf(Promise.resolve(false))); test("Promise.resolve(true ),  originatedOnServer: false >>> clientFailureNotAuthorized", () => assert.clientFailureNotAuthorized(newRequest().requireServerOriginIf(Promise.resolve(true)))); test("Promise.resolve(false),  originatedOnServer: false >>> resolved", () => newRequest().requireServerOriginIf(Promise.resolve(false))); return test("-> not invoked, originatedOnServer: true >>> resolved", () => {let wasInvoked; wasInvoked = false; return newRequest({originatedOnServer: true}).requireServerOriginIf(() => wasInvoked = true).then(() => assert.false(wasInvoked));});}, requireServerOriginOr: function() {test("true,   originatedOnServer: true >>> resolved", () => newRequest({originatedOnServer: true}).requireServerOriginOr(true)); test("false,  originatedOnServer: true >>> resolved", () => newRequest({originatedOnServer: true}).requireServerOriginOr(false)); test("true,   originatedOnServer: false >>> resolved", () => newRequest().requireServerOriginOr(true)); test("false,  originatedOnServer: false >>> clientFailureNotAuthorized", () => assert.clientFailureNotAuthorized(newRequest().requireServerOriginOr(false))); test("Promise.resolve(true ),  originatedOnServer: true >>> resolved", () => newRequest({originatedOnServer: true}).requireServerOriginIf(Promise.resolve(true))); test("Promise.resolve(false),  originatedOnServer: true >>> resolved", () => newRequest({originatedOnServer: true}).requireServerOriginIf(Promise.resolve(false))); test("Promise.resolve(true ),  originatedOnServer: false >>> clientFailureNotAuthorized", () => assert.clientFailureNotAuthorized(newRequest().requireServerOriginIf(Promise.resolve(true)))); test("Promise.resolve(false),  originatedOnServer: false >>> resolved", () => newRequest().requireServerOriginIf(Promise.resolve(false))); return test("-> not invoked, originatedOnServer: true >>> resolved", () => {let wasInvoked; wasInvoked = false; return newRequest({originatedOnServer: true}).requireServerOriginOr(() => wasInvoked = true).then(() => assert.false(wasInvoked));});}}}}, requests: {props: function() {test("new Request key and data set via props:", () => {let props; return assert.selectedPropsEq({key: "123", data: "abc", props: props = {key: "123", data: "abc"}}, new Request({type: "get", props: {key: "123", data: "abc"}, session: {}, pipeline: new Pipeline}));}); test("new Request props: myProp: 987", () => assert.selectedPropsEq({key: undefined, data: undefined, props: {myProp: 987}}, new Request({type: "get", props: {myProp: 987}, session: {}, pipeline: new Pipeline}))); test("new Request key: and data: are merged into props:", () => {let props; return assert.selectedPropsEq({key: "123", data: "abc", props: props = {key: "123", data: "abc", customProp: "xyz"}, _key: undefined, _data: undefined, _props: props}, new Request({type: "get", key: "123", data: "abc", props: {customProp: "xyz"}, session: {}, pipeline: new Pipeline}));}); return test("remoteRequest prop", () => {let r, remoteRequest; r = new Request({type: "get", pipeline: new Pipeline, session: {}, remoteRequest: remoteRequest = "myRemoteRequest"}); assert.eq(r.remoteRequest, remoteRequest); return r.withData("foo").then((r2) => {assert.neq(r, r2); assert.eq(r2.data, "foo"); return assert.eq(r2.remoteRequest, remoteRequest);});});}, validation: {"valid new Request": function() {test("type: 'get'", () => new Request({type: "get", key: "123", pipeline: new Pipeline, session: {}})); test("type: 'create'", () => new Request({type: "create", pipeline: new Pipeline, session: {}})); test("type: 'update'", () => new Request({type: "update", key: "123", pipeline: new Pipeline, session: {}})); return test("type: 'delete'", () => new Request({type: "delete", key: "123", pipeline: new Pipeline, session: {}}));}, "invalid new Request": function() {test("missing everything", () => assert.throws(() => new Request)); test("missing session", () => assert.throws(() => new Request({type: "get", key: "123", pipeline: new Pipeline}))); test("key: {}", () => assert.throws(() => new Request({session: {}, type: "get", key: {}, pipeline: new Pipeline}))); return test("props: key: {}", () => assert.throws(() => new Request({session: {}, type: "get", props: {key: {}}, pipeline: new Pipeline})));}}, properties: function() {test("getKey", () => {let request; request = new Request({type: "get", pipeline: new Pipeline, session: {}, props: {key: "123"}}); return assert.eq(request.getKey(), "123");}); return test("getRequestType alias for getType", () => {let request; request = new Request({type: "get", pipeline: new Pipeline, session: {}}); assert.eq(request.getRequestType(), "get"); return assert.eq(request.getType(), "get");});}, withData: function() {test("withData", () => {let request; request = new Request({type: "create", pipeline: new Pipeline, session: {}, data: {}}); return request.withData({foo: "bar"}).then((newRequest) => {assert.neq(newRequest, request); return assert.eq(newRequest.data, {foo: "bar"});});}); return test("withMergedData", () => {let request; request = new Request({type: "create", pipeline: new Pipeline, session: {}, data: {bing: "bong"}}); return request.withMergedData({foo: "bar"}).then((newRequest) => {assert.neq(newRequest, request); return assert.eq(newRequest.data, {bing: "bong", foo: "bar"});});});}, derivedRequestsPersistProps: function() {return test("originatedOnServer", () => {let request; request = new Request({type: "get", key: "123", originatedOnServer: true, pipeline: new Pipeline, session: {}}); return request.withData({}).then((derivedRequest) => assert.selectedPropsEq({originatedOnServer: true, type: "get", key: "123", pipeline: request.pipeline}, derivedRequest));});}, context: {"is identical after": function() {test("request cloning", () => {let request, context; request = newRequest(); ({context} = request); return request.withMergedData({user: "alice"}).then((request) => assert.same(context, request.context));}); test("response generation", () => {let request, context; request = newRequest(); ({context} = request); return request.success().then((response) => assert.same(context, response.context));}); return test("subrequests-form-A", () => {let MyPipeline, request, context, subrequest; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}); request = newRequest(); ({context} = request); subrequest = request.createSubRequest("myPipeline", "get"); return assert.same(context, subrequest.context);});}}, "key and data alias priorities": function() {test("key: foo has priority over props: key: bar", () => {assert.eq("aliasKey", newRequest({key: "aliasKey"}).key); assert.eq("propsKey", newRequest({props: {key: "propsKey"}}).key); return assert.eq("aliasKey", newRequest({key: "aliasKey", props: {key: "propsKey"}}).key);}); return test("data: foo: 123 has priority over props: data: foo: 456", () => {let aliasData, propsData; aliasData = {aliasData: 123}; propsData = {propsData: 123}; assert.eq(aliasData, newRequest({data: aliasData}).data); assert.eq(propsData, newRequest({props: {data: propsData}}).data); return assert.eq(aliasData, newRequest({data: aliasData, props: {data: propsData}}).data);});}, withProps: {withoutAliases: function() {test("withProps", () => {let request; request = newRequest({props: {foo: 1}}); return request.withProps({bar: 2}).then((newRequest) => {assert.neq(newRequest, request); return assert.eq(newRequest.props, {bar: 2});});}); return test("withMergedProps", () => {let request; request = newRequest({props: {foo: 1}}); return request.withMergedProps({bar: 2}).then((newRequest) => {assert.neq(newRequest, request); return assert.eq(newRequest.props, {foo: 1, bar: 2});});});}, withAliases: function() {test("withProps replaces aliases even if not explicitly set", () => {let request; request = newRequest({key: "myKey", data: {myField: 1}, props: {foo: 1}}); return request.withProps({bar: 2}).then((newRequest) => {assert.neq(newRequest, request); assert.eq(newRequest.key, undefined); assert.eq(newRequest.data, undefined); return assert.eq(newRequest.props, {bar: 2});});}); test("withProps replace aliases", () => {let request; request = newRequest({key: "myKey", data: {myField: 1}, props: {foo: 1}}); return request.withProps({bar: 2, key: "myKey2", data: {myField2: 2}}).then((newRequest) => {assert.neq(newRequest, request); assert.eq(newRequest.key, "myKey2"); assert.eq(newRequest.data, {myField2: 2}); return assert.eq(newRequest.props, {bar: 2, key: "myKey2", data: {myField2: 2}});});}); test("withMergedProps does not replace aliases even if not explicitly set", () => {let request; request = newRequest({key: "myKey", data: {myField: 1}, props: {foo: 1}}); return request.withMergedProps({bar: 2}).then((newRequest) => {assert.neq(newRequest, request); assert.eq(newRequest.key, request.key); assert.eq(newRequest.data, request.data); return assert.eq(newRequest.props, {foo: 1, bar: 2, key: "myKey", data: {myField: 1}});});}); return test("withMergedProps replace aliases", () => {let request; request = newRequest({key: "myKey", data: {myField: 1}, props: {foo: 1}}); return request.withMergedProps({bar: 2, key: "myKey2", data: {myField2: 2}}).then((newRequest) => {assert.neq(newRequest, request); assert.eq(newRequest.key, "myKey2"); assert.eq(newRequest.data, {myField2: 2}); return assert.eq(newRequest.props, {foo: 1, bar: 2, key: "myKey2", data: {myField2: 2}});});});}}, requestTrace: function() {test("requestTrace depth 1", () => {let MyRt; return (MyRt = Caf.defClass(class MyRt extends Pipeline {}, function(MyRt, classSuper, instanceSuper) {this.publicHandler({myHandler: function(request) {return request.requestTrace;}});})).myRt.myHandler({location: "server"}).then((requestTrace) => {assert.isArray(requestTrace); assert.eq(requestTrace.length, 1); return assert.eq(requestTrace[0].requestString, "myRt.myHandler");});}); test("requestTrace client > continueAtServerLocation > server == 2", () => {let MyRt; return (MyRt = Caf.defClass(class MyRt extends Pipeline {}, function(MyRt, classSuper, instanceSuper) {this.publicHandler({myHandler: function(request) {return request.requestTrace;}});})).myRt.myHandler().then((requestTrace) => {assert.isArray(requestTrace); assert.eq(requestTrace.length, 2); return assert.match(JSON.stringify(requestTrace[0]), "myRt.myHandler");});}); return test("requestTrace depth 2", () => {let MyRt2; return (MyRt2 = Caf.defClass(class MyRt2 extends Pipeline {}, function(MyRt2, classSuper, instanceSuper) {this.publicHandlers({outterRequest: function(request) {return request.pipeline.innerRequest(request);}, innerRequest: function(request) {return request.requestTrace;}});})).myRt2.outterRequest({key: randomString()});});}}, responses: {"new Request validation": {invalid: function() {test("without request or status ", () => assert.throws(() => new Request({}))); test("without status", () => assert.throws(() => new Request({request: newRequest()}))); test("without request", () => assert.throws(() => new Request({status: success}))); test("props is not an object", () => assert.throws(() => new Request({props: 123, status: success, request: newRequest()}))); test("invalid status", () => assert.throws(() => new Request({status: "dode", request: newRequest()}))); return test("invalid session", () => assert.throws(() => newResponse({session: 123})));}, valid: function() {test("status: success", () => new Request({status: success, request: newRequest()})); test("status: failure", () => new Request({status: failure, request: newRequest()})); return test("status: missing", () => new Request({status: missing, request: newRequest()}));}}, getters: function() {test("request", () => assert.instanceof(Request, newResponse().request)); test("requestData", () => {let r; r = newResponse({props: {foo: 1, data: {bar: 2}}}); return assert.equal(r.request.data, r.requestData);}); test("requestProps", () => {let r; r = newResponse({props: {foo: 1, data: {bar: 2}}}); return assert.equal(r.request.props, r.requestProps);}); test("responseProps", () => {let r; r = newResponse({props: {foo: 1, data: {bar: 2}}}); assert.equal(r.props, r.responseProps); return assert.neq(r.props, r.requestProps);}); test("responseData", () => {let r; r = newResponse({props: {foo: 1, data: {bar: 2}}}); assert.equal(r.data, r.responseData); return assert.neq(r.data, r.requestData);}); test("parentRequest", () => assert.eq(undefined, newResponse().parentRequest)); return test("rootRequest", () => {let response; response = newResponse(); return assert.eq(response.request, response.rootRequest);});}, props: function() {test("props defaults to {}", () => assert.selectedPropsEq({props: {}}, new Request({status: success, request: newRequest()}))); test("props: myProp: 123", () => assert.selectedPropsEq({props: {myProp: 123}}, new Request({status: success, props: {myProp: 123}, request: newRequest()}))); test("data: 123 sets props", () => assert.selectedPropsEq({props: {data: 123}, _data: undefined, data: 123}, new Request({status: success, data: 123, request: newRequest()}))); return test("data: 123, props: data: 456 - data-outside-props-has-priority", () => assert.selectedPropsEq({props: {data: 123}}, new Request({status: success, data: 123, props: {data: 456}, request: newRequest()})));}, plainObjectsResponse: function() {test("basic", () => assert.selectedEq({status: "success"}, newResponse().plainObjectsResponse)); test("data: 123", () => assert.selectedEq({status: "success", props: {data: 123}}, newResponse({data: 123}).plainObjectsResponse)); test("session: 123", () => assert.selectedEq({status: "success", session: {userId: "abc123"}}, newResponse({session: {userId: "abc123"}}).plainObjectsResponse)); return test("props: foo: 123", () => assert.selectedEq({status: "success", props: {foo: 123}}, newResponse({props: {foo: 123}}).plainObjectsResponse));}, withTransformedRecords: {oneRecord: function() {test("success", () => newResponse({data: {foo: "bar", id: "xyz"}}).withTransformedRecords((record) => merge(record, {baz: "bam"})).then((response) => {assert.eq(response.status, success); return assert.eq(response.data, {foo: "bar", baz: "bam", id: "xyz"});})); test("using when and with: only transforms if id is present API1", () => newResponse({data: {foo: "bar"}}).withTransformedRecords({with: (record) => merge(record, {baz: "bam"})}).then((response) => {assert.eq(response.status, success); return assert.eq(response.data, {foo: "bar"});})); test("using when and with: only transforms if id is present API2", () => newResponse({data: {foo: "bar"}}).withTransformedRecords({with: (record) => merge(record, {baz: "bam"}), when: ({id}) => id != null}).then((response) => {assert.eq(response.status, success); return assert.eq(response.data, {foo: "bar"});})); test("using when and with: only transforms if id is present API3", () => newResponse({data: {foo: "bar"}}).withTransformedRecords((record) => merge(record, {baz: "bam"}), (record) => (Caf.exists(record) && record.id) != null).then((response) => {assert.eq(response.status, success); return assert.eq(response.data, {foo: "bar"});})); test("null", () => newResponse({data: {foo: "bar", id: "xyz"}}).withTransformedRecords((record) => null).then((response) => assert.eq(response.status, missing))); test("clientFailure", () => newResponse({data: {foo: "bar", id: "xyz"}}).withTransformedRecords((record, response) => response.clientFailure()).then((response) => assert.eq(response.status, clientFailure))); return test("clientFailureNotAuthorized", () => newResponse({data: {foo: "bar", id: "xyz"}}).withTransformedRecords((record, response) => response.clientFailureNotAuthorized()).then((response) => assert.eq(response.status, clientFailureNotAuthorized)));}, manyRecords: function() {test("success", () => newResponse({data: [{id: 123, name: "shane"}, {id: 456, name: "george"}]}).withTransformedRecords((record) => merge(record, {baz: "bam"})).then((response) => {assert.eq(response.status, success); return assert.eq(response.data, [{id: 123, name: "shane", baz: "bam"}, {id: 456, name: "george", baz: "bam"}]);})); test("null", () => newResponse({data: [{id: 123, name: "shane"}, {id: 456, name: "george"}, {id: 789, name: "bob"}]}).withTransformedRecords((record) => (record.name !== "george") ? record : undefined).then((response) => {assert.eq(response.status, success); return assert.eq(response.data, [{id: 123, name: "shane"}, {id: 789, name: "bob"}]);})); test("clientFailure", () => newResponse({data: [{id: 123, name: "shane"}, {id: 456, name: "george"}, {id: 789, name: "bob"}]}).withTransformedRecords((record, response) => (record.name !== "george") ? record : newResponse({status: clientFailure})).then((response) => {assert.eq(response.status, success); return assert.eq(response.data, [{id: 123, name: "shane"}, {id: 789, name: "bob"}]);})); test("clientFailureNotAuthorized", () => newResponse({data: [{id: 123, name: "shane"}, {id: 456, name: "george"}, {id: 789, name: "bob"}]}).withTransformedRecords((record, response) => (record.name !== "george") ? record : newResponse({status: clientFailureNotAuthorized})).then((response) => {assert.eq(response.status, success); return assert.eq(response.data, [{id: 123, name: "shane"}, {id: 789, name: "bob"}]);})); return test("serverFailure", () => newResponse({data: [{id: 123, name: "shane"}, {id: 456, name: "george"}, {id: 789, name: "bob"}]}).withTransformedRecords((record, response) => (record.name !== "george") ? record : newResponse({status: serverFailure})).then((response) => assert.eq(response.status, serverFailure)));}, nonRecords: function() {return test("success", () => newResponse({data: null}).withTransformedRecords((record) => merge(record, {baz: "bam"})).then((response) => {assert.eq(response.status, success); return assert.ok(!(response.data != null));}));}}}, stringify: function() {return test("json", () => {let request; request = newRequest({props: {foo: 1}}); assert.eq(JSON.stringify(request), JSON.stringify(request.inspectedObjects)); return assert.eq(JSON.stringify(request.pipeline), JSON.stringify(request.pipeline.inspectedObjects));});}});});});
//# sourceMappingURL=Request.test.js.map
