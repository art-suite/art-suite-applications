"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "test", "Pipeline", "assert", "Error"], [global, require('../StandardImport')], (describe, test, Pipeline, assert, Error) => {require('art-config').configure(); return describe({afterFilterFailures: function() {test("internal error", () => {let filterLog, MyPipeline, p; filterLog = []; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.publicHandlers({create: function(request) {return {foo: 1, bar: 2};}}); this.filter({name: "myFilter1", after: {create: function(response) {filterLog.push("myFilter1"); return response;}}}); this.filter({name: "myFilter2", after: {create: function(response) {filterLog.push("myFilter2"); return (() => {throw new Error("internal oops");})();}}}); this.filter({name: "myFilter3", after: {create: function(response) {filterLog.push("myFilter3"); return response;}}});}); p = new MyPipeline; return assert.rejects(p.create()).then((error) => {let response; ({response} = error.props); assert.present(response.errorProps.failedIn, "failedIn"); assert.eq(filterLog, ["myFilter1", "myFilter2"]); assert.match(error.message, "internal oops"); return assert.eq(response.errorProps.source.this.name, "myFilter2");});}); return test("clientFailure", () => {let MyPipeline, p; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.publicHandlers({create: function(request) {return {foo: 1, bar: 2};}}); this.filter({name: "myFilter1", after: {create: function(response) {return response;}}}); this.filter({name: "myFilter2", after: {create: function(response) {return response.clientFailure("you lose!");}}}); this.filter({name: "myFilter3", after: {create: function(response) {return response;}}});}); p = new MyPipeline; return assert.rejects(p.create()).then((error) => {let response; ({response} = error.props); assert.present(response.errorProps.failedIn); assert.eq(["created", "create-handler"], Caf.array(response.beforeFilterLog, ({name}) => name)); assert.eq(["myFilter1", "myFilter2"], Caf.array(response.afterFilterLog, ({name}) => name)); assert.match(response.data.message, "you lose!"); return assert.doesNotExist(error.props.response.errorProps.source);});});}, beforeFilterFailures: function() {test("clientFailure", () => {let MyPipeline, p; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.publicHandlers({create: function(request) {return {foo: 1, bar: 2};}}); this.filter({name: "myFilter1", before: {create: function(response) {return response;}}}); this.filter({name: "myFilter2", before: {create: function(response) {return response.clientFailure("you lose!");}}}); this.filter({name: "myFilter3", before: {create: function(response) {return response;}}});}); p = new MyPipeline; return assert.rejects(p.create()).then((error) => {let response; ({response} = error.props); assert.present(response.errorProps.failedIn); assert.eq(["created", "myFilter3", "myFilter2"], Caf.array(response.beforeFilterLog, ({name}) => name)); assert.eq(response.afterFilterLog, []); assert.eq(response.handledBy.name, "myFilter2"); return assert.eq(response.data.message, "you lose!");});}); return test("internal error", () => {let filterLog, MyPipeline, p; filterLog = []; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.publicHandlers({create: function(request) {return {foo: 1, bar: 2};}}); this.filter({name: "myFilter1", before: {create: function(response) {filterLog.push("myFilter1"); return response;}}}); this.filter({name: "myFilter2", before: {create: function(response) {filterLog.push("myFilter2"); return (() => {throw new Error("internal oops");})();}}}); this.filter({name: "myFilter3", before: {create: function(response) {filterLog.push("myFilter3"); return response;}}});}); p = new MyPipeline; return assert.rejects(p.create()).then((error) => {let response; ({response} = error.props); assert.present(response.errorProps.failedIn); assert.eq(filterLog, ["myFilter3", "myFilter2"]); assert.match(error.message, "internal oops"); return assert.eq(response.errorProps.source.this.name, "myFilter2");});});}, handlerFailures: function() {return test("internal error", () => {let filterLog, MyPipeline, p; filterLog = []; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.publicHandlers({create: function(request) {return (() => {throw new Error("internal oops");})();}}); this.filter({name: "myFilter1", before: {create: function(response) {filterLog.push("myFilter1"); return response;}}}); this.filter({name: "myFilter2", after: {create: function(response) {filterLog.push("myFilter2"); return response;}}});}); p = new MyPipeline; return assert.rejects(p.create()).then((error) => {let response; ({response} = error.props); assert.present(response.errorProps.failedIn); assert.eq(filterLog, ["myFilter1"]); assert.match(error.message, "internal oops"); return assert.eq(error.props.response.errorProps.source.this.name, "myPipeline");});});}});});});
//# sourceMappingURL=PipelineFailures.test.js.map
