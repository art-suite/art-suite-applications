"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["test", "Pipeline", "assert", "pipelines", "Object", "PipelineRegistry"], [global, require('../StandardImport'), require('../PipelineWithRegistry')], (test, Pipeline, assert, pipelines, Object, PipelineRegistry) => {test("aliases don't currently add actual alises in pipelines", function() {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.pipelineRegistry(new PipelineRegistry); this.aliases("MyPipelineAlias");}); assert.eq(pipelines.myPipelineAlias, undefined); assert.eq(MyPipeline.getAliases(), {myPipelineAlias: true}); return assert.eq(Object.keys(MyPipeline.getRegistry().pipelines).sort(), ["myPipeline", "myPipelineAlias"]);}); test("second aliases call replaces first", function() {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.pipelineRegistry(new PipelineRegistry); this.aliases("MyPipelineAlias"); this.aliases("FooLand");}); assert.eq(MyPipeline.getAliases(), {fooLand: true}); assert.eq(MyPipeline.myPipeline.aliases, ["fooLand"]); return assert.eq(Object.keys(MyPipeline.getRegistry().pipelines).sort(), ["fooLand", "myPipeline"]);}); test("aliases are not inherited", function() {let registry, MyPipeline, MySubPipeline; registry = new PipelineRegistry; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.pipelineRegistry(registry); this.aliases("MyPipelineAlias");}); MySubPipeline = Caf.defClass(class MySubPipeline extends MyPipeline {}, function(MySubPipeline, classSuper, instanceSuper) {this.pipelineRegistry(registry); this.aliases("MySubPipelineAlias");}); assert.eq(MyPipeline.getAliases(), {myPipelineAlias: true}); assert.eq(MySubPipeline.getAliases(), {mySubPipelineAlias: true}); return assert.eq(Object.keys(registry.pipelines).sort(), ["myPipeline", "myPipelineAlias", "mySubPipeline", "mySubPipelineAlias"]);}); return test("two pipelines with different aliases are distinct", function() {let registry, MyPipeline, MyOtherPipeline; registry = new PipelineRegistry; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.pipelineRegistry(registry); this.aliases("MyPipelineAlias");}); MyOtherPipeline = Caf.defClass(class MyOtherPipeline extends Pipeline {}, function(MyOtherPipeline, classSuper, instanceSuper) {this.pipelineRegistry(registry); this.aliases("MyOtherPipelineAlias");}); assert.eq(MyPipeline.getAliases(), {myPipelineAlias: true}); assert.eq(MyOtherPipeline.getAliases(), {myOtherPipelineAlias: true}); return assert.eq(Object.keys(registry.pipelines).sort(), ["myOtherPipeline", "myOtherPipelineAlias", "myPipeline", "myPipelineAlias"]);});});});
//# sourceMappingURL=PipelineAliases.test.js.map
