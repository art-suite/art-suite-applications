"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Pipeline", "PipelineRegistry", "describe", "test", "assert", "Error", "simplifyFilterLog", "log"], [global, require('../StandardImport')], (Pipeline, PipelineRegistry, describe, test, assert, Error, simplifyFilterLog, log) => {Pipeline.registry(new PipelineRegistry({session: {}})); require('art-config').configure(); return describe({afterFilterFailures: function() {test("internal error", () => {let filterLog, MyPipeline, p; filterLog = []; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.publicHandlers({create: function(request) {return {foo: 1, bar: 2};}}); this.filter({name: "myFilter1", after: {create: function(response) {filterLog.push("myFilter1"); return response;}}}); this.filter({name: "myFilter2", after: {create: function(response) {filterLog.push("myFilter2"); return (() => {throw new Error("internal oops");})();}}}); this.filter({name: "myFilter3", after: {create: function(response) {filterLog.push("myFilter3"); return response;}}});}); p = new MyPipeline; return assert.rejects(p.create()).then((error) => {let response; ({response} = error.props); assert.present(response.errorProps.failedIn, "failedIn"); assert.eq(filterLog, ["myFilter1", "myFilter2"]); assert.match(error.message, "internal oops"); return assert.eq(response.errorProps.source.this.name, "myFilter2");});}); return test("clientFailure", () => {let MyPipeline, p; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.publicHandlers({create: function(request) {return {foo: 1, bar: 2};}}); this.filter({name: "myFilter1", after: {create: function(response) {return response;}}}); this.filter({name: "myFilter2", after: {create: function(response) {return response.clientFailure("you lose!");}}}); this.filter({name: "myFilter3", after: {create: function(response) {return response;}}});}); p = new MyPipeline; return assert.rejects(p.create()).then((error) => {let response; ({response} = error.props); assert.present(response.errorProps.failedIn); assert.eq(simplifyFilterLog(response.beforeFilterLog), ["server-pending-created", "server-success-myPipeline-handler"]); assert.eq(simplifyFilterLog(response.afterFilterLog), ["server-success-myFilter1-after", "server-clientFailure-myFilter2-after", "server-clientFailure-completed"]); assert.match(response.data.message, "you lose!"); return assert.doesNotExist(error.props.response.errorProps.source);});});}, beforeFilterFailures: function() {test("clientFailure", () => {let MyPipeline, p; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.publicHandlers({create: function(request) {return {foo: 1, bar: 2};}}); this.filter({name: "myFilter1", before: {create: function(response) {return response;}}}); this.filter({name: "myFilter2", before: {create: function(response) {return response.failure("you lose!");}}}); this.filter({name: "myFilter3", before: {create: function(response) {return response;}}});}); p = new MyPipeline; return assert.rejects(p.create()).then((error) => {let response; ({response} = error.props); assert.present(response.errorProps.failedIn); assert.eq(simplifyFilterLog(response.beforeFilterLog), ["server-pending-created", "server-pending-myFilter3-before", "server-serverFailure-myFilter2-before"]); assert.eq(simplifyFilterLog(response.afterFilterLog), ["server-serverFailure-completed"]); assert.doesNotExist(response.handledBy); assert.eq(response.failedIn.name, "myFilter2"); return assert.eq(response.data.message, "you lose!");});}); return test("internal error", () => {let filterLog, MyPipeline, p; filterLog = []; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.publicHandlers({create: function(request) {return {foo: 1, bar: 2};}}); this.filter({name: "myFilter1", before: {create: function(response) {filterLog.push("myFilter1"); return response;}}}); this.filter({name: "myFilter2", before: {create: function(response) {filterLog.push("myFilter2"); return (() => {throw new Error("internal oops");})();}}}); this.filter({name: "myFilter3", before: {create: function(response) {filterLog.push("myFilter3"); return response;}}});}); p = new MyPipeline; return assert.rejects(p.create()).then((error) => {let response; ({response} = error.props); assert.present(response.errorProps.failedIn); assert.eq(filterLog, ["myFilter3", "myFilter2"]); assert.match(error.message, "internal oops"); return assert.eq(response.errorProps.source.this.name, "myFilter2");});});}, handlerFailures: function() {return test("internal error", () => {let filterLog, MyPipeline, p; filterLog = []; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.publicHandlers({create: function(request) {return (() => {throw new Error("internal oops");})();}}); this.filter({name: "myFilter1", before: {create: function(response) {filterLog.push("myFilter1"); return response;}}}); this.filter({name: "myFilter2", after: {create: function(response) {filterLog.push("myFilter2"); return response;}}});}); p = new MyPipeline; return assert.rejects(p.create()).then((error) => {let response; if (!error.props) {log({WTF: error});}; ({response} = error.props); assert.present(response.errorProps.failedIn); assert.eq(filterLog, ["myFilter1"]); assert.match(error.message, "internal oops"); return assert.eq(error.props.response.errorProps.source.this.name, "myPipeline");});});}});});});
//# sourceMappingURL=PipelineFailures.test.js.map
