"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "test", "Pipeline", "assert", "Filter", "toInspectedObjects", "pipelines", "upperCamelCase", "merge", "Error", "Promise", "Object"], [global, require('./StandardImport')], (describe, test, Pipeline, assert, Filter, toInspectedObjects, pipelines, upperCamelCase, merge, Error, Promise, Object) => {require('art-config').configure(); return describe({definitionMethods: function() {test("plainObjectDefinition", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.filter({before: {helloWorld: function() {return "Hello world!";}}});}); assert.isArray(MyPipeline.getFilters()); assert.eq(MyPipeline.getFilters().length, 1); assert.instanceOf(MyPipeline.getFilters()[0], Filter); assert.eq(MyPipeline.getFilters(), MyPipeline.myPipeline.filters); return assert.eq(toInspectedObjects(MyPipeline.myPipeline.filters), [{filter: {name: "Filter", location: "server", group: 0, before: ["helloWorld"]}}]);}); test("class", () => {let MyFilter, MyPipeline; MyFilter = Caf.defClass(class MyFilter extends Filter {}, function(MyFilter, classSuper, instanceSuper) {this.before({helloWorld: function() {return "Hello world!";}});}); MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.filter(MyFilter);}); return assert.eq(toInspectedObjects(MyPipeline.myPipeline.filters), [{filter: {name: "MyFilter", location: "server", group: 0, before: ["helloWorld"]}}]);}); return test("instance", () => {let MyFilter, MyPipeline; MyFilter = Caf.defClass(class MyFilter extends Filter {}, function(MyFilter, classSuper, instanceSuper) {this.before({helloWorld: function() {return "Hello world!";}});}); MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.filter(new MyFilter);}); return assert.eq(toInspectedObjects(MyPipeline.myPipeline.filters), [{filter: {name: "MyFilter", location: "server", group: 0, before: ["helloWorld"]}}]);});}, basic: function() {test("before", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({helloWorld: function({data}) {return `Hello ${Caf.toString(data)}.`;}}); this.publicRequestTypes("helloWorld"); this.filter({before: {helloWorld: function(request) {return request.withData(upperCamelCase(request.data));}}});}); return pipelines.myPipeline.helloWorld({data: "frank"}).then((result) => assert.eq(result, "Hello Frank."));}); test("all", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({helloWorld: function({data}) {return `Hello ${Caf.toString(data)}.`;}}); this.publicRequestTypes("helloWorld"); this.filter({before: {all: function(request) {return request.withData(upperCamelCase(request.data));}}});}); return pipelines.myPipeline.helloWorld({data: "frank"}).then((result) => assert.eq(result, "Hello Frank."));}); return test("after", () => {let myPipeline, MyPipeline; ({myPipeline} = MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({helloWorld: function({data}) {return `Hello ${Caf.toString(data)}.`;}}); this.publicRequestTypes("helloWorld"); this.filter({after: {helloWorld: function(request) {return request.withData(request.data + " How are you?");}}});})); return pipelines.myPipeline.helloWorld({data: "frank"}).then((result) => assert.eq(result, "Hello frank. How are you?"));});}, order: {basic: function() {return test("two filters", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({helloWorld: function({data}) {return `Hello ${Caf.toString(data)}.`;}}); this.publicRequestTypes("helloWorld"); this.filter({before: {helloWorld: function(r) {return r.withData(r.data + "/a-before/");}}, after: {helloWorld: function(r) {return r.withData(r.data + "/a-after/");}}}); this.filter({before: {helloWorld: function(r) {return r.withData(r.data + "/b-before/");}}, after: {helloWorld: function(r) {return r.withData(r.data + "/b-after/");}}});}); return pipelines.myPipeline.helloWorld({data: "frank"}).then((result) => assert.eq(result, "Hello frank/b-before//a-before/./a-after//b-after/"));});}, groups: function() {test("grouped", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({myAction: function() {return "-";}}); this.publicRequestTypes("myAction"); this.filter({name: "filterA", group: "outer", after: {myAction: function(r) {return r.withData(`${Caf.toString(r.data)}A`);}}}); this.filter({name: "filterB", group: "inner", after: {myAction: function(r) {return r.withData(`${Caf.toString(r.data)}B`);}}}); this.filter({name: "filterC", group: "middle", after: {myAction: function(r) {return r.withData(`${Caf.toString(r.data)}C`);}}}); this.filter({name: "filterD", group: "loggers", after: {myAction: function(r) {return r.withData(`${Caf.toString(r.data)}D`);}}});}); return pipelines.myPipeline.myAction().then((result) => assert.eq(result, "-BCAD"));}); return test("ungrouped", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({myAction: function() {return "-";}}); this.publicRequestTypes("myAction"); this.filter({name: "filterA", after: {myAction: function(r) {return r.withData(`${Caf.toString(r.data)}A`);}}}); this.filter({name: "filterB", after: {myAction: function(r) {return r.withData(`${Caf.toString(r.data)}B`);}}}); this.filter({name: "filterC", after: {myAction: function(r) {return r.withData(`${Caf.toString(r.data)}C`);}}}); this.filter({name: "filterD", after: {myAction: function(r) {return r.withData(`${Caf.toString(r.data)}D`);}}});}); return pipelines.myPipeline.myAction().then((result) => assert.eq(result, "-ABCD"));});}}, query: function() {return test("query handlers with after-all filter", () => {let Post; Post = Caf.defClass(class Post extends Pipeline {}, function(Post, classSuper, instanceSuper) {this.query({byUserId: function(request) {return [request.key, 1, 2, 3];}}); this.publicRequestTypes("byUserId"); this.filter({after: {all: function(response) {return response.withData(Caf.array(response.data, (a) => `${Caf.toString(a)} ${Caf.toString(a)}`));}}});}); assert.eq(Post.post.clientApiMethodList, ["byUserId"]); return Post.post.byUserId({key: "foo"}).then((results) => assert.eq(results, ["foo foo", "1 1", "2 2", "3 3"]));});}, filterLogs: function() {return test("basic", () => {let MyPipeline, p; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({foo: function(request) {return merge(request.data, {myHandlerRan: true});}}); this.publicRequestTypes("foo"); this.filter({name: "MyBeforeFooFilter", before: {foo: function(request) {return request.withMergedData({myBeforeFooFilterRan: true});}}}); this.filter({name: "MyAfterFooFilter", after: {foo: function(response) {return response.withMergedData({myAfterFooFilterRan: true});}}});}); p = new MyPipeline; return p.foo({returnResponseObject: true}).then((response) => {assert.eq(["created", "MyBeforeFooFilter", "foo-handler"], Caf.array(response.beforeFilterLog, ({name}) => name)); assert.eq(["MyAfterFooFilter"], Caf.array(response.afterFilterLog, ({name}) => name)); return assert.eq(response.data, {myHandlerRan: true, myBeforeFooFilterRan: true, myAfterFooFilterRan: true});});});}, location: function() {test("before filters by location", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({foo: function(request) {return merge(request.data, {myHandlerRan: true});}}); this.publicRequestTypes("foo"); this.filter({location: "client", before: {foo: function(request) {return request;}}}); this.filter({location: "both", before: {foo: function(request) {return request;}}}); this.filter({location: "server", before: {foo: function(request) {return request;}}});}); assert.eq(["client", "both"], Caf.array(pipelines.myPipeline.getBeforeFilters({requestType: "foo", location: "client"}), (f) => f.location)); assert.eq(["server", "both"], Caf.array(pipelines.myPipeline.getBeforeFilters({requestType: "foo", location: "server"}), (f) => f.location)); return assert.eq(["client", "server", "both"], Caf.array(pipelines.myPipeline.getBeforeFilters({requestType: "foo", location: "both"}), (f) => f.location));}); return test("after filters by location", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({foo: function(request) {return merge(request.data, {myHandlerRan: true});}}); this.publicRequestTypes("foo"); this.filter({location: "client", after: {foo: function(request) {return request;}}}); this.filter({location: "both", after: {foo: function(request) {return request;}}}); this.filter({location: "server", after: {foo: function(request) {return request;}}});}); assert.eq(["both", "client"], Caf.array(pipelines.myPipeline.getAfterFilters({requestType: "foo", location: "client"}), (f) => f.location)); assert.eq(["both", "server"], Caf.array(pipelines.myPipeline.getAfterFilters({requestType: "foo", location: "server"}), (f) => f.location)); return assert.eq(["both", "server", "client"], Caf.array(pipelines.myPipeline.getAfterFilters({requestType: "foo", location: "both"}), (f) => f.location));});}, filterFailures: function() {return test("basic", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({foo: function(request) {return (() => {throw new Error("simulated error on foo request");})();}}); this.publicRequestTypes("foo"); this.filter({name: "FilterWithoutFilterFailures", after: {foo: function(response) {return response.success({data: "not me"});}}}); this.filter({name: "FilterWithFilterFailures", filterFailures: true, after: {foo: function(response) {return response.success({data: "me!"});}}});}); assert.eq(false, pipelines.myPipeline.filters[0].filterFailures); assert.eq(true, pipelines.myPipeline.filters[1].filterFailures); return pipelines.myPipeline.foo().then((result) => assert.eq(result, "me!"));});}, regressions: function() {return test("can share filter instances", () => {let MyFilter, instance, MyPipeline1, MyPipeline2; MyFilter = Caf.defClass(class MyFilter extends Filter {}, function(MyFilter, classSuper, instanceSuper) {this.after({foo: function(response) {return response.withMergedData({myFiltered: true});}});}); instance = new MyFilter; MyPipeline1 = Caf.defClass(class MyPipeline1 extends Pipeline {}, function(MyPipeline1, classSuper, instanceSuper) {this.publicRequestTypes("foo"); this.handlers({foo: function(request) {return {foo1ed: true};}}); this.filter(instance);}); MyPipeline2 = Caf.defClass(class MyPipeline2 extends Pipeline {}, function(MyPipeline2, classSuper, instanceSuper) {this.publicRequestTypes("foo"); this.handlers({foo: function(request) {return {foo2ed: true};}}); this.filter(instance);}); return Promise.all([pipelines.myPipeline1.foo(), pipelines.myPipeline2.foo()]).then(([foo1, foo2]) => {assert.eq(foo1, {foo1ed: true, myFiltered: true}); return assert.eq(foo2, {foo2ed: true, myFiltered: true});});});}, extendFields: function() {test("on subclass", () => {let MyFilter; MyFilter = Caf.defClass(class MyFilter extends Filter {}, function(MyFilter, classSuper, instanceSuper) {this.fields({foo: "string"});}); assert.eq(["foo"], Object.keys(MyFilter.getFields())); return assert.selectedEq({fieldType: "string", dataType: "string"}, MyFilter.getFields().foo);}); test("filter fields add to pipeline", () => {let MyFilter, MyPipeline; MyFilter = Caf.defClass(class MyFilter extends Filter {}, function(MyFilter, classSuper, instanceSuper) {this.fields({filterFoo: "string"});}); MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.fields({pipelineFoo: "string"}); this.filter(MyFilter);}); return assert.eq(["filterFoo", "pipelineFoo"], Object.keys(MyPipeline.getFields()).sort());}); test("on subclass and sub-subclass - with new field", () => {let MyFilter, MySubFilter; MyFilter = Caf.defClass(class MyFilter extends Filter {}, function(MyFilter, classSuper, instanceSuper) {this.fields({foo: "string"});}); MySubFilter = Caf.defClass(class MySubFilter extends MyFilter {}, function(MySubFilter, classSuper, instanceSuper) {this.fields({bar: "number"});}); assert.eq(["foo"], Object.keys(MyFilter.getFields())); assert.eq(["foo", "bar"], Object.keys(MySubFilter.getFields())); assert.selectedEq({fieldType: "string"}, MyFilter.getFields().foo); assert.selectedEq({fieldType: "string"}, MySubFilter.getFields().foo); return assert.selectedEq({fieldType: "number"}, MySubFilter.getFields().bar);}); test("on subclass and sub-subclass - with replaced field", () => {let MyFilter, MySubFilter; MyFilter = Caf.defClass(class MyFilter extends Filter {}, function(MyFilter, classSuper, instanceSuper) {this.fields({foo: "string"});}); MySubFilter = Caf.defClass(class MySubFilter extends MyFilter {}, function(MySubFilter, classSuper, instanceSuper) {this.fields({foo: "number"});}); assert.eq(["foo"], Object.keys(MyFilter.getFields())); assert.eq(["foo"], Object.keys(MySubFilter.getFields())); assert.selectedEq({fieldType: "string"}, MyFilter.getFields().foo); return assert.selectedEq({fieldType: "number"}, MySubFilter.getFields().foo);}); return test("on subclass and subclass-instance", () => {let MyFilter, myFilter; MyFilter = Caf.defClass(class MyFilter extends Filter {}, function(MyFilter, classSuper, instanceSuper) {this.fields({foo: "string"});}); myFilter = new MyFilter; myFilter.extendFields({bar: "number"}); assert.eq(["foo"], Object.keys(MyFilter.getFields())); return assert.eq(["foo", "bar"], Object.keys(myFilter.getFields()));});}, all: function() {let OrderTestFilter; OrderTestFilter = Caf.defClass(class OrderTestFilter extends Filter {constructor(str) {super(...arguments); this.str = str;};}, function(OrderTestFilter, classSuper, instanceSuper) {this.before({all: function(request) {let m; return request.withData({message: `${Caf.toString((m = request.data.message) ? `${Caf.toString(m)}\n` : "")}before-${Caf.toString(request.type)}(${Caf.toString(this.str)})`});}}); this.after({all: function(response) {let m; return response.withMergedData({message: `${Caf.toString((m = response.data.message) ? `${Caf.toString(m)}\n` : "")}after-${Caf.toString(response.request.type)}(${Caf.toString(this.str)})`});}});}); return test("before and after all", () => {let orderLog, MyPipeline; orderLog = []; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.filter(new OrderTestFilter("g")); this.filter(new OrderTestFilter("a")); this.filter(new OrderTestFilter("b")); this.publicHandlers({create: function({data: {message}}) {return {message: `${Caf.toString(message)}\ncreate-handler`};}});}); return MyPipeline.singleton.create({data: {}}).then((savedData) => assert.eq(savedData.message, "before-create(b)\nbefore-create(a)\nbefore-create(g)\ncreate-handler\nafter-create(g)\nafter-create(a)\nafter-create(b)"));});}});});});
//# sourceMappingURL=Filters.test.js.map
