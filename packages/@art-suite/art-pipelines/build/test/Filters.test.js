"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "test", "Pipeline", "pipelines", "upperCamelCase", "assert", "merge", "Error", "Filter", "Promise"], [global, require('./StandardImport')], (describe, test, Pipeline, pipelines, upperCamelCase, assert, merge, Error, Filter, Promise) => {require('art-config').configure(); return describe({basic: function() {test("before", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({helloWorld: function({data}) {return `Hello ${Caf.toString(data)}.`;}}); this.publicRequestTypes("helloWorld"); this.filter({before: {helloWorld: function(request) {return request.withData(upperCamelCase(request.data));}}});}); return pipelines.myPipeline.helloWorld({data: "frank"}).then((result) => assert.eq(result, "Hello Frank."));}); test("all", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({helloWorld: function({data}) {return `Hello ${Caf.toString(data)}.`;}}); this.publicRequestTypes("helloWorld"); this.filter({before: {all: function(request) {return request.withData(upperCamelCase(request.data));}}});}); return pipelines.myPipeline.helloWorld({data: "frank"}).then((result) => assert.eq(result, "Hello Frank."));}); return test("after", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({helloWorld: function({data}) {return `Hello ${Caf.toString(data)}.`;}}); this.publicRequestTypes("helloWorld"); this.filter({after: {helloWorld: function(request) {return request.withData(request.data + " How are you?");}}});}); return pipelines.myPipeline.helloWorld({data: "frank"}).then((result) => assert.eq(result, "Hello frank. How are you?"));});}, order: {basic: function() {return test("two", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({helloWorld: function({data}) {return `Hello ${Caf.toString(data)}.`;}}); this.publicRequestTypes("helloWorld"); this.filter({before: {helloWorld: function(r) {return r.withData(r.data + "A");}}, after: {helloWorld: function(r) {return r.withData(r.data + "A");}}}); this.filter({before: {helloWorld: function(r) {return r.withData(r.data + "B");}}, after: {helloWorld: function(r) {return r.withData(r.data + "B");}}});}); return pipelines.myPipeline.helloWorld({data: "frank"}).then((result) => assert.eq(result, "Hello frankBA.AB"));});}, groups: function() {test("grouped", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({myAction: function() {return "-";}}); this.publicRequestTypes("myAction"); this.filter({name: "filterA", group: "outer", after: {myAction: function(r) {return r.withData(`${Caf.toString(r.data)}A`);}}}); this.filter({name: "filterB", group: "inner", after: {myAction: function(r) {return r.withData(`${Caf.toString(r.data)}B`);}}}); this.filter({name: "filterC", group: "middle", after: {myAction: function(r) {return r.withData(`${Caf.toString(r.data)}C`);}}}); this.filter({name: "filterD", group: "loggers", after: {myAction: function(r) {return r.withData(`${Caf.toString(r.data)}D`);}}});}); return pipelines.myPipeline.myAction().then((result) => assert.eq(result, "-BCAD"));}); return test("ungrouped", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({myAction: function() {return "-";}}); this.publicRequestTypes("myAction"); this.filter({name: "filterA", after: {myAction: function(r) {return r.withData(`${Caf.toString(r.data)}A`);}}}); this.filter({name: "filterB", after: {myAction: function(r) {return r.withData(`${Caf.toString(r.data)}B`);}}}); this.filter({name: "filterC", after: {myAction: function(r) {return r.withData(`${Caf.toString(r.data)}C`);}}}); this.filter({name: "filterD", after: {myAction: function(r) {return r.withData(`${Caf.toString(r.data)}D`);}}});}); return pipelines.myPipeline.myAction().then((result) => assert.eq(result, "-ABCD"));});}}, query: function() {return test("query handlers with after-all filter", () => {let Post; Post = Caf.defClass(class Post extends Pipeline {}, function(Post, classSuper, instanceSuper) {this.query({postByUserId: function(request) {return [request.key, 1, 2, 3];}}); this.publicRequestTypes("postByUserId"); this.filter({after: {all: function(response) {return response.withData(Caf.array(response.data, (a) => `${Caf.toString(a)} ${Caf.toString(a)}`));}}});}); assert.eq(Post.post.clientApiMethodList, ["postByUserId"]); return Post.post.postByUserId({key: "foo"}).then((results) => assert.eq(results, ["foo foo", "1 1", "2 2", "3 3"]));});}, filterLogs: function() {return test("basic", () => {let MyPipeline, p; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({foo: function(request) {return merge(request.data, {myHandlerRan: true});}}); this.publicRequestTypes("foo"); this.filter({name: "MyBeforeFooFilter", before: {foo: function(request) {return request.withMergedData({myBeforeFooFilterRan: true});}}}); this.filter({name: "MyAfterFooFilter", after: {foo: function(response) {return response.withMergedData({myAfterFooFilterRan: true});}}});}); p = new MyPipeline; return p.foo({returnResponseObject: true}).then((response) => {assert.eq(["created", "MyBeforeFooFilter", "foo-handler"], Caf.array(response.beforeFilterLog, ({name}) => name)); assert.eq(["MyAfterFooFilter"], Caf.array(response.afterFilterLog, ({name}) => name)); return assert.eq(response.data, {myHandlerRan: true, myBeforeFooFilterRan: true, myAfterFooFilterRan: true});});});}, location: function() {test("before filters by location", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({foo: function(request) {return merge(request.data, {myHandlerRan: true});}}); this.publicRequestTypes("foo"); this.filter({location: "client", name: "beforeFooClient", before: {foo: function(request) {return request;}}}); this.filter({location: "both", name: "beforeFooBoth", before: {foo: function(request) {return request;}}}); this.filter({location: "server", name: "beforeFooServer", before: {foo: function(request) {return request;}}});}); assert.eq(["client", "both"], Caf.array(pipelines.myPipeline.getBeforeFilters({requestType: "foo", location: "client"}), (f) => f.location)); assert.eq(["server", "both"], Caf.array(pipelines.myPipeline.getBeforeFilters({requestType: "foo", location: "server"}), (f) => f.location)); return assert.eq(["client", "server", "both"], Caf.array(pipelines.myPipeline.getBeforeFilters({requestType: "foo", location: "both"}), (f) => f.location));}); return test("after filters by location", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({foo: function(request) {return merge(request.data, {myHandlerRan: true});}}); this.publicRequestTypes("foo"); this.filter({location: "client", name: "afterFooClient", after: {foo: function(request) {return request;}}}); this.filter({location: "both", name: "afterFooBoth", after: {foo: function(request) {return request;}}}); this.filter({location: "server", name: "afterFooServer", after: {foo: function(request) {return request;}}});}); assert.eq(["both", "client"], Caf.array(pipelines.myPipeline.getAfterFilters({requestType: "foo", location: "client"}), (f) => f.location)); assert.eq(["both", "server"], Caf.array(pipelines.myPipeline.getAfterFilters({requestType: "foo", location: "server"}), (f) => f.location)); return assert.eq(["both", "server", "client"], Caf.array(pipelines.myPipeline.getAfterFilters({requestType: "foo", location: "both"}), (f) => f.location));});}, filterFailures: function() {return test("basic", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({foo: function(request) {return (() => {throw new Error("simulated error on foo request");})();}}); this.publicRequestTypes("foo"); this.filter({name: "FilterWithoutFilterFailures", after: {foo: function(response) {return response.success({data: "not me"});}}}); this.filter({name: "FilterWithFilterFailures", filterFailures: true, after: {foo: function(response) {return response.success({data: "me!"});}}});}); assert.eq(false, pipelines.myPipeline.filters[0].filterFailures); assert.eq(true, pipelines.myPipeline.filters[1].filterFailures); return pipelines.myPipeline.foo().then((result) => assert.eq(result, "me!"));});}, groups: function() {}, regressions: function() {return test("can share filter instances", () => {let MyFilter, instance, MyPipeline1, MyPipeline2; MyFilter = Caf.defClass(class MyFilter extends Filter {}, function(MyFilter, classSuper, instanceSuper) {this.after({foo: function(response) {return response.withMergedData({myFiltered: true});}});}); instance = new MyFilter; MyPipeline1 = Caf.defClass(class MyPipeline1 extends Pipeline {}, function(MyPipeline1, classSuper, instanceSuper) {this.publicRequestTypes("foo"); this.handlers({foo: function(request) {return {foo1ed: true};}}); this.filter(instance);}); MyPipeline2 = Caf.defClass(class MyPipeline2 extends Pipeline {}, function(MyPipeline2, classSuper, instanceSuper) {this.publicRequestTypes("foo"); this.handlers({foo: function(request) {return {foo2ed: true};}}); this.filter(instance);}); return Promise.all([pipelines.myPipeline1.foo(), pipelines.myPipeline2.foo()]).then(([foo1, foo2]) => {assert.eq(foo1, {foo1ed: true, myFiltered: true}); return assert.eq(foo2, {foo2ed: true, myFiltered: true});});});}});});});
//# sourceMappingURL=Filters.test.js.map
