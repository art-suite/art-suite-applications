"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "test", "Filter", "assert", "Object", "Pipeline"], [global, require('./StandardImport')], (describe, test, Filter, assert, Object, Pipeline) => {require('art-config').configure(); return describe({extendFields: function() {test("on subclass", () => {let MyFilter; MyFilter = Caf.defClass(class MyFilter extends Filter {}, function(MyFilter, classSuper, instanceSuper) {this.fields({foo: "string"});}); assert.eq(["foo"], Object.keys(MyFilter.getFields())); return assert.selectedEq({fieldType: "string", dataType: "string"}, MyFilter.getFields().foo);}); test("on subclass and sub-subclass - with new field", () => {let MyFilter, MySubFilter; MyFilter = Caf.defClass(class MyFilter extends Filter {}, function(MyFilter, classSuper, instanceSuper) {this.fields({foo: "string"});}); MySubFilter = Caf.defClass(class MySubFilter extends MyFilter {}, function(MySubFilter, classSuper, instanceSuper) {this.fields({bar: "number"});}); assert.eq(["foo"], Object.keys(MyFilter.getFields())); assert.eq(["foo", "bar"], Object.keys(MySubFilter.getFields())); assert.selectedEq({fieldType: "string"}, MyFilter.getFields().foo); assert.selectedEq({fieldType: "string"}, MySubFilter.getFields().foo); return assert.selectedEq({fieldType: "number"}, MySubFilter.getFields().bar);}); test("on subclass and sub-subclass - with replaced field", () => {let MyFilter, MySubFilter; MyFilter = Caf.defClass(class MyFilter extends Filter {}, function(MyFilter, classSuper, instanceSuper) {this.fields({foo: "string"});}); MySubFilter = Caf.defClass(class MySubFilter extends MyFilter {}, function(MySubFilter, classSuper, instanceSuper) {this.fields({foo: "number"});}); assert.eq(["foo"], Object.keys(MyFilter.getFields())); assert.eq(["foo"], Object.keys(MySubFilter.getFields())); assert.selectedEq({fieldType: "string"}, MyFilter.getFields().foo); return assert.selectedEq({fieldType: "number"}, MySubFilter.getFields().foo);}); return test("on subclass and subclass-instance", () => {let MyFilter, myFilter; MyFilter = Caf.defClass(class MyFilter extends Filter {}, function(MyFilter, classSuper, instanceSuper) {this.fields({foo: "string"});}); myFilter = new MyFilter; myFilter.extendFields({bar: "number"}); assert.eq(["foo"], Object.keys(MyFilter.getFields())); return assert.eq(["foo", "bar"], Object.keys(myFilter.getFields()));});}, order: function() {let orderLog, OrderTestFilter; orderLog = []; OrderTestFilter = Caf.defClass(class OrderTestFilter extends Filter {constructor(str) {super(...arguments); this.str = str;};}, function(OrderTestFilter, classSuper, instanceSuper) {this.before({create: function(request) {orderLog.push(`beforeCreate ${Caf.toString(this.str)}`); return request.withData({message: `${Caf.toString(request.data.message || "")}${Caf.toString(this.str)}`});}}); this.after({create: function(response) {orderLog.push(`afterCreate ${Caf.toString(this.str)}`); return response;}});}); return test("b > a > g > save > g > a > b", () => {let MyPipeline; orderLog = []; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.filter(new OrderTestFilter("g")); this.filter(new OrderTestFilter("a")); this.filter(new OrderTestFilter("b")); this.publicHandlers({create: function({data}) {return data;}});}); return MyPipeline.singleton.create({data: {}}).then((savedData) => {assert.eq(orderLog, ["beforeCreate b", "beforeCreate a", "beforeCreate g", "afterCreate g", "afterCreate a", "afterCreate b"]); return assert.eq(savedData.message, "bag");});});}, all: function() {let OrderTestFilter; OrderTestFilter = Caf.defClass(class OrderTestFilter extends Filter {constructor(str) {super(...arguments); this.str = str;};}, function(OrderTestFilter, classSuper, instanceSuper) {this.before({all: function(request) {let m; return request.withData({message: `${Caf.toString((m = request.data.message) ? `${Caf.toString(m)}\n` : "")}before_${Caf.toString(request.type)}(${Caf.toString(this.str)})`});}}); this.after({all: function(response) {let m; return response.withMergedData({message: `${Caf.toString((m = response.data.message) ? `${Caf.toString(m)}\n` : "")}after_${Caf.toString(response.request.type)}(${Caf.toString(this.str)})`});}});}); return test("before and after all", () => {let orderLog, MyPipeline; orderLog = []; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.filter(new OrderTestFilter("g")); this.filter(new OrderTestFilter("a")); this.filter(new OrderTestFilter("b")); this.publicHandlers({create: function({data}) {return data;}});}); return MyPipeline.singleton.create({data: {}}).then((savedData) => assert.eq(savedData.message, "before_create(b)\nbefore_create(a)\nbefore_create(g)\nafter_create(g)\nafter_create(a)\nafter_create(b)"));});}});});});
//# sourceMappingURL=FilterBase.test.js.map
