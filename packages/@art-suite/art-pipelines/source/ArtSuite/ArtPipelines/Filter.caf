import &StandardImport
Validator extract normalizeFields

class Filter extends &RequestHandler

  @preprocessFilters: (filter) =>
    if isPlainArray filter
      array f in compactFlatten filter when f with @preprocessFilter f

    else
      @preprocessFilter filter

  @preprocessFilter: (filter) ->
    if isClass filter                 then new filter
    else if isFunction filter         then filter @
    else if filter instanceof Filter  then filter
    else if isPlainObject filter      then new Filter filter
    else throw "" invalid filter: #{inspect filter} #{filter instanceof Filter}

  @locationNames: locationNames =
    server: true
    client: true
    both: true

  #############################
    ###########################

      Declarative API

    ###########################
    ###########################
  ## FilterFunction
    FilterFunction: (response) -> Promise<Request>
      IN: Request instance
      OUT: return a Promise returning one of the list below OR just return one of the list below:
        Request request instance
        Request response instance
        anythingElse -> toResponse anythingElse

      To reject a request:
      - throw an error
      - return a rejected promise
      - or create a Request response object with the appropriate fields
  @extendableProperty
    ## before USAGE: @before requestName: FilterFunction
    before: {}

    ## after USAGE: @after requestName: FilterFunction
    after: {}

  ## @fields extendableProperty
    USAGE: see Pipeline.fields
    Triggers pipeline.fields thisFitler.fields when added to a pipeline
  @extendableProperty
    fields: {}
    {} extend: (oldFields, addFields) ->
      merge oldFields, normalizeFields addFields
  @field: @extendFields

  ## @requestTypes extendableProperty
    USAGE: see Pipeline.requestTypes
    Triggers pipeline.requestTypes thisFitler.requestTypes when added to a pipeline
  @extendableProperty
    requestTypes: {}
  @requestType: @extendRequestTypes

  ## @filterFailures extendableProperty
    If true, any after-filters will process both successful AND failed responses
    By defailt, after-filters will only filter successful responses.
  @extendableProperty filterFailures: false

  ## @location extendableProperty
    USAGE: @location :server
    determine if the filter will run on the 'server', 'client' or 'both'.
  @extendableProperty
    location: :server
    {} extend: (__, v) ->
      throw new Error "invalid location: #{v}" unless locationNames[v]
      v

  ###
    Filter Groups: default: "middle"

    Filter sequence, based on groups:
      loggers beforeFilter
        authorization beforeFilter
          outer beforeFilter
            middle beforeFilter
              inner beforeFilter
                handler
              inner afterFilter
            middle afterFilter
          outer afterFilter
        authorization afterFilter
      loggers afterFilter
  @groupNames:
    loggers:        3
    authorization:  2
    outer:          1
    middle:         0
    inner:          -1

  ## group USAGE: @group :outer
  @extendableProperty
    group: @groupNames.middle
    {} extend: (__, v) ->
      if v?
        throw new Error "invalid Filter group: #{v}" unless (value = Filter.groupNames[v])?
        value
      else
        0

  ###
    2018-04-19 SBD: I still think 'both' should be 1000, but it breaks Zo.

    Why? Because the ValidationFilter sets default fields and the UserOwnedFilter
    throws errors if the user attempts to set fields they aren't allowed to manually
    set. Well, this means the UserOwnedFilter needs to fire BEFORE ValidationFilter.

    The real problem here is ValidationFilter actually acts differently client-side vs
    server-side. I'm beginning to think the "both" mode for a Filter actually doesn't
    make much sense. I think we DO want to have a client-side validator which is
    initialized with the exact same constraint as the server-side validator. However,
    I'm beginning to think it just makes more sense if they are actually different filters.

    Right now I'm overloading what "Validation" means - and overloading usually (always?)
    creates unecessary complexity.

    And guess what? Validation, and only as a pre-filter, is STILL the only example I've
    found where a "both" filter kind-of makes sense.

    If we split Validator into separate Client and Server, we can drop the whole "both"
    concept - which probably simplifies A LOT of code! ooo!

    2022-12-17 SBD: YES! Split ValidationFitler; Drop 'both' for filter run-location, and
      not metioned here but mentioned elsewhere, run the exact same filter sequence wheather
      we are running 100% client-side or split client-server (needs some refactoring).

      THEN we can drop this whole 'locationPriorityBoost' hack

      In fact, I want to drop 'priority' all together, though I'm not quite sure what I want
      to replace it with.
  locationPriorityBoost =
    client: 2000
    both:   0
    server: 0

  @getter
    priority: -> @group + locationPriorityBoost[@location]
    logName:  -> @getName()
    props:    -> {} @location
    inspectedObjects: -> if @path?.match @name then @path else  @name

  #################################
  # class instance methods
  #################################

  ## NOTE!!! Filter instances must be stateless w.r.t. pipelines
    In other words, the same filter instance can be used on more than one pipeline.
    WHY? So we can inherit filters.
    WHY? So we can define global filters for all, or a subset, of the pipelines
  constructor: (options = {}) ->
    @serverSideOnly = options.serverSideOnly
    @clientSideOnly = options.clientSideOnly
    @name           = options.name ? @class.getName()

    # declarables
    @location       = options.location ? @class.getLocation()
    @fields         = options.fields
    @group          = options.group
    @filterFailures = options.filterFailures
    @after          = options.after
    @before         = options.before

  @property :name

  shouldFilter: (processingLocation) ->
    switch @location
    when :server then processingLocation != :client
    when :client then processingLocation != :server
    when :both   then true
    else throw new Error "" Filter #{@getName()}: invalid filter location: #{@location}

  toString: -> @getName()

  getBeforeFilter: ({requestType, location}) -> @shouldFilter(location) && (@before[requestType] || @before.all)
  getAfterFilter:  ({requestType, location}) -> @shouldFilter(location) && (@after[requestType]  || @after.all)

  processBefore:  (request) -> @applyHandler request, @getBeforeFilter(request), :beforeFilter
  processAfter:   (request) -> @applyHandler request, @getAfterFilter(request),  :afterFilter

  handleRequest: (request, filterChain, currentFilterChainIndex) ->
    @processBefore request
    .then (request) ->
      if request.isResponse then request
      else
        if nextHandler = filterChain[nextIndex = currentFilterChainIndex + 1]
              nextHandler.handleRequest request, filterChain, nextIndex
        else  request.failure "" INTERNAL-ERROR: no nextHandler for request type: #{request.type}

        .then (response) ->
          if response.isSuccessful || @filterFailures
                @processAfter response
          else  response
