import &StandardImport
Validator extract normalizeFields

class Filter extends &RequestHandler

  @preprocessFilters: (filter) =>
    if isPlainArray filter
      array f in compactFlatten filter when f with @preprocessFilter f

    else
      @preprocessFilter filter

  @preprocessFilter: (filter) ->
    if isClass filter                 then new filter
    else if isFunction filter         then throw new Error "Passing a function for Filter definition is DEPRICATED" # filter @
    else if filter instanceof Filter  then filter
    else if isPlainObject filter      then new Filter filter
    else throw "" invalid filter: #{inspect filter} #{filter instanceof Filter}

  #############################
    ###########################

      Declarative API

    ###########################
    ###########################
  ## FilterFunction
    FilterFunction: (response) -> Promise<Request>
      IN: Request instance
      OUT: return a Promise returning one of the list below OR just return one of the list below:
        Request request instance
        Request response instance
        anythingElse -> toResponse anythingElse

      To reject a request:
      - throw an error
      - return a rejected promise
      - or create a Request response object with the appropriate fields
  @extendableProperty
    ## before USAGE: @before requestName: FilterFunction
    before: {}

    ## after USAGE: @after requestName: FilterFunction
    after: {}

  ## @fields extendableProperty
    USAGE: see Pipeline.fields
    Triggers pipeline.fields thisFitler.fields when added to a pipeline
  @extendableProperty
    fields: {}
    {} extend: (oldFields, addFields) ->
      merge oldFields, normalizeFields addFields
  @field: @extendFields

  ## @requestTypes extendableProperty
    USAGE: see Pipeline.requestTypes
    Triggers pipeline.requestTypes thisFitler.requestTypes when added to a pipeline
  @extendableProperty
    requestTypes: {}
  @requestType: @extendRequestTypes

  ## @filterFailures extendableProperty
    If true, any after-filters will process both successful AND failed responses
    By defailt, after-filters will only filter successful responses.
  @extendableProperty filterFailures: false

  ## @location extendableProperty
    USAGE: @location :server
    determine if the filter will run on the 'server', 'client' or 'both'.
  @extendableProperty
    location: :server
    {} extend: (__, v) ->
      throw new Error "invalid location: #{v}" unless filterLocations[v]
      v

  ###
    Filter Groups: default: "middle"

    Filter sequence, based on groups:
      loggers beforeFilter
        authorization beforeFilter
          outer beforeFilter
            middle beforeFilter
              inner beforeFilter
                handler
              inner afterFilter
            middle afterFilter
          outer afterFilter
        authorization afterFilter
      loggers afterFilter
  @groupNames:
    loggers:        3
    authorization:  2
    outer:          1
    middle:         0
    inner:          -1
    handler:        -2

  ## group USAGE: @group :outer
  @extendableProperty
    group: @groupNames.middle
    {} extend: (__, v) ->
      if v?
        throw new Error "invalid Filter group: #{v}" unless (value = Filter.groupNames[v])?
        value
      else
        0

  @getter
    priority: -> @group
    props:    -> {} @location
    inspectedObjects: ->
      filter: merge {} @name, @location, @group,
        before: if objectHasKeys @before then Object.keys @before
        after:  if objectHasKeys @after then Object.keys @after

  #################################
  # class instance methods
  #################################

  ## NOTE!!! Filter instances must be stateless w.r.t. pipelines
    In other words, the same filter instance can be used on more than one pipeline.
    WHY? So we can inherit filters.
    WHY? So we can define global filters for all, or a subset, of the pipelines
  constructor: (options = {}) ->
    @serverSideOnly = options.serverSideOnly
    @clientSideOnly = options.clientSideOnly
    @name           = options.name ? @class.getName()

    # declarables
    @location       = options.location ? @class.getLocation()
    @fields         = options.fields
    @group          = options.group
    @filterFailures = options.filterFailures
    @after          = options.after
    @before         = options.before

    @extendRequestTypes requestTypes if requestTypes = options.requestType ? options.requestTypes

  @property :name

  shouldFilter: (processingLocation) ->
    switch @location
    when :server then processingLocation != :client
    when :client then processingLocation != :server
    when :both   then true
    else throw new Error "" Filter #{@getName()}: invalid filter location: #{@location}

  toString: -> @getName()

  getBeforeFilter: ({requestType, location}) -> @shouldFilter(location) && (@before[requestType] || @before.all)
  getAfterFilter:  ({requestType, location}) -> @shouldFilter(location) && (@after[requestType]  || @after.all)

  processBefore:  (request) -> @applyHandler request, @getBeforeFilter(request), :beforeFilter
  processAfter:   (request) -> @applyHandler request, @getAfterFilter(request),  :afterFilter

  handleRequest: (request, filterChain, currentFilterChainIndex) ->
    @processBefore request
    .then (request) ->
      if request.isResponse then request
      else
        if nextHandler = filterChain[nextIndex = currentFilterChainIndex + 1]
              nextHandler.handleRequest request, filterChain, nextIndex
        else  request.failure "" INTERNAL-ERROR: no nextHandler for request type: #{request.type}

        .then (response) ->
          if response.isSuccessful || @filterFailures
                @processAfter response
          else  response
