import &StandardImport, &PipelineRegistry, {} &Request

class RequestHandler extends BaseObject
  @abstractClass()

  @extendableProperty {} pipelineRegistry
  @registry: @extendPipelineRegistry
  @getRegistry: -> @getPipelineRegistry()
  @getter registry: -> @pipelineRegistry

  @getter
    registry: -> @class.getRegistry()
    pipelines: -> @registry.pipelines

  ## applyHandler
    OUT:
      promise.then (request or response) ->
        NOTE: response may be failing
      .catch -> internal errors only
  applyHandler: (request, handlerFunction, context) ->
    # pass-through if no filter
    return Promise.resolve request unless handlerFunction

    resultPromise =
      @_applyHandler request, handlerFunction, context
      .then (response) ->
        if response?.isFailure && !response.errorProps?.failedIn
          response.withMergedErrorProps failedIn: {}
            context
            handler: @
            response

        else
          response

    if request.verbose
      resultPromise
      .tap (result) ->
        if result != request && neq request.summary, result.summary
          content = "ArtPipelines-applyHandler-Verbose #{request.requestString} - #{dashCase context} #{@getLogName @type}":
            before: request.summary
            after:  result.summary

          if result.isError && !request.isError then log.error content else log content

        else log "ArtPipelines-applyHandler-Verbose #{request.requestString} - #{dashCase context} #{@getLogName @type}": "no-change"

    else resultPromise

  ## _applyHandler
  _applyHandler: (request, handlerFunction, context) ->

    newFilterLog = null
    Promise.then ->
      newFilterLog = request.addFilterLog @, context
      handlerFunction.call @, request

    .then
      (data) ->
        unless data?                                then request.missing()
        else if data instanceof Request
          if isFailure data.status
            newFilterLog.stack = data.creationStack

          data
        else if isJsonType data                     then request.success {} data
        else
          request.failure
            """
              Invalid response data returned from handler: #{@name} context: #{context}

              #{} formattedInspect {} data

      # send response-errors back through the 'resolved' promise path
      # We allow them to be thrown in order to skip parts of code, but they should be returned normally
      (error) ->
        newFilterLog.exception = error || new Error "there was no error"
        # newFilterLog.status = if request.location == :client then :clientFailure else :serverFailure

        if error.props?.response?.isResponse
          error.props.response

        else if isFailure status = error.info?.status
          request.toResponse status, error: error.info

        else
          request.failure errorProps:
            exception: error
            source:
              this: @
              function: handlerFunction

    .tap (requestResponse) -> newFilterLog.status = requestResponse.status

    ## handleRequest
      IN:
        request OR response

        if response, it is immediately returned
      OUT:
        promise.then -> response
          response may or maynot be successful, but it is always returned via the promise-success path

        promise.catch -> always means an internal failure

      OVERRIDE THIS
    # handleRequest: (request) ->
