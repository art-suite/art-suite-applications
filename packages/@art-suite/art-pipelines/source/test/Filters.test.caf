import &StandardImport

&ArtConfig.configure()

describe
  basic: ->
    test :before ->
      class MyPipeline extends Pipeline
        @handlers helloWorld: ({data}) -> "Hello #{data}."
        @publicRequestTypes :helloWorld

        @filter
          before: helloWorld: (request) ->
            request.withData upperCamelCase request.data

      pipelines.myPipeline.helloWorld data: "frank"
      .then (result) ->
        assert.eq result, "Hello Frank."

    test :all ->
      class MyPipeline extends Pipeline
        @handlers helloWorld: ({data}) -> "Hello #{data}."
        @publicRequestTypes :helloWorld

        @filter
          before: all: (request) ->
            request.withData upperCamelCase request.data

      pipelines.myPipeline.helloWorld data: "frank"
      .then (result) ->
        assert.eq result, "Hello Frank."

    test :after ->
      {myPipeline} = class MyPipeline extends Pipeline
        @handlers helloWorld: ({data}) -> "Hello #{data}."
        @publicRequestTypes :helloWorld

        @filter
          after: helloWorld: (request) ->
            request.withData request.data + " How are you?"

      # assert.eq
      #   myPipeline.location
      #   :foo

      pipelines.myPipeline.helloWorld data: "frank"
      .then (result) ->
        assert.eq result, "Hello frank. How are you?"

  order:
    basic: ->
      test :two ->
        class MyPipeline extends Pipeline
          @handlers helloWorld: ({data}) -> "Hello #{data}."
          @publicRequestTypes :helloWorld

          @filter
            before: helloWorld: (r) -> r.withData r.data + :A
            after:  helloWorld: (r) -> r.withData r.data + :A

          @filter
            before: helloWorld: (r) -> r.withData r.data + :B
            after:  helloWorld: (r) -> r.withData r.data + :B

        pipelines.myPipeline.helloWorld data: "frank"
        .then (result) ->
          assert.eq result, "Hello frankBA.AB"

    groups: ->
      test :grouped ->
        class MyPipeline extends Pipeline
          @handlers myAction: -> :-
          @publicRequestTypes :myAction

          @filter name: :filterA  group: :outer     after: myAction: (r) -> r.withData "" #{r.data}A
          @filter name: :filterB  group: :inner     after: myAction: (r) -> r.withData "" #{r.data}B
          @filter name: :filterC  group: :middle    after: myAction: (r) -> r.withData "" #{r.data}C
          @filter name: :filterD  group: :loggers   after: myAction: (r) -> r.withData "" #{r.data}D

        pipelines.myPipeline.myAction()
        .then (result) ->
          assert.eq result, "-BCAD"

      test :ungrouped ->
        class MyPipeline extends Pipeline
          @handlers myAction: -> :-
          @publicRequestTypes :myAction

          @filter name: :filterA  after: myAction: (r) -> r.withData "" #{r.data}A
          @filter name: :filterB  after: myAction: (r) -> r.withData "" #{r.data}B
          @filter name: :filterC  after: myAction: (r) -> r.withData "" #{r.data}C
          @filter name: :filterD  after: myAction: (r) -> r.withData "" #{r.data}D

        pipelines.myPipeline.myAction()
        .then (result) ->
          assert.eq result, "-ABCD"

  query: ->
    test "query handlers with after-all filter" ->
      class Post extends Pipeline
        @query postByUserId: (request) -> [] request.key, 1, 2, 3
        @publicRequestTypes :postByUserId

        @filter
          after: all: (response) ->
            response.withData array a from response.data with "#{a} #{a}"

      assert.eq Post.post.clientApiMethodList, [] "postByUserId"
      Post.post.postByUserId key: :foo
      .then (results) ->
        assert.eq results, [] "foo foo" "1 1" "2 2" "3 3"

  filterLogs: ->
    test "basic", ->
      class MyPipeline extends Pipeline
        @handlers foo: (request) -> merge request.data, myHandlerRan: true
        @publicRequestTypes :foo

        @filter
          name: "MyBeforeFooFilter"
          before: foo: (request) -> request.withMergedData myBeforeFooFilterRan: true

        @filter
          name: "MyAfterFooFilter"
          after: foo: (response) -> response.withMergedData myAfterFooFilterRan: true

      p = new MyPipeline
      p.foo returnResponseObject: true
      .then (response) ->
        assert.eq [:created :MyBeforeFooFilter, :foo-handler], array {name} in response.beforeFilterLog with name
        assert.eq [:MyAfterFooFilter               ], array {name} in response.afterFilterLog  with name
        assert.eq
          response.data
          myHandlerRan: true
          myBeforeFooFilterRan: true
          myAfterFooFilterRan: true

  location: ->
    test "before filters by location", ->
      class MyPipeline extends Pipeline
        @handlers foo: (request) -> merge request.data, myHandlerRan: true
        @publicRequestTypes :foo

        @filter
          location: "client"
          name: "beforeFooClient"
          before: foo: (request) -> request

        @filter
          location: "both"
          name: "beforeFooBoth"
          before: foo: (request) -> request

        @filter
          location: "server"
          name: "beforeFooServer"
          before: foo: (request) -> request

      assert.eq ["client", "both"],           array f in pipelines.myPipeline.getBeforeFilters requestType: "foo", location: "client" with f.location
      assert.eq ["server", "both"],           array f in pipelines.myPipeline.getBeforeFilters requestType: "foo", location: "server" with f.location
      assert.eq ["client", "server", "both"], array f in pipelines.myPipeline.getBeforeFilters requestType: "foo", location: "both"   with f.location

    test "after filters by location", ->
      class MyPipeline extends Pipeline
        @handlers foo: (request) -> merge request.data, myHandlerRan: true
        @publicRequestTypes :foo

        @filter
          location: "client"
          name: "afterFooClient"
          after: foo: (request) -> request

        @filter
          location: "both"
          name: "afterFooBoth"
          after: foo: (request) -> request

        @filter
          location: "server"
          name: "afterFooServer"
          after: foo: (request) -> request

      assert.eq ["both", "client"],           array f in pipelines.myPipeline.getAfterFilters requestType: "foo", location: "client" with f.location
      assert.eq ["both", "server"],           array f in pipelines.myPipeline.getAfterFilters requestType: "foo", location: "server" with f.location
      assert.eq ["both", "server", "client"], array f in pipelines.myPipeline.getAfterFilters requestType: "foo", location: "both"   with f.location


  filterFailures: ->
    test :basic ->
      class MyPipeline extends Pipeline
        @handlers foo: (request) -> throw new Error "simulated error on foo request"
        @publicRequestTypes :foo

        @filter
          name: :FilterWithoutFilterFailures
          # filterFailures: true
          after: foo: (response) ->
            response.success data: "not me"

        @filter
          name: :FilterWithFilterFailures
          filterFailures: true
          after: foo: (response) ->
            # log FilterWithFilterFailures: response
            response.success data: "me!"


      assert.eq false, pipelines.myPipeline.filters[0].filterFailures
      assert.eq true, pipelines.myPipeline.filters[1].filterFailures

      pipelines.myPipeline.foo()
      .then (result)->
        assert.eq result, "me!"

  regressions: ->
    test "can share filter instances" ->
      class MyFilter extends Filter
        @after foo: (response) ->
          response.withMergedData myFiltered: true

      instance = new MyFilter

      class MyPipeline1 extends Pipeline
        @publicRequestTypes :foo
        @handlers foo: (request) -> foo1ed: true
        @filter instance

      class MyPipeline2 extends Pipeline
        @publicRequestTypes :foo
        @handlers foo: (request) -> foo2ed: true
        @filter instance

      Promise.all([
        pipelines.myPipeline1.foo()
        pipelines.myPipeline2.foo()
      ]).then ([foo1, foo2]) ->
        assert.eq foo1, foo1ed: true, myFiltered: true
        assert.eq foo2, foo2ed: true, myFiltered: true

  extendFields: ->
    test "on subclass", ->
      class MyFilter extends Filter
        @fields foo: "string"

      assert.eq ["foo"], Object.keys MyFilter.getFields()
      assert.selectedEq
        fieldType:  "string"
        dataType:   "string"
        MyFilter.getFields().foo

    test "filter fields add to pipeline", ->
      class MyFilter extends Filter
        @fields filterFoo: "string"

      class MyPipeline extends Pipeline
        @fields pipelineFoo: "string"

        @filter MyFilter

      assert.eq
        :filterFoo :pipelineFoo
        Object.keys MyPipeline.getFields()
        .sort()

    test "on subclass and sub-subclass - with new field", ->
      class MyFilter extends Filter
        @fields foo: "string"

      class MySubFilter extends MyFilter
        @fields bar: "number"

      assert.eq ["foo"], Object.keys MyFilter.getFields()
      assert.eq ["foo", "bar"], Object.keys MySubFilter.getFields()

      assert.selectedEq {fieldType: "string"}, MyFilter.getFields().foo
      assert.selectedEq {fieldType: "string"}, MySubFilter.getFields().foo
      assert.selectedEq {fieldType: "number"}, MySubFilter.getFields().bar

    test "on subclass and sub-subclass - with replaced field", ->
      class MyFilter extends Filter
        @fields foo: "string"

      class MySubFilter extends MyFilter
        @fields foo: "number"

      assert.eq ["foo"], Object.keys MyFilter.getFields()
      assert.eq ["foo"], Object.keys MySubFilter.getFields()

      assert.selectedEq {fieldType: "string"}, MyFilter.getFields().foo
      assert.selectedEq {fieldType: "number"}, MySubFilter.getFields().foo

    test "on subclass and subclass-instance", ->
      class MyFilter extends Filter
        @fields foo: "string"

      myFilter = new MyFilter
      myFilter.extendFields bar: "number"

      assert.eq ["foo"], Object.keys MyFilter.getFields()
      assert.eq ["foo", "bar"], Object.keys myFilter.getFields()

  all: ->

    class OrderTestFilter extends Filter
      constructor: (@str) ->

      @before all: (request)  -> request.withData         message: "" #{if m = request.data.message  then "#{m}\n" else ''}before-#{request.type}(#{@str})
      @after  all: (response) -> response.withMergedData  message: "" #{if m = response.data.message then "#{m}\n" else ''}after-#{response.request.type}(#{@str})

    test "before and after all" ->
      orderLog = []
      class MyPipeline extends Pipeline
        @filter new OrderTestFilter :g
        @filter new OrderTestFilter :a
        @filter new OrderTestFilter :b

        @publicHandlers create: ({data:{message}}) -> message: "#{message}\ncreate-handler"

      MyPipeline.singleton.create data: {}
      .then (savedData) ->
        assert.eq
          savedData.message
          """
            before-create(b)
            before-create(a)
            before-create(g)
            create-handler
            after-create(g)
            after-create(a)
            after-create(b)