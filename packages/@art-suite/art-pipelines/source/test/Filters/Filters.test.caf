import &StandardImport

pipelineRegistry = new &build.PipelineRegistry location: :client
pipelineRegistry extract pipelines

class Pipeline extends &build.Pipeline
  @registry pipelineRegistry

&ArtConfig.configure()

describe
  definitionMethods: ->
    test :plainObjectDefinition ->
      class MyPipeline extends Pipeline
        @filter before: helloWorld: -> "" Hello world!

      assert.isArray MyPipeline.getFilters()
      assert.eq MyPipeline.getFilters().length, 1
      assert.instanceOf MyPipeline.getFilters()[0], Filter
      assert.eq
        MyPipeline.getFilters()
        MyPipeline.myPipeline.filters

      assert.eq
        toInspectedObjects MyPipeline.myPipeline.filters
        [] filter: name: :Filter location: :server group: 0 before: [] :helloWorld

    test :class ->
      class MyFilter extends Filter
        @before helloWorld: -> "" Hello world!
      class MyPipeline extends Pipeline
        @filter MyFilter

      assert.eq
        toInspectedObjects MyPipeline.myPipeline.filters
        [] filter: name: :MyFilter location: :server group: 0 before: [] :helloWorld

    test :instance ->
      class MyFilter extends Filter
        @before helloWorld: -> "" Hello world!
      class MyPipeline extends Pipeline
        @filter new MyFilter

      assert.eq
        toInspectedObjects MyPipeline.myPipeline.filters
        [] filter: name: :MyFilter location: :server group: 0 before: [] :helloWorld

  basic: ->
    test :before ->
      class MyPipeline extends Pipeline
        @handlers helloWorld: ({data}) -> "" Hello #{data}.
        @publicRequestTypes :helloWorld
        @filter before: helloWorld: (request) -> request.withData upperCamelCase request.data

      pipelines.myPipeline.helloWorld data: :frank location: :server
      .then (result) -> assert.eq result, "" Hello Frank.

    test :all ->
      class MyPipeline extends Pipeline
        @handlers helloWorld: ({data}) -> "" Hello #{data}.
        @publicRequestTypes :helloWorld
        @filter before: all: (request) -> request.withData upperCamelCase request.data

      pipelines.myPipeline.helloWorld data: :frank location: :server
      .then (result) -> assert.eq result, "" Hello Frank.

    test :after ->
      {myPipeline} = class MyPipeline extends Pipeline
        @handlers helloWorld: ({data}) -> "" Hello #{data}.
        @publicRequestTypes :helloWorld
        @filter after: helloWorld: (request) -> request.withData request.data + " How are you?"

      pipelines.myPipeline.helloWorld data: :frank location: :server
      .then (result) -> assert.eq result, "" Hello frank. How are you?

  order:
    basic: ->
      test "two filters" ->
        class MyPipeline extends Pipeline
          @handlers helloWorld: ({data}) -> "Hello #{data}."
          @publicRequestTypes :helloWorld

          @filter
            before: helloWorld: (r) -> r.withData r.data + :/a-before/
            after:  helloWorld: (r) -> r.withData r.data + :/a-after/

          @filter
            before: helloWorld: (r) -> r.withData r.data + :/b-before/
            after:  helloWorld: (r) -> r.withData r.data + :/b-after/

        pipelines.myPipeline.helloWorld data: :frank location: :server
        .then (result) ->
          assert.eq result, "" Hello frank/b-before//a-before/./a-after//b-after/

    groups: ->
      test :grouped ->
        class MyPipeline extends Pipeline
          @handlers myAction: -> :-
          @publicRequestTypes :myAction

          @filter name: :filterA  group: :outer     after: myAction: (r) -> r.withData "" #{r.data}A
          @filter name: :filterB  group: :inner     after: myAction: (r) -> r.withData "" #{r.data}B
          @filter name: :filterC  group: :middle    after: myAction: (r) -> r.withData "" #{r.data}C
          @filter name: :filterD  group: :loggers   after: myAction: (r) -> r.withData "" #{r.data}D

        pipelines.myPipeline.myAction location: :server
        .then (result) ->
          assert.eq result, "-BCAD"

      test :ungrouped ->
        class MyPipeline extends Pipeline
          @handlers myAction: -> :-
          @publicRequestTypes :myAction

          @filter name: :filterA  after: myAction: (r) -> r.withData "" #{r.data}A
          @filter name: :filterB  after: myAction: (r) -> r.withData "" #{r.data}B
          @filter name: :filterC  after: myAction: (r) -> r.withData "" #{r.data}C
          @filter name: :filterD  after: myAction: (r) -> r.withData "" #{r.data}D

        pipelines.myPipeline.myAction location: :server
        .then (result) ->
          assert.eq result, "-ABCD"

  query: ->
    test "query handlers with after-all filter" ->
      class Post extends Pipeline
        @query byUserId: (request) -> [] request.key, 1, 2, 3
        @publicRequestTypes :byUserId

        @filter
          after: all: (response) ->
            response.withData array a from response.data with "#{a} #{a}"

      assert.eq Post.post.clientApiMethodList, [] "byUserId"
      Post.post.byUserId key: :foo location: :server
      .then (results) ->
        assert.eq results, [] "foo foo", "1 1", "2 2", "3 3"

  location: ->
    test "before filters by location" ->
      class MyPipeline extends Pipeline
        @handlers foo: (request) -> merge request.data, myHandlerRan: true
        @publicRequestTypes :foo

        @filter location: :client before: foo: (request) -> request
        @filter location: :both   before: foo: (request) -> request
        @filter location: :server before: foo: (request) -> request

      assert.eq [:both :client],          array f in pipelines.myPipeline.getBeforeFilters requestType: :foo location: :client with f.location
      assert.eq [:server :both],          array f in pipelines.myPipeline.getBeforeFilters requestType: :foo location: :server with f.location

    test "after filters by location" ->
      class MyPipeline extends Pipeline
        @handlers foo: (request) -> merge request.data, myHandlerRan: true
        @publicRequestTypes :foo

        @filter location: :client after:  foo: (request) -> request
        @filter location: :both   after:  foo: (request) -> request
        @filter location: :server after:  foo: (request) -> request

      assert.eq [:client :both],            array f in pipelines.myPipeline.getAfterFilters requestType: :foo location: :client with f.location
      assert.eq [:both :server],            array f in pipelines.myPipeline.getAfterFilters requestType: :foo location: :server with f.location

  filterFailures: ->
    test :basic ->
      class MyPipeline extends Pipeline
        @handlers foo: (request) -> throw new Error "" simulated error on foo request
        @publicRequestTypes :foo

        @filter
          name: :FilterWithoutFilterFailures
          after: foo: (response) -> response.success data: "" not me

        @filter
          name: :FilterWithFilterFailures
          filterFailures: true
          after: foo: (response) -> response.success data: "" me!

      assert.eq false  pipelines.myPipeline.filters[0].filterFailures
      assert.eq true   pipelines.myPipeline.filters[1].filterFailures

      pipelines.myPipeline.foo location: :server
      .then (result)-> assert.eq result, "" me!

  regressions: ->
    test "can share filter instances" ->
      class MyFilter extends Filter
        @after foo: (response) ->
          response.withMergedData myFiltered: true

      instance = new MyFilter

      class MyPipeline1 extends Pipeline
        @publicRequestTypes :foo
        @handlers foo: (request) -> foo1ed: true
        @filter instance

      class MyPipeline2 extends Pipeline
        @publicRequestTypes :foo
        @handlers foo: (request) -> foo2ed: true
        @filter instance

      Promise.all []
        pipelines.myPipeline1.foo location: :server
        pipelines.myPipeline2.foo location: :server
      .then ([foo1, foo2]) ->
        assert.eq foo1, foo1ed: true myFiltered: true
        assert.eq foo2, foo2ed: true myFiltered: true

  extendFields: ->
    test "on subclass" ->
      class MyFilter extends Filter
        @fields foo: "string"

      assert.eq ["foo"], Object.keys MyFilter.getFields()
      assert.selectedEq
        fieldType:  "string"
        dataType:   "string"
        MyFilter.getFields().foo

    test "filter fields add to pipeline" ->
      class MyFilter extends Filter
        @fields filterFoo: "string"

      class MyPipeline extends Pipeline
        @fields pipelineFoo: "string"

        @filter MyFilter

      assert.eq
        :filterFoo :pipelineFoo
        Object.keys MyPipeline.getFields()
        .sort()

    test "on subclass and sub-subclass - with new field" ->
      class MyFilter extends Filter
        @fields foo: "string"

      class MySubFilter extends MyFilter
        @fields bar: "number"

      assert.eq ["foo"], Object.keys MyFilter.getFields()
      assert.eq ["foo", "bar"], Object.keys MySubFilter.getFields()

      assert.selectedEq {fieldType: "string"}, MyFilter.getFields().foo
      assert.selectedEq {fieldType: "string"}, MySubFilter.getFields().foo
      assert.selectedEq {fieldType: "number"}, MySubFilter.getFields().bar

    test "on subclass and sub-subclass - with replaced field" ->
      class MyFilter extends Filter
        @fields foo: "string"

      class MySubFilter extends MyFilter
        @fields foo: "number"

      assert.eq [:foo], Object.keys MyFilter.getFields()
      assert.eq [:foo], Object.keys MySubFilter.getFields()

      assert.selectedEq {fieldType: :string}, MyFilter.getFields().foo
      assert.selectedEq {fieldType: :number}, MySubFilter.getFields().foo

    test "on subclass and subclass-instance" ->
      class MyFilter extends Filter
        @fields foo: :string

      myFilter = new MyFilter
      myFilter.extendFields bar: :number

      assert.eq [:foo],       Object.keys MyFilter.getFields()
      assert.eq [:foo :bar],  Object.keys myFilter.getFields()

  all: ->
    class OrderTestFilter extends Filter
      constructor: (@str) ->

      @before all: (request)  -> request.withData         message: "" #{if m = request.data.message  then "#{m}\n" else ''}before-#{request.type}(#{@str})
      @after  all: (response) -> response.withMergedData  message: "" #{if m = response.data.message then "#{m}\n" else ''}after-#{response.request.type}(#{@str})

    test "before and after all" ->
      orderLog = []
      class MyPipeline extends Pipeline
        @filter new OrderTestFilter :g
        @filter new OrderTestFilter :a
        @filter new OrderTestFilter :b

        @publicHandlers create: ({data:{message}}) -> message:
          compactFlatten [message, :create-handler]
          .join "\n"

      MyPipeline.singleton.create data: {}, location: :server
      .then (savedData) ->
        assert.eq
          savedData.message
          """
            before-create(b)
            before-create(a)
            before-create(g)
            create-handler
            after-create(g)
            after-create(a)
            after-create(b)