import &StandardImport

newRequest = (options) ->
  new Request merge
    type:   "get"
    pipeline: new Pipeline
    session: {}
    options

newResponse = (responseOptions, requestOptions)->
  new Request merge
    status: responseOptions?.status || success
    request: newRequest requestOptions
    responseOptions

&ArtConfig.configure()

getEnv().ART_PIPELINES_ATTACH_RESPONSE_TO_ERRORS = true

describe
  common:
    requireHelpers:
      rejectIfErrors: ->
        test "not clientFailure" ->
          newRequest()
          .rejectIfErrors null

        test "clientFailure with string" ->
          assert.clientFailure
            newRequest()
            .rejectIfErrors "my error"

        test "clientFailure with []" ->
          assert.clientFailure
            newRequest()
            .rejectIfErrors []

        test "clientFailure with [string]" ->
          assert.clientFailure
            newRequest()
            .rejectIfErrors ["my error"]

      resolveRequireTestValue: ->
        resolveRequireTestValue = Request._resolveRequireTestValue
        test "resolveRequireTestValue true" ->
          resolveRequireTestValue true
          .then (v) -> assert.true v

        test "resolveRequireTestValue false" ->
          resolveRequireTestValue false
          .then (v) -> assert.false v

        test "resolveRequireTestValue -> true" ->
          resolveRequireTestValue -> true
          .then (v) -> assert.true v

        test "resolveRequireTestValue -> false" ->
          resolveRequireTestValue -> false
          .then (v) -> assert.false v

        test "resolveRequireTestValue -> Promise.resolve true" ->
          resolveRequireTestValue -> Promise.resolve true
          .then (v) -> assert.true v

        test "resolveRequireTestValue -> Promise.resolve false" ->
          resolveRequireTestValue -> Promise.resolve false
          .then (v) -> assert.false v

        test "resolveRequireTestValue Promise.resolve true" ->
          resolveRequireTestValue Promise.resolve true
          .then (v) -> assert.true v

        test "resolveRequireTestValue Promise.resolve false" ->
          resolveRequireTestValue Promise.resolve false
          .then (v) -> assert.false v

      requires:
        require: ->
          test "true - resolved" -> newRequest().require true
          test "Promise.resolve(true) - resolved" -> newRequest().require Promise.resolve true
          test "clientFailure" -> assert.clientFailure newRequest().require false

        rejectIf: ->
          test "false - resolved" -> newRequest().rejectIf false
          test "Promise.resolve(false) - resolved" -> newRequest().rejectIf Promise.resolve false
          test "clientFailure" -> assert.clientFailure newRequest().rejectIf true

        requiredFields: ->
          test "a: true, b: false >>> resolved" ->
            newRequest().requiredFields a: true, b: false
            .then (out) -> assert.eq out, a: true, b: false

          test "a: null, b: false >>> clientFailure" ->
            assert.clientFailure newRequest().requiredFields alpha: null, beta: false
            .then (rejectsWith) ->
              assert.match rejectsWith.info.response.data.message, /missing.*alpha/


      requireServerOrigins:
        requireServerOrigin: ->
          test "originatedOnServer: true >>> resolved" -> newRequest(originatedOnServer: true).requireServerOrigin()
          test "originatedOnServer: false >>> clientFailureNotAuthorized" -> assert.clientFailureNotAuthorized newRequest().requireServerOrigin()

        requireServerOriginIf: ->
          test "true,   originatedOnServer: true >>> resolved" -> newRequest(originatedOnServer: true).requireServerOriginIf true
          test "false,  originatedOnServer: true >>> resolved" -> newRequest(originatedOnServer: true).requireServerOriginIf false
          test "true,   originatedOnServer: false >>> clientFailureNotAuthorized" -> assert.clientFailureNotAuthorized newRequest().requireServerOriginIf true
          test "false,  originatedOnServer: false >>> resolved" -> newRequest().requireServerOriginIf false

          test "Promise.resolve(true ),  originatedOnServer: true >>> resolved" -> newRequest(originatedOnServer: true).requireServerOriginIf       Promise.resolve true
          test "Promise.resolve(false),  originatedOnServer: true >>> resolved" -> newRequest(originatedOnServer: true).requireServerOriginIf       Promise.resolve false
          test "Promise.resolve(true ),  originatedOnServer: false >>> clientFailureNotAuthorized" -> assert.clientFailureNotAuthorized newRequest().requireServerOriginIf  Promise.resolve true
          test "Promise.resolve(false),  originatedOnServer: false >>> resolved" -> newRequest().requireServerOriginIf                              Promise.resolve false

          test "-> not invoked, originatedOnServer: true >>> resolved" ->
            wasInvoked = false
            newRequest originatedOnServer: true
            .requireServerOriginIf -> wasInvoked = true
            .then -> assert.false wasInvoked

        requireServerOriginOr: ->
          test "true,   originatedOnServer: true >>> resolved" -> newRequest(originatedOnServer: true).requireServerOriginOr true
          test "false,  originatedOnServer: true >>> resolved" -> newRequest(originatedOnServer: true).requireServerOriginOr false
          test "true,   originatedOnServer: false >>> resolved" -> newRequest().requireServerOriginOr true
          test "false,  originatedOnServer: false >>> clientFailureNotAuthorized" -> assert.clientFailureNotAuthorized newRequest().requireServerOriginOr false

          test "Promise.resolve(true ),  originatedOnServer: true >>> resolved" ->        newRequest(originatedOnServer: true).requireServerOriginIf  Promise.resolve true
          test "Promise.resolve(false),  originatedOnServer: true >>> resolved" ->        newRequest(originatedOnServer: true).requireServerOriginIf  Promise.resolve false
          test "Promise.resolve(true ),  originatedOnServer: false >>> clientFailureNotAuthorized" ->  assert.clientFailureNotAuthorized newRequest().requireServerOriginIf   Promise.resolve true
          test "Promise.resolve(false),  originatedOnServer: false >>> resolved" ->       newRequest().requireServerOriginIf                          Promise.resolve false

          test "-> not invoked, originatedOnServer: true >>> resolved" ->
            wasInvoked = false
            newRequest originatedOnServer: true
            .requireServerOriginOr -> wasInvoked = true
            .then -> assert.false wasInvoked

  requests:
    props: ->
      test "new Request key and data set via props:", ->

        assert.selectedPropsEq
          # via getters
          key:    "123"
          data:   "abc"
          props:  props = key: "123", data: "abc"

          new Request
            type:   "get"
            props:
              key:    "123"
              data:   "abc"
            session:  {}
            pipeline: new Pipeline

      test "new Request props: myProp: 987", ->

        assert.selectedPropsEq
          # via getters
          key:    undefined
          data:   undefined
          props:  myProp: 987

          new Request
            type:     "get"
            props:    myProp: 987
            session:  {}
            pipeline: new Pipeline

      test "new Request key: and data: are merged into props:", ->

        assert.selectedPropsEq
          # via getters
          key:    "123"
          data:   "abc"
          props:  props = key: "123", data: "abc", customProp: "xyz"

          # direct reads
          _key:   undefined
          _data:  undefined
          _props: props

          new Request
            type:   "get"
            key:    "123"
            data:   "abc"
            props:  customProp: "xyz"
            session:  {}
            pipeline: new Pipeline

      test "remoteRequest prop", ->
        r = new Request {}
          type: :get
          pipeline: new Pipeline
          session:  {}
          remoteRequest = :myRemoteRequest
        assert.eq r.remoteRequest, remoteRequest
        r.withData :foo
        .then (r2) ->
          assert.neq r, r2
          assert.eq r2.data, :foo
          assert.eq r2.remoteRequest, remoteRequest

    validation:
      "valid new Request": ->
        test "type: 'get'", ->
          new Request
            type: "get"
            key: "123"
            pipeline: new Pipeline
            session: {}

        test "type: 'create'", ->
          new Request
            type: "create"
            pipeline: new Pipeline
            session: {}

        test "type: 'update'", ->
          new Request
            type: "update"
            key: "123"
            pipeline: new Pipeline
            session: {}

        test "type: 'delete'", ->
          new Request
            type: "delete"
            key: "123"
            pipeline: new Pipeline
            session: {}

      "invalid new Request": ->
        test "missing everything", ->
          assert.throws -> new Request

        test "missing session", ->
          assert.throws ->
            new Request
              type: "get"
              key: "123"
              pipeline: new Pipeline

        test "key: {}", ->
          assert.throws ->
            new Request
              session: {}
              type: "get"
              key: {}
              pipeline: new Pipeline

        test "props: key: {}", ->
          assert.throws ->
            new Request
              session: {}
              type: "get"
              props: key: {}
              pipeline: new Pipeline

    properties: ->
      test "getKey", ->
        request = new Request
          type: "get"
          pipeline: new Pipeline
          session: {}
          props: key: "123"
        assert.eq request.getKey(), "123"

      test "getRequestType alias for getType", ->
        request = new Request
          type: "get"
          pipeline: new Pipeline
          session: {}
        assert.eq request.getRequestType(), "get"
        assert.eq request.getType(), "get"

    withData: ->
      test "withData", ->
        request = new Request
          type: "create"
          pipeline: new Pipeline
          session: {}
          data: {}
        request.withData foo: "bar"
        .then (newRequest) ->
          assert.neq newRequest, request
          assert.eq newRequest.data, foo: "bar"

      test "withMergedData", ->
        request = new Request
          type: "create"
          pipeline: new Pipeline
          session: {}
          data: bing: "bong"
        request.withMergedData foo: "bar"
        .then (newRequest) ->
          assert.neq newRequest, request
          assert.eq newRequest.data, bing: "bong", foo: "bar"

    derivedRequestsPersistProps: ->
      test "originatedOnServer", ->
        request = new Request
          type: "get"
          key: "123"
          originatedOnServer: true
          pipeline: new Pipeline
          session: {}

        request.withData({}).then (derivedRequest) ->
          assert.selectedPropsEq
            originatedOnServer: true
            type:     "get"
            key:      "123"
            pipeline: request.pipeline
            derivedRequest

    context:

      "is identical after": ->
        test "request cloning", ->
          request = newRequest()
          {context} = request
          request.withMergedData user: "alice"
          .then (request) ->
            assert.same context, request.context

        test "response generation", ->
          request = newRequest()
          {context} = request
          request.success()
          .then (response) ->
            assert.same context, response.context

        test "subrequests-form-A", ->
          class MyPipeline extends Pipeline

          request = newRequest()
          {context} = request
          subrequest = request.createSubRequest "myPipeline", "get"
          assert.same context, subrequest.context

    subrequests: ->
      subrequestPipeline = null

      subrequestHandlers =
        form1: (request) -> subrequestPipeline.bar request, {} request.props
        form2: (request) -> subrequestPipeline.bar request, request.key, props: objectWithout request.props,             :key
        form3: (request) -> request.subrequest :subrequestPipeline :bar {} request.props
        form4: (request) -> request.subrequest :subrequestPipeline :bar request.key, props: objectWithout request.props, :key
        form5: (request) -> subrequestPipeline.bar request

      subrequestCompatibleHandlers =
        compatibleForm1: (request) -> subrequestPipeline.bar null, {} request.props
        compatibleForm2: (request) -> subrequestPipeline.bar null, request.key, props: objectWithout request.props,             :key

      beforeEach ->
        {subrequestPipeline} = class SubrequestPipeline extends Pipeline
          @handlers handlers = merge
            subrequestHandlers
            subrequestCompatibleHandlers
            bar: (request) -> merge request.props, isSubrequest: !!request.parentRequest
          @publicRequestTypes "HOWHOW", Object.keys handlers

      key = "myKey"
      props = prop1: "propValue1"

      each _, k in subrequestHandlers
        test "subrequests #{k}", ->
          subrequestPipeline[k] key, {} props
          .then (data) -> assert.eq
            data
            merge props, {} key, isSubrequest: true

      each _, k in subrequestCompatibleHandlers
        test "subrequestCompatible #{k}", ->
          subrequestPipeline[k] key, {} props
          .then (data) ->
            assert.eq
              data
              merge props, {} key, isSubrequest: false

    ## compoundKeys: ->
      class MyCompoundKeyPipe extends KeyFieldsMixin Pipeline
        @keyFields "userId/postId"

      newCompoundKeyRequest = (options) ->
        new Request merge
          type:   "get"
          pipeline: new MyCompoundKeyPipe
          session: {}
          options

      request = null
      beforeEach ->
        request = newCompoundKeyRequest
          key: userId: "userAbc", postId: "postXyz"
          data: followerCount: 123

      test "key", -> assert.eq request.key, "userAbc/postXyz"
      test "keyObject", -> assert.eq request.keyObject, userId: "userAbc", postId: "postXyz"
      test "requestDataWithKey", -> assert.eq request.requestDataWithKey, userId: "userAbc", postId: "postXyz", followerCount: 123


    "key and data alias priorities": ->
      test "key: foo has priority over props: key: bar", ->
        assert.eq "aliasKey", (newRequest key: "aliasKey").key
        assert.eq "propsKey", (newRequest props: key: "propsKey").key
        assert.eq "aliasKey", (newRequest key: "aliasKey", props: key: "propsKey").key

      test "data: foo: 123 has priority over props: data: foo: 456", ->
        aliasData = aliasData: 123
        propsData = propsData: 123
        assert.eq aliasData, (newRequest data: aliasData).data
        assert.eq propsData, (newRequest props: data: propsData).data
        assert.eq aliasData, (newRequest data: aliasData, props: data: propsData).data

    withProps:
      withoutAliases: ->
        test "withProps", ->
          request = newRequest props: foo: 1
          request.withProps bar: 2
          .then (newRequest) ->
            assert.neq newRequest, request
            assert.eq newRequest.props, bar: 2

        test "withMergedProps", ->
          request = newRequest props: foo: 1
          request.withMergedProps bar: 2
          .then (newRequest) ->
            assert.neq newRequest, request
            assert.eq newRequest.props, foo: 1, bar: 2

      withAliases: ->
        test "withProps replaces aliases even if not explicitly set", ->
          request = newRequest key: "myKey", data: {myField: 1}, props: foo: 1
          request.withProps bar: 2
          .then (newRequest) ->
            assert.neq newRequest, request
            assert.eq newRequest.key,   undefined
            assert.eq newRequest.data,  undefined
            assert.eq newRequest.props, bar: 2

        test "withProps replace aliases", ->
          request = newRequest key: "myKey", data: {myField: 1}, props: foo: 1
          request.withProps bar: 2, key: "myKey2", data: {myField2: 2}
          .then (newRequest) ->
            assert.neq newRequest, request
            assert.eq newRequest.key,   "myKey2"
            assert.eq newRequest.data,  {myField2: 2}
            assert.eq newRequest.props, bar: 2, key: "myKey2", data: {myField2: 2}

        test "withMergedProps does not replace aliases even if not explicitly set", ->
          request = newRequest key: "myKey", data: {myField: 1}, props: foo: 1
          request.withMergedProps bar: 2
          .then (newRequest) ->
            assert.neq newRequest, request
            assert.eq newRequest.key,   request.key
            assert.eq newRequest.data,  request.data
            assert.eq newRequest.props, foo: 1, bar: 2, key: "myKey", data: myField: 1

        test "withMergedProps replace aliases", ->
          request = newRequest key: "myKey", data: {myField: 1}, props: foo: 1
          request.withMergedProps bar: 2, key: "myKey2", data: {myField2: 2}
          .then (newRequest) ->
            assert.neq newRequest, request
            assert.eq newRequest.key,   "myKey2"
            assert.eq newRequest.data,  {myField2: 2}
            assert.eq newRequest.props, foo: 1, bar: 2, key: "myKey2", data: {myField2: 2}

    requestTrace: ->
      test "requestTrace depth 1" ->
        {myRt} = class MyRt extends Pipeline

          @publicHandlers
            myHandler: (request) ->
              request.requestTrace

        myRt.myHandler()
        .then (requestTrace) ->
          assert.isArray requestTrace
          assert.selectedEq
            length: 1
            requestTrace
          assert.selectedEq
            request: :myRt.myHandler
            requestTrace[0]
          # assert.selectedEq
          #   name: :myHandler-handler
          #   requestTrace[0].lastFilter

      test "requestTrace depth 2" ->
        {myRt2} = class MyRt2 extends Pipeline

          @publicHandlers
            outterRequest: (request) ->
              myRt2.innerRequest request

            innerRequest: (request) -> request.requestTrace

        myRt2.outterRequest key: randomString()

  responses:
      "new Request validation":
        invalid: ->
          test "without request or status ", ->
            assert.throws -> new Request {}

          test "without status", ->
            assert.throws -> new Request request: newRequest()

          test "without request", ->
            assert.throws -> new Request status: success

          test "props is not an object", ->
            assert.throws -> new Request
              props: 123
              status: success
              request: newRequest()

          test "invalid status", ->
            assert.throws -> new Request
              status: "dode"
              request: newRequest()

          test "invalid session", ->
            assert.throws -> newResponse session: 123

        valid: ->

          test "status: success", ->
            new Request
              status: success
              request: newRequest()

          test "status: failure", ->
            new Request
              status: failure
              request: newRequest()

          test "status: missing", ->
            new Request
              status: missing
              request: newRequest()

      getters: ->
        test "request", -> assert.instanceof Request, newResponse().request
        test "requestData",   -> r = newResponse(props: foo: 1, data: bar: 2); assert.equal r.request.data, r.requestData
        test "requestProps",  -> r = newResponse(props: foo: 1, data: bar: 2); assert.equal r.request.props, r.requestProps
        test "responseProps", -> r = newResponse(props: foo: 1, data: bar: 2); assert.equal r.props, r.responseProps; assert.neq r.props, r.requestProps
        test "responseData",  -> r = newResponse(props: foo: 1, data: bar: 2); assert.equal r.data,  r.responseData;  assert.neq r.data, r.requestData
        test "parentRequest", -> assert.eq undefined, newResponse().parentRequest
        test "rootRequest", ->
          response = newResponse()
          assert.eq response.request, response.rootRequest

      props: ->
        test "props defaults to {}", ->
          assert.selectedPropsEq
            props: {}
            new Request
              status: success
              request: newRequest()

        test "props: myProp: 123", ->
          assert.selectedPropsEq
            props: myProp: 123
            new Request
              status: success
              props: myProp: 123
              request: newRequest()

        test "data: 123 sets props", ->
          assert.selectedPropsEq
            props: data: 123
            _data: undefined
            data: 123

            new Request
              status: success
              data: 123
              request: newRequest()

        test "data: 123, props: data: 456 - data-outside-props-has-priority", ->
          assert.selectedPropsEq
            props: data: 123

            new Request
              status: success
              data: 123
              props: data: 456
              request: newRequest()

      plainObjectsResponse: ->
        test "basic", ->
          assert.selectedEq
            status: "success"
            newResponse().plainObjectsResponse

        test "data: 123", ->
          assert.selectedEq
            status: "success"
            props: data: 123
            newResponse(data: 123).plainObjectsResponse

        test "session: 123", ->
          assert.selectedEq
            status: "success"
            session: userId: "abc123"
            newResponse(session: userId: "abc123").plainObjectsResponse

        test "props: foo: 123", ->
          assert.selectedEq
            status: "success"
            props: foo: 123
            newResponse(props: foo: 123).plainObjectsResponse

      withTransformedRecords:
        oneRecord: ->
          test "success" ->
            newResponse data: foo: :bar, id: :xyz
            .withTransformedRecords (record) ->
              merge record, baz: :bam
            .then (response) ->
              assert.eq response.status, success
              assert.eq response.data, foo: "bar", baz: "bam", id: :xyz

          test "using when and with: only transforms if id is present API1" ->
            newResponse data: foo: :bar
            .withTransformedRecords
              with: (record) -> merge record, baz: :bam
              # default when uses isRecord - which tests for id? by default
            .then (response) ->
              assert.eq response.status, success
              assert.eq response.data, foo: "bar"

          test "using when and with: only transforms if id is present API2" ->
            newResponse data: foo: :bar
            .withTransformedRecords
              with: (record) -> merge record, baz: :bam
              when: ({id}) -> id?
            .then (response) ->
              assert.eq response.status, success
              assert.eq response.data, foo: "bar"

          test "using when and with: only transforms if id is present API3" ->
            newResponse data: foo: :bar
            .withTransformedRecords
              (record) -> merge record, baz: :bam
              (record) -> record?.id?

            .then (response) ->
              assert.eq response.status, success
              assert.eq response.data, foo: "bar"

          test "null" ->
            newResponse data: foo: :bar, id: :xyz
            .withTransformedRecords (record) -> null
            .then (response) ->
              assert.eq response.status, missing

          test "clientFailure" ->
            newResponse data: foo: :bar, id: :xyz
            .withTransformedRecords (record, response) -> response.clientFailure()
            .then (response) ->
              assert.eq response.status, clientFailure

          test "clientFailureNotAuthorized" ->
            newResponse data: foo: :bar, id: :xyz
            .withTransformedRecords (record, response) -> response.clientFailureNotAuthorized()
            .then (response) ->
              assert.eq response.status, clientFailureNotAuthorized

        manyRecords: ->
          test "success" ->
            newResponse data: []
              id: 123 name: :shane
              id: 456 name: :george
            .withTransformedRecords (record) ->
              merge record, baz: :bam
            .then (response) ->
              assert.eq response.status, success
              assert.eq response.data, []
                id: 123, name: "shane",  baz: "bam"
                id: 456, name: "george", baz: "bam"

          test "null" ->
            newResponse data: []
              id: 123 name: :shane
              id: 456 name: :george
              id: 789 name: :bob
            .withTransformedRecords (record) ->
              record if record.name != :george
            .then (response) ->
              assert.eq response.status, success
              assert.eq response.data, []
                id: 123 name: "shane"
                id: 789 name: :bob

          test "clientFailure" ->
            newResponse data: []
              id: 123 name: :shane
              id: 456 name: :george
              id: 789 name: :bob
            .withTransformedRecords (record, response) ->
              if record.name != :george
                record
              else
                newResponse status: clientFailure
            .then (response) ->
              assert.eq response.status, success
              assert.eq response.data, []
                id: 123 name: "shane"
                id: 789 name: :bob

          test "clientFailureNotAuthorized" ->
            newResponse data: []
              id: 123 name: :shane
              id: 456 name: :george
              id: 789 name: :bob
            .withTransformedRecords (record, response) ->
              if record.name != :george
                record
              else
                newResponse status: clientFailureNotAuthorized
            .then (response) ->
              assert.eq response.status, success
              assert.eq response.data, []
                id: 123 name: "shane"
                id: 789 name: :bob

          test "serverFailure" ->
            newResponse data: []
              id: 123 name: :shane
              id: 456 name: :george
              id: 789 name: :bob
            .withTransformedRecords (record, response) ->
              if record.name != :george
                record
              else
                newResponse status: serverFailure
            .then (response) ->
              assert.eq response.status, serverFailure

        nonRecords: ->
          test "success" ->
            newResponse data: null
            .withTransformedRecords (record) ->
              merge record, baz: :bam
            .then (response) ->
              assert.eq response.status, success
              assert.ok !response.data?


  stringify: ->
    test "json" ->
      request = newRequest props: foo: 1
      assert.eq
        JSON.stringify request
        JSON.stringify request.inspectedObjects
      assert.eq
        JSON.stringify request.pipeline
        JSON.stringify request.pipeline.inspectedObjects

    # uncomment this and run JEST - this should produce a nice error
    # test "json and errors and jest" ->
    #   newRequest props: foo: 1
    #   .failure "something happened"
    #   .then (request) -> request.toPromise()
