import &StandardImport

&ArtConfig.configure()

describe
  trueDefault: ->
    test "in tests, server is the default" ->
      {myPipeline} = class MyPipeline extends Pipeline
        @registry new PipelineRegistry
        @publicHandler get: (request) -> "#{request.location}-handler"

      myPipeline.get :bar
      .then (data) -> assert.eq data, :server-handler

  defaultLocation_client: ->
    {myPipeline} = class MyPipeline extends Pipeline
      @registry new PipelineRegistry defaultLocation: :client
      @filter name: :server-filter location: :server after: get: ({data}) -> "#{data}/server-filter"
      @filter name: :client-filter location: :client after: get: ({data}) -> "#{data}/client-filter"

      @publicHandler get: (request) -> "#{request.location}-handler"

    test "client (default)" ->
      myPipeline.get :bar
      .then (data) -> assert.eq data, :client-handler/client-filter

    test "server (override)" ->
      myPipeline.get :bar location: :server
      .then (data) -> assert.eq data, :server-handler/server-filter

  clientAndServerHandlers: ->
    test "we can fake a client-side-only handler using a client-side only before-filter" ->
      {myPipeline} = class MyPipeline extends Pipeline
        @registry new PipelineRegistry defaultLocation: :client
        @filter name: :client-filter-handler location: :client before: get: ({data}) -> "#{data}client-filter-handler"
        @filter name: :server-filter location: :server after: get: ({data}) -> "#{data}/server-filter"
        @filter name: :client-filter location: :client after: get: ({data}) -> "#{data}/client-filter"

        @publicHandler get: (request) -> "#{request.location}-handler"

      Promise.all []
        myPipeline.get :bar
        .then (data) -> assert.eq data, :client-filter-handler/client-filter

        myPipeline.get :bar location: :server
        .then (data) -> assert.eq data, :server-handler/server-filter

    test "now, what if the client-side handler fires off a server-side request - faking like it's a remote request?" ->
      class BothMode extends Filter
        @location :client
        @group :handler
        @before all: (request) ->
          request.pipeline.get request.key, {}
            location:       :server
            props:          JSON.parse JSON.stringify request.props
            returnResponse: true
            remoteRequest:  request
            request.filterLog

          .then  (remoteResponse) ->
            request.toResponse
              if isFailure remoteResponse.status then :serverFailure
              else remoteResponse.status
              {}
                remoteResponse
                remoteResponse.remoteRequest
                remoteResponse.filterLog
                props: JSON.parse JSON.stringify remoteResponse.props

      {myPipeline} = class MyPipeline extends Pipeline
        @registry new PipelineRegistry defaultLocation: :client

        @filter name: :server-filter location: :server after: get: ({data}) -> "#{data}/server-filter"
        @filter name: :client-filter location: :client after: get: ({data}) -> "#{data}/client-filter"

        @filter BothMode

        @publicHandler
          get: (request) -> "#{request.data}/#{request.location}-handler"

      Promise.all []
        myPipeline.get :bar data: :requestData
        .then (data) -> assert.eq data, :requestData/server-handler/server-filter/client-filter

        myPipeline.get :bar  data: :requestData location: :server
        .then (data) -> assert.eq data, :requestData/server-handler/server-filter
