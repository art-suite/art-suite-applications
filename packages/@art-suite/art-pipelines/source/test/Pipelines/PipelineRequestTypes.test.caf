import &StandardImport, &ArtValidation

# eqAfterStringifyingFunctionsR = (a, b) ->
#   switch
#   when isObject a then
#     isObject b
#     && eq Object.keys(a).sort(), Object.keys(b).sort()
#     && !find v, k in a when !eqAfterStringifyingFunctionsR v, b[k]
#   when isArray a then
#     isArray b
#     && a.length == b.length
#     && !find v, i in a when !eqAfterStringifyingFunctionsR v, b[i]
#   when isFunction a then
#     isFunction b
#     && "#{a}" == "#{b}"
#   else eq a, b

# assert.eqAfterStringifyingFunctions = (a, b, context) ->
#   if !equal = eqAfterStringifyingFunctionsR a, b
#     assert.eq a, b

describe
  basics: ->
    chainedTest "simple" ->
      requestTypes = null
      {myPipeline} = class MyPipeline extends Pipeline
        @requestTypes requestTypes =
          getTime:
            response:   data: time: :number

      assert.eq
        myPipeline.requestTypes
        requestTypes

      myPipeline

    .thenTest "simple normalizedRequestTypes" (myPipeline) ->
      assert.eqAfterStringifyingFunctions
        myPipeline.normalizedRequestTypes
        getTime:
            response:   data: normalizeFieldProps fields: time: :number

  autodefined: ->
    test "handlers define request types" ->
      {myPipeline} = class MyPipeline extends Pipeline
        @handler rock: -> :roll

      assert.eq
        myPipeline.requestTypes
        rock: {}

    test "beforeFilters define request types and afterFilters do not" ->
      {myPipeline} = class MyPipeline extends Pipeline
        @filter
          name: :myFilter
          before: rock: -> :roll

        @filter
          name: :myOtherFilter
          after: roll: -> :rap

      assert.eq
        myPipeline.requestTypes
        rock: {}

  normalized: ->
    test "singleton data" ->
      {myPipeline} = class MyPipeline extends Pipeline
        @requestTypes
          getTime:
            response:   data: :number

      assert.eqAfterStringifyingFunctions
        myPipeline.normalizedRequestTypes
        getTime: response: data: normalizeFieldProps :number

    test ":record data" ->
      requestTypes = null
      {myPipeline} = class MyPipeline extends Pipeline
        @fields
          name: :string

        @requestTypes requestTypes =
          getTime:
            response:   data: :record

      assert.eq
        myPipeline.requestTypes
        requestTypes

      assert.eqAfterStringifyingFunctions
        myPipeline.normalizedRequestTypes
        getTime: response: data: merge
          normalizeFieldProps {} myPipeline.fields
          fieldType: :record

##
  filters: ->
    test "filters can define request-types" ->
      requestTypes = null
      class CrudFilter extends Filter
        @requestTypes requestTypes =
          get:
            request:    key:  true
            response:   data: :record

          create:
            request:    data: :record
            response:   key:  true    data: :record

          update:
            request:    key:  true    data: :record
            response:   data: :record

          delete:
            request:    key:  true
            response:   data: :record

      pipelineRequestTypes = null
      {myUser} = class MyUser extends Pipeline
        @filter CrudFilter
        @field
          otherId:  :string
          age:      :number

        @requestType pipelineRequestTypes =
          customRequestType: request: data: :string
          get: request: {}, response: data: :record # should not be overridden by the filter

          userBySimpleQuery:
            request:    key:  :string
            response:   data: array: :record

          userByOtherId:
            request:    key:  otherId: :string
            response:   data: array: :record

          userByMultiSearch:
            request:
              # keyFields:  :keyword :age
              key:
                keyword:  :string
                :age

            response:   data: array: :record

      assert.eq
        myUser.requestTypes
        merge requestTypes, pipelineRequestTypes