// Generated by CoffeeScript 1.12.7
(function() {
  var ArtModel, BaseObject, ErrorWithInfo, InstanceFunctionBindingMixin, ModelRegistry, Promise, compactFlatten, decapitalize, defineModule, failure, formattedInspect, isFailure, isPlainObject, isString, log, merge, missing, modelStore, pending, ref, ref1, success, validStatus,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  ref = require("art-standard-lib"), log = ref.log, decapitalize = ref.decapitalize, merge = ref.merge, isString = ref.isString, compactFlatten = ref.compactFlatten, Promise = ref.Promise, formattedInspect = ref.formattedInspect, isPlainObject = ref.isPlainObject, ErrorWithInfo = ref.ErrorWithInfo, defineModule = ref.defineModule;

  BaseObject = require('art-class-system').BaseObject;

  InstanceFunctionBindingMixin = require("@art-suite/instance-function-binding-mixin").InstanceFunctionBindingMixin;

  ref1 = require('art-communication-status'), missing = ref1.missing, success = ref1.success, pending = ref1.pending, failure = ref1.failure, validStatus = ref1.validStatus, isFailure = ref1.isFailure;

  modelStore = require("./ModelStore").modelStore;

  ModelRegistry = require('./ModelRegistry');

  defineModule(module, ArtModel = (function(superClass) {
    extend(ArtModel, superClass);

    ArtModel.abstractClass();

    ArtModel.declarable({
      staleDataReloadSeconds: null,
      minNetworkFailureReloadSeconds: null,
      maxNetworkFailureReloadSeconds: 2e308,
      minServerFailureReloadSeconds: null,
      maxServerFailureReloadSeconds: 2e308
    });

    ArtModel.getter({
      autoReloadEnabled: function() {
        return this.getStaleDataReloadSeconds() > 0 || this.getMinNetworkFailureReloadSeconds() > 0 || this.getMinServerFailureReloadSeconds() > 0;
      }
    });

    ArtModel.register = function() {
      this.singletonClass();
      return ModelRegistry.register(this.getSingleton());
    };

    ArtModel.postCreateConcreteClass = function(arg) {
      var hotReloaded;
      hotReloaded = arg.hotReloaded;
      if (hotReloaded) {
        this.singleton.bindFunctionsToInstance();
      } else {
        this.register();
      }
      return ArtModel.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
    };


    /*
      INPUT: zero or more strings or arrays of strings
        - arbitrary nesting of arrays is OK
        - nulls are OK, they are ignored
      OUTPUT: null
    
      NOTE: @aliases can be called multiple times.
    
      example:
        class Post extends ArtModel
          @aliases "chapterPost"
    
      purpose:
        - declare alternative names to access this model.
        - allows you to use the shortest form of Components subscriptions for each alias:
            @subscriptions "chapterPost"
          in addition to the model's class name:
            @subscriptions "post"
     */

    ArtModel.aliases = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this._aliases = compactFlatten([args, this._aliases]);
      return null;
    };

    ArtModel._aliases = [];

    ArtModel.prototype.onNextReady = function(f) {
      return modelStore.onNextReady(f);
    };

    function ArtModel(name) {
      ArtModel.__super__.constructor.apply(this, arguments);
      this._name = name || decapitalize(this["class"].getName());
      this.bindFunctionsToInstance();
      this._activeLoadingRequests = {};
    }

    ArtModel.classGetter({
      models: function() {
        return ModelRegistry.models;
      },
      modelStore: function() {
        return modelStore;
      }
    });

    ArtModel.getter({
      models: function() {
        return ModelRegistry.models;
      },
      modelStore: function() {
        return modelStore;
      },
      singlesModel: function() {
        return this._singlesModel || this;
      },
      modelStoreEntries: function() {
        return modelStore.getEntriesForModel(this.name);
      }
    });

    ArtModel.prototype.subscribe = function(modelKey, subscriptionFunction) {
      log.error("DEPRICATED - use ModelSubscriptionsMixin and it's subscribe");
      return modelStore.subscribe(this._name, modelKey, subscriptionFunction);
    };

    ArtModel.getter("name", {
      modelName: function() {
        return this._name;
      }
    });


    /* load:
      load the requested data for the given key and update the modelStore
    
      required:
        Should ALWAYS call modelStore.update immediately OR once the data is available.
        Clients will assume that a call to "load" forces a reload of the data in the modelStore.
    
      optional:
        If the data is immediately available, you can return the modelRecord instead of "null"
        If load was called because of a new Component being mounted and its subscriptions initialized,
          returning the modelRecord immediately will guarantee the Component has valid data for its
          first render.
    
      Note:
        Typically called automatically by the modelStore when a Component subscribes to
        data from this model with the given key.
    
      The simplest possible load function:
        load: (key) -> @updateModelRecord key, {}
    
      The "load" function below is:
        Simplest "load" with immediate modelRecord return.
        Immediate return means:
        - modelStore.subscribe() will return the modelRecord returned from this "load"
        - Components subscriptions will update state in time for the inital render.
    
      inputs:
        key: string
    
      side effects:
        expected to call modelStore.update @_name, key, modelRecord
          - when modelRecord.status is no longer pending
          - optionally as progress is made loading the modelRecord.data
    
      returns: null OR modelRecord if the value is immediately available
        NOTE: load can return null or modelRecord as it chooses. The client shouldn't
          rely on the fact that it returned a modelRecord with a set of inputs, it might not
          the next time.
    
      Optionally, you can implement one of two altenative load functions with Promise support:
    
        loadData:       (key) ->
                          promise.then (data) ->
                            if data is null or undefined, status will be set to missing
                            otherwise, status will be success
                          promise.catch (a validStatus or error info, status becomes failure) ->
        loadModelRecord: (key) -> promise.then (modelRecord) ->
    
        @load will take care of updating ModelStore.
     */

    ArtModel.prototype.load = function(key) {
      if (this.loadData || this.loadModelRecord) {
        this.loadPromise(key);
        return null;
      } else {
        return this.updateModelRecord(key, {
          status: missing
        });
      }
    };


    /* loadPromise:
      NOTE: @loadData or @loadModelRecord should be implemented.
      @loadPromise is an alternative to @load
    
      Unlike @load, @loadPromise returns a promise that resolves when the load is done.
    
      The down-side is @loadPromise cannot immediately update the ModelStore. If you have
      a model which stores its data locally, like ApplicationState, then override @load
      for immediate modelStore updates.
    
      However, if your model always has to get the data asynchronously, override @loadData
      or @loadModelRecord and use @loadPromise anytime you need to manually trigger a load.
    
      EFFECTS:
      - Triggers loadData or loadModelRecord.
      - Puts the results in the modelStore.
      - Elegently reduces multiple in-flight requests with the same key to one Promise.
        @loadData or @loadModelRecord will only be invoked once per key while their
        returned promises are unresolved.
        NOTE: the block actually extends all the way through to the modelStore being updated.
        That means you can immediately call @getModelRecord and get the latest data - when
        the promise resolves.
    
      OUT: promise.then (modelRecord) ->
        modelRecord: the latest, just-loaded data
        ERRORS: errors are encoded into the modelRecord. The promise should always resolve.
     */

    ArtModel.prototype.loadPromise = function(key) {
      var p;
      if (p = this._activeLoadingRequests[key]) {
        return p;
      }
      p = this.loadData ? Promise.then((function(_this) {
        return function() {
          return _this.loadingRecord(key);
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.loadData(key);
        };
      })(this)).then((function(_this) {
        return function(data) {
          return _this.updateModelRecord(key, data != null ? {
            data: data,
            status: success
          } : {
            status: missing
          });
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          var info, ref2, status;
          status = validStatus(status = (error != null ? (ref2 = error.info) != null ? ref2.status : void 0 : void 0) || error) ? status : failure;
          info = error != null ? error.info : void 0;
          if (!(error instanceof Error)) {
            error = null;
          }
          return _this.updateModelRecord(key, {
            status: status,
            info: info,
            error: error
          });
        };
      })(this)) : this.loadModelRecord ? this.loadModelRecord(key).then((function(_this) {
        return function(modelRecord) {
          return _this.updateModelRecord(key, modelRecord);
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          return _this.updateModelRecord(key, {
            status: failure,
            error: error
          });
        };
      })(this)) : Promise.resolve(this.updateModelRecord(key, {
        status: missing
      }));
      return this._activeLoadingRequests[key] = p.then((function(_this) {
        return function(result) {
          _this.onNextReady();
          return result;
        };
      })(this)).then((function(_this) {
        return function(result) {
          _this._activeLoadingRequests[key] = null;
          return result;
        };
      })(this));
    };

    ArtModel.prototype.reload = function(key) {
      if (this.loadData || this.loadModelRecord) {
        return this.loadPromise(key);
      } else {
        return this.load(key);
      }
    };

    ArtModel.prototype.loadingRecord = function(key) {
      var modelRecord, ref2;
      if (isFailure((ref2 = (modelRecord = this.getModelRecord(key))) != null ? ref2.status : void 0)) {
        return this.updateModelRecord(key, merge(modelRecord, {
          status: pending
        }));
      }
    };

    ArtModel.prototype.getModelRecord = function(key) {
      return modelStore.get(this._name, this.toKeyString(key));
    };

    ArtModel.prototype.updateModelRecord = function(key, modelRecord) {
      return modelStore.update(this._name, key, modelRecord);
    };

    ArtModel.prototype.onModelRegistered = function(modelName) {
      return ModelRegistry.onModelRegistered(modelName);
    };

    ArtModel.prototype.get = function(key) {
      key = this.toKeyString(key);
      return Promise.then((function(_this) {
        return function() {
          var currentModelRecord, ref2;
          if (((ref2 = (currentModelRecord = _this.getModelRecord(key))) != null ? ref2.status : void 0) === pending) {
            currentModelRecord = null;
          }
          return currentModelRecord != null ? currentModelRecord : _this.loadPromise(key);
        };
      })(this)).then(function(modelRecord) {
        var data, status;
        status = modelRecord.status, data = modelRecord.data;
        if (status !== success) {
          throw new ErrorWithInfo("ArtModel#get: Error getting data. Status: " + status + ".", {
            status: status,
            modelRecord: modelRecord
          });
        }
        return data;
      });
    };

    ArtModel.prototype.toKeyString = function(key) {
      if (isPlainObject(key)) {
        return this.dataToKeyString(key);
      } else if (isString(key)) {
        return key;
      } else {
        throw new Error("ArtModel " + this.name + ": Must implement custom toKeyString for non-string keys like: " + (formattedInspect(key)));
      }
    };

    ArtModel.prototype.dataToKeyString = function(obj) {
      throw new Error("ArtModel " + this.name + ": must override dataToKeyString for converting objects to key-strings.");
    };

    ArtModel.getRecordPropsToKeyFunction = function(recordType) {
      return (function(_this) {
        return function(props, stateField) {
          var propsField, ref2, ref3;
          propsField = stateField != null ? stateField : recordType;
          return (ref2 = (ref3 = props[propsField]) != null ? ref3.id : void 0) != null ? ref2 : props[propsField + "Id"];
        };
      })(this);
    };

    ArtModel.getter({
      propsToKey: function() {
        return this._propsToKey != null ? this._propsToKey : this._propsToKey = ArtModel.getRecordPropsToKeyFunction(this.modelName);
      }
    });

    ArtModel.prototype.modelStoreEntryUpdated = function(entry) {};

    ArtModel.prototype.modelStoreEntryAdded = function(entry) {};

    ArtModel.prototype.modelStoreEntryRemoved = function(entry) {};

    ArtModel.prototype.modelRegistered = function() {};

    return ArtModel;

  })(InstanceFunctionBindingMixin(BaseObject)));

}).call(this);

//# sourceMappingURL=ArtModel.js.map
