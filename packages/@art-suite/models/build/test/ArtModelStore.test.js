"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "_resetArtSuiteModels", "ArtModel", "assert", "models", "test", "chainedTest", "artModelStore", "pending", "merge", "Promise", "missing"], [global, require('./StandardImport')], (describe, _resetArtSuiteModels, ArtModel, assert, models, test, chainedTest, artModelStore, pending, merge, Promise, missing) => {let reset; reset = function() {return _resetArtSuiteModels().then(() => {let MyModel; MyModel = Caf.defClass(class MyModel extends ArtModel {}); return assert.eq(true, !!models.myModel, {models});});}; return describe({basic: function() {test("artModelStore.reset & length", () => reset().then(() => assert.eq(artModelStore.length, 0))); chainedTest("artModelStore.update basic", () => reset().then(() => {artModelStore.subscribe("myModel", "myKey", () => {}); artModelStore.update("myModel", "myKey", {bar: 1}); return artModelStore.onNextReady(() => {let modelRecord; assert.eq(artModelStore.length, 1); assert.selectedEq({entryCount: 1, entrySubscribers: 1, modelCount: 1}, artModelStore.status); assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, modelRecord = artModelStore.get("myModel", "myKey")); assert.isNumber(modelRecord.updatedAt); assert.isNumber(modelRecord.createdAt); return assert.lt(modelRecord.createdAt, modelRecord.updatedAt);});})).tapTest(["modelStoreEntry._getAndLogErrorMessage", () => {let logged, myLog, error, message; logged = []; myLog = (a) => logged.push(a); error = {}; message = artModelStore._entriesByModelName.myModel.myKey._getAndLogErrorMessage(error, "giggle", myLog); assert.isString(message); assert.true(Caf.in("giggle", message)); return assert.eq(logged.length, 1);}], ["artModelStore.inspectedObjects", () => {let inspectedObjects, myKey, createdAt, updatedAt; inspectedObjects = artModelStore.inspectedObjects; myKey = inspectedObjects.myModel.myKey; createdAt = myKey.createdAt; updatedAt = myKey.updatedAt; assert.isNumber(createdAt); assert.isNumber(updatedAt); return assert.eq(inspectedObjects, {myModel: {myKey: {modelName: "myModel", key: "myKey", status: "pending", createdAt, updatedAt}}});}]); test("artModelStore.update with no subscriber is noop", () => reset().then(() => {artModelStore.update("myModel", "myKey", {bar: 1}); return artModelStore.onNextReady(() => {assert.eq(artModelStore.length, 0); return assert.eq(!!artModelStore._getEntry("myModel", "myKey"), false);});})); test("artModelStore.update twice replaces old value", () => reset().then(() => {artModelStore.subscribe("myModel", "myKey", () => {}); artModelStore.update("myModel", "myKey", {bar: 1}); artModelStore.update("myModel", "myKey", {baz: 2}); return artModelStore.onNextReady(() => {assert.eq(artModelStore.length, 1); return assert.selectedEq({status: pending, baz: 2, key: "myKey", modelName: "myModel"}, artModelStore.get("myModel", "myKey"));});})); test("artModelStore.update with update function can merge", () => reset().then(() => {artModelStore.subscribe("myModel", "myKey", () => {}); artModelStore.update("myModel", "myKey", {bar: 1}); artModelStore.update("myModel", "myKey", (old) => merge(old, {baz: 2})); return artModelStore.onNextReady(() => {assert.eq(artModelStore.length, 1); return assert.selectedEq({status: pending, bar: 1, baz: 2, key: "myKey", modelName: "myModel"}, artModelStore.get("myModel", "myKey"));});})); test("artModelStore.update cant set key", () => reset().then(() => {artModelStore.subscribe("myModel", "myKey", () => {}); artModelStore.update("myModel", "myKey", {bar: 1, key: "boggle"}); return artModelStore.onNextReady(() => {assert.doesNotExist(artModelStore.get("myModel", "boggle")); return assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, artModelStore.get("myModel", "myKey"));});})); test("artModelStore.update cant update key", () => reset().then(() => {artModelStore.subscribe("myModel", "myKey", () => {}); artModelStore.update("myModel", "myKey", {bar: 1}); return artModelStore.onNextReady(() => {artModelStore.update("myModel", "myKey", {bar: 1, key: "boggle2"}); return artModelStore.onNextReady(() => assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, artModelStore.get("myModel", "myKey")));});})); test("artModelStore.subscribe basic", () => reset().then(() => new Promise((resolve) => {artModelStore.subscribe("myModel", "myKey", (modelRecord, previousModelRecord) => {assert.selectedEq({status: missing, key: "myKey", modelName: "myModel"}, previousModelRecord); assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, modelRecord); return resolve();}); return artModelStore.update("myModel", "myKey", {bar: 1});}))); test("artModelStore.unsubscribe", () => reset().then(() => {let count1, count2, subscriber1, subscriber2; count1 = 0; count2 = 0; subscriber1 = (modelRecord) => count1++; subscriber2 = (modelRecord) => count2++; artModelStore.subscribe("myModel", "myKey", subscriber1); artModelStore.subscribe("myModel", "myKey", subscriber2); artModelStore.update("myModel", "myKey", {bar: 1}); return artModelStore.onNextReady(() => {assert.eq(count1, 1); assert.eq(count2, 1); artModelStore.unsubscribe("myModel", "myKey", subscriber2); artModelStore.update("myModel", "myKey", {bar: 2}); return artModelStore.onNextReady(() => {assert.eq(count1, 2); return assert.eq(count2, 1);});});})); test("artModelStore model callbacks: modelStoreEntryUpdated, modelStoreEntryAdded, modelStoreEntryRemoved", () => new Promise((resolve) => reset().then(() => {let updateCount, addedCount, removedCount, MyModel2, mySubscription; updateCount = addedCount = removedCount = 0; MyModel2 = Caf.defClass(class MyModel2 extends ArtModel {}, function(MyModel2, classSuper, instanceSuper) {this.prototype.modelStoreEntryUpdated = function(entry) {return updateCount++;}; this.prototype.modelStoreEntryAdded = function(entry) {return addedCount++;}; this.prototype.modelStoreEntryRemoved = function(entry) {assert.eq(2, updateCount); assert.eq(1, addedCount); assert.eq(1, ++removedCount); return resolve();};}); artModelStore.subscribe("myModel2", "myKey", mySubscription = () => 123); return artModelStore.onNextReady(() => artModelStore.unsubscribe("myModel2", "myKey", mySubscription));}))); test("subscribe triggers load on model", () => reset().then(() => new Promise((resolve) => {let MyBasicModel; MyBasicModel = Caf.defClass(class MyBasicModel extends ArtModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.prototype.load = resolve;}); return artModelStore.subscribe("myBasicModel", "123", (modelRecord) => null);}))); return test("subscribe with initial value does not trigger load on model nor subscription callback", () => reset().then(() => {let MyBasicModel; MyBasicModel = Caf.defClass(class MyBasicModel extends ArtModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.prototype.load = function(key) {return assert.fail();};}); artModelStore.subscribe("myBasicModel", "123", (modelRecord) => assert.fail(), {data: {foo: 1, bar: 2}}); return artModelStore.onNextReady(() => {});}));}});});});
//# sourceMappingURL=ArtModelStore.test.js.map
