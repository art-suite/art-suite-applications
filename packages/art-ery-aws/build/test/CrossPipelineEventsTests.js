"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "chainedTest", "setupTestConfiguration", "deleteTestTables", "AfterEventsFilter", "Neptune", "DynamoDbPipeline", "Promise", "pipelines", "assert", "session", "test"], [global, require('./StandardImport')], (describe, chainedTest, setupTestConfiguration, deleteTestTables, AfterEventsFilter, Neptune, DynamoDbPipeline, Promise, pipelines, assert, session, test) => {let sharedAfterEventTests; sharedAfterEventTests = function(setupUserWith) {return chainedTest(() => {setupTestConfiguration(); return deleteTestTables().then(() => {let User, Post; AfterEventsFilter._reset(); Neptune.Art.Ery.PipelineRegistry._reset(); User = null; User = Caf.defClass(class User extends DynamoDbPipeline {}, function(User, classSuper, instanceSuper) {this.publicRequestTypes("get", "create", "update", "delete"); this.addDatabaseFilters({linkFilterVersion: 2, fields: {name: "required trimmedstring", postCount: "number", lastPostCreatedAt: "timestamp", text: "trimmedstring"}});}); setupUserWith(User); Post = Caf.defClass(class Post extends DynamoDbPipeline {}, function(Post, classSuper, instanceSuper) {this.publicRequestTypes("get", "create", "update", "delete"); this.addDatabaseFilters({linkFilterVersion: 2, userOwned: {publicFields: true, userCreatableFields: "name text postCount lastPostCreatedAt", userUpdatableFields: "name text postCount lastPostCreatedAt"}, fields: {text: "trimmedstring", createdAt: "timestamp"}});}); return Promise.all([pipelines.user._vivifyTable(), pipelines.post._vivifyTable()]).then(() => {assert.eq(AfterEventsFilter.handlers.post.create.length, 1); return assert.eq(AfterEventsFilter.handlers.post.create[0], User);});});}).thenTest("User and AfterEventsFilter properly setup", () => {;}).thenTest("create user and two posts", () => {let userId, post; userId = post = null; return pipelines.user.create({data: {name: "Bill"}}).then((user) => {let name, postCount, lastPostCreatedAt; ({name, postCount, lastPostCreatedAt, id: userId} = user); session.data = {userId}; assert.doesNotExist(lastPostCreatedAt); assert.doesNotExist(postCount); assert.eq(name, "Bill"); assert.eq(name, "Bill"); return assert.isString(userId);}).then(() => pipelines.post.create({data: {userId, text: "hi"}})).then((_post) => {post = _post; return pipelines.user.get({key: userId});}).then((user) => {let postCount, lastPostCreatedAt; ({postCount, lastPostCreatedAt} = user); assert.eq(lastPostCreatedAt, post.createdAt); return assert.eq(postCount, 1);}).then(() => pipelines.post.create({data: {userId, text: "hi"}})).then((_post) => {post = _post; return pipelines.user.get({key: userId});}).then((user) => {let postCount, lastPostCreatedAt; ({postCount, lastPostCreatedAt} = user); assert.eq(lastPostCreatedAt, post.createdAt); return assert.eq(postCount, 2);});});}; return describe({afterEvent: function() {return sharedAfterEventTests((User) => {let afterEventFunction; User.afterEvent({create: {post: afterEventFunction = (response) => Promise.then(() => {let userId, createdAt; ({userId, createdAt} = response.data); assert.eq("post", response.pipelineName); return response.subrequest("user", "update", {props: {key: userId, data: {lastPostCreatedAt: createdAt}, add: {postCount: 1}}});})}}); return assert.eq(User.getAfterEventFunctions(), {post: {create: [afterEventFunction]}});});}, updateAfter: {full: function() {return sharedAfterEventTests((User) => {let postCreateUpdateFunction; User.updateAfter({create: {post: postCreateUpdateFunction = (response) => Promise.then(() => {let userId, createdAt; ({userId, createdAt} = response.data); assert.eq("post", response.pipelineName); return {key: userId, data: {lastPostCreatedAt: createdAt}, add: {postCount: 1}};})}}); return assert.eq(User.getUpdatePropsFunctions(), {post: {create: [postCreateUpdateFunction]}});});}, _mergeUpdateProps: function() {global.beforeAll(() => {let User; AfterEventsFilter._reset(); Neptune.Art.Ery.PipelineRegistry._reset(); User = null; return User = Caf.defClass(class User extends DynamoDbPipeline {}, function(User, classSuper, instanceSuper) {this.addDatabaseFilters({linkFilterVersion: 2, fields: {name: "required trimmedstring", postCount: "number", lastPostCreatedAt: "timestamp", text: "trimmedstring"}});});}); test("basic", () => assert.eq({foo: {key: "foo", set: {bar: 123}}}, DynamoDbPipeline._mergeUpdateProps([{key: "foo", set: {bar: 123}}], "user"))); test("distinct actions for same key", () => assert.eq({foo: {key: "foo", set: {bar: 123}, setDefault: {baz: 456}}}, DynamoDbPipeline._mergeUpdateProps([{key: "foo", set: {bar: 123}}, {key: "foo", setDefault: {baz: 456}}], "user"))); test("two keys with overlapping actions", () => assert.eq({foo: {key: "foo", set: {name: "alice"}}, bar: {key: "bar", set: {name: "bill"}}}, DynamoDbPipeline._mergeUpdateProps([{key: "foo", set: {name: "alice"}}, {key: "bar", set: {name: "bill"}}], "user"))); return test("array of updates", () => assert.eq({foo: {key: "foo", set: {name: "alice", address: "123 Street"}}, bar: {key: "bar", set: {name: "bill"}}}, DynamoDbPipeline._mergeUpdateProps([[{key: "foo", set: {name: "alice"}}, {key: "bar", set: {name: "bill"}}], {key: "foo", set: {address: "123 Street"}}], "user")));}}});});});
//# sourceMappingURL=CrossPipelineEventsTests.js.map
