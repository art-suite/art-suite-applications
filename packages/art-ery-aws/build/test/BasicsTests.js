"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "deleteTestTables", "Neptune", "DynamoDbPipeline", "Promise", "Error", "chainedTest", "assert", "missing", "compactFlatten", "merge", "randomString", "pipelines", "success", "networkFailure"], [global, require('./StandardImport')], (describe, deleteTestTables, Neptune, DynamoDbPipeline, Promise, Error, chainedTest, assert, missing, compactFlatten, merge, randomString, pipelines, success, networkFailure) => {let myTable, MyTable, setupPromise, setupWithMyTable, setupWithMyTableEmptied; myTable = MyTable = null; setupPromise = null; setupWithMyTable = function() {require('art-config').configure({artConfigName: "test", artConfig: {Art: {Aws: {credentials: {accessKeyId: "test-accessKeyId", secretAccessKey: "test-secretAccessKey"}, region: "us-east-1", dynamoDb: {endpoint: "http://localhost:8081"}}, Ery: {tableNamePrefix: "art-ery-aws-test."}}}}); return setupPromise || (setupPromise = deleteTestTables().then(() => {let myCompoundKeyTable, MyCompoundKeyTable; Neptune.Art.Ery.PipelineRegistry._reset(); ({myTable} = MyTable = Caf.defClass(class MyTable extends DynamoDbPipeline {}, function(MyTable, classSuper, instanceSuper) {this.publicRequestTypes("get", "create", "update", "delete", "getAll", "batchGet"); this.addDatabaseFilters({linkFilterVersion: 2, fields: {name: "required string", email: "required email", rank: "number", attributes: "array"}}); this.publicHandlers({throwServiceUnavailable: function(request) {let numFailures, attemptCount; ({numFailures} = request.props); attemptCount = 0; return this._artEryToDynamoDbRequest(request, {then: (params) => {attemptCount++; if (numFailures >= attemptCount) {throw new Error("Service Unavailable");}; return {successfulOnAttempt: attemptCount};}});}});})); ({myCompoundKeyTable} = MyCompoundKeyTable = Caf.defClass(class MyCompoundKeyTable extends DynamoDbPipeline {}, function(MyCompoundKeyTable, classSuper, instanceSuper) {this.keyFields("userId/postId"); this.addDatabaseFilters({linkFilterVersion: 2, fields: {user: "link", post: "link"}});})); return Promise.all([myCompoundKeyTable._vivifyTable(), myTable._vivifyTable()]);}));}; setupWithMyTableEmptied = function() {return setupWithMyTable().then(() => myTable.getAll().then((users) => Caf.each2(users, (user) => myTable.delete(user.id))));}; return describe({basic: function() {return chainedTest(setupWithMyTable).softTapTest(["create then get", () => myTable.create({data: {name: "John", email: "foo@bar.com"}}).then((data) => {assert.isString(data.id); assert.isNumber(data.createdAt); assert.isNumber(data.updatedAt); return myTable.get({key: data}).then((getData) => assert.eq(getData, data));})], ["number type can create and update factional valuyes", () => myTable.create({data: {name: "John", email: "foo@bar.com", rank: .25}}).then((record) => {assert.eq(record.rank, .25, "create"); return myTable.get(record.id);}).then((record) => {assert.eq(record.rank, .25, "create-get"); return myTable.update({key: record.id, data: {rank: .75}});}).then((record) => {assert.eq(record.rank, .75, "update"); return myTable.get(record.id);}).then((record) => assert.eq(record.rank, .75, "update-get"))], ["delete", () => {let createData; createData = null; return myTable.create({data: {name: "John", email: "foo@bar.com", rank: 123, attributes: ["adventurous", "charming"]}}).then((_createData) => {createData = _createData; return myTable.delete({key: createData.id});}).then(() => assert.rejects(myTable.get({key: createData.id}))).then((expectedError) => {let response; ({response} = expectedError.info); assert.eq(response.status, missing); return "triggered catch";});}], ["describeTable", () => myTable.dynamoDb.describeTable({TableName: myTable.tableName}).then(({Table}) => assert.eq(Table.AttributeDefinitions, [{AttributeName: "id", AttributeType: "S"}]))]);}, batchedEach: function() {return chainedTest(() => setupWithMyTable()).thenTest("batchedEach", () => myTable.batchedEach((records) => assert.isArray(records)));}, scanAndBatchGet: function() {return chainedTest(setupWithMyTableEmptied).thenTest("createX2 then scan", () => Promise.all([myTable.create({data: {name: "Alice", email: "alice@gmail.com"}}), myTable.create({data: {name: "Bill", email: "bill@gmail.com"}})]).then(() => myTable.getAll()).tap((users) => {assert.eq(2, users.length); return assert.eq(["Alice", "Bill"], Caf.array(users, (user) => user.name).sort());})).thenTest("batchGet 2 records", (users) => myTable.batchGet({props: {keys: Caf.array(users, ({id}) => id)}}).then((users2) => assert.eq(users.sort((a, b) => a.id.localeCompare(b.id)), users2.sort((a, b) => a.id.localeCompare(b.id)))));}, scan: function() {return chainedTest(setupWithMyTableEmptied).thenTest("multiple pages", () => Promise.all([myTable.create({data: {name: "Alice", email: "alice@gmail.com"}}), myTable.create({data: {name: "Bill", email: "bill@gmail.com"}})]).then(() => myTable.getAll({returnResponse: true, props: {limit: 1}})).then(({props: {lastEvaluatedKey}, data: users}) => {assert.eq(1, users.length); assert.isObject(lastEvaluatedKey); return myTable.getAll({returnResponse: true, props: {lastEvaluatedKey, limit: 1}}).then(({props: {lastEvaluatedKey2}, data: users2}) => {assert.doesNotExist(lastEvaluatedKey2); return assert.eq(["Alice", "Bill"], Caf.array(compactFlatten([users, users2]), (user) => user.name).sort());});}));}, update: function() {return chainedTest(setupWithMyTable).softTapTest(["using keys", () => {let createData; createData = null; return myTable.create({data: {name: "John", email: "foo@bar.com", rank: 123, attributes: ["adventurous", "charming"]}}).then((createData) => myTable.update({key: createData.id, data: {rank: 456}}).then((updatedData) => myTable.get({key: createData.id}).then((data) => assert.eq(data, merge(createData, updatedData)))));}], ["non-existant record fails with status: missing", () => assert.rejects(myTable.update({key: randomString(), data: {rank: 123}})).then((rejectsWith) => assert.eq(rejectsWith.info.response.status, missing))], ["with createOk rejected without originatedOnServer", () => assert.clientFailureNotAuthorized(myTable.update({props: {createOk: true, key: randomString(), data: {rank: 123}}}))], ["non-existant record works with createOk and originatedOnServer", () => pipelines.myCompoundKeyTable.update({returnResponseObject: true, originatedOnServer: true, props: {createOk: true, key: {userId: "123", postId: "abc"}}}).then((response) => assert.eq(response.status, success))]);}, errors: function() {return chainedTest(setupWithMyTable).softTapTest(["Service Unavailable errors return valid response with status networkFailure", () => assert.rejects(myTable.throwServiceUnavailable({props: {numFailures: 3}})).then(({status}) => assert.eq(status, networkFailure))], ["Service Unavailable errors are retried a limited number of times", () => myTable.throwServiceUnavailable({props: {numFailures: 2}}).then((rest) => assert.eq(rest, {successfulOnAttempt: 3}))]);}});});});
//# sourceMappingURL=BasicsTests.js.map
