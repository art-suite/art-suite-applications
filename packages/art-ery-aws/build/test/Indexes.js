"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["randomString", "deleteTestTables", "Neptune", "DynamoDbPipeline", "chainedTest", "assert", "Promise"], [global, require('./StandardImport'), require('art-aws')], (randomString, deleteTestTables, Neptune, DynamoDbPipeline, chainedTest, assert, Promise) => {let myAppMessage, MyAppMessage, setupPromise, setupWithMyTable, aliceId, billId; myAppMessage = MyAppMessage = null; setupPromise = null; setupWithMyTable = function() {return deleteTestTables().then(() => {Neptune.Art.Ery.PipelineRegistry._reset(); ({myAppMessage} = MyAppMessage = Caf.defClass(class MyAppMessage extends DynamoDbPipeline {}, function(MyAppMessage, classSuper, instanceSuper) {this.publicRequestTypes("get", "create", "update", "delete", "byUserIdEventAt", "byUserIdEventAtDesc"); this.addDatabaseFilters({fields: {userId: "id", eventAt: ["required", "secondsTimestamp"], text: ["required", "trimmedString"]}}); this.globalIndexes({byUserIdEventAt: "userId/eventAt"});})); return myAppMessage._vivifyTable();});}; aliceId = randomString(); billId = randomString(); return {suite: {basic: function() {return chainedTest(setupWithMyTable).thenTest("fields are required", () => assert.clientFailure(myAppMessage.create({data: {userId: aliceId, text: "hi"}})).then((rejectsWith) => assert.match(rejectsWith.message, /missing.*eventAt/))).thenTest("create then get", () => Promise.all([myAppMessage.create({data: {userId: aliceId, text: "message at 1", eventAt: 1}}), myAppMessage.create({data: {userId: aliceId, text: "message at 2", eventAt: 2}}), myAppMessage.create({data: {userId: aliceId, text: "message at 3", eventAt: 3}})])).tapTest("byUserIdEventAt", () => myAppMessage.byUserIdEventAt(aliceId).then((messages) => assert.eq([1, 2, 3], Caf.array(messages, ({eventAt}) => eventAt)))).tapTest("byUserIdEventAtDesc", () => myAppMessage.byUserIdEventAtDesc(aliceId).then((messages) => assert.eq([3, 2, 1], Caf.array(messages, ({eventAt}) => eventAt), {messages}))).tapTest("where: eventAt: gt: 2", () => myAppMessage.byUserIdEventAt(aliceId, {props: {where: {eventAt: {gt: 2}}}}).then((messages) => assert.eq([3], Caf.array(messages, ({eventAt}) => eventAt)))).tapTest("where: eventAt: gte: 2", () => myAppMessage.byUserIdEventAt(aliceId, {props: {where: {eventAt: {gte: 2}}}}).then((messages) => assert.eq([2, 3], Caf.array(messages, ({eventAt}) => eventAt)))).tapTest("where: eventAt: between: 1 2", () => myAppMessage.byUserIdEventAt(aliceId, {props: {where: {eventAt: {between: [1, 2]}}}}).then((messages) => assert.eq([1, 2], Caf.array(messages, ({eventAt}) => eventAt)))).tapTest("where: eventAt: 2", () => myAppMessage.byUserIdEventAt(aliceId, {props: {where: {eventAt: 2}}}).then((messages) => assert.eq([2], Caf.array(messages, ({eventAt}) => eventAt)))).tapTest("select: :eventAt", () => myAppMessage.byUserIdEventAt(aliceId, {props: {select: "eventAt"}}).then((messages) => assert.eq([{eventAt: 1}, {eventAt: 2}, {eventAt: 3}], messages))).tapTest("select: :eventAt :userId", () => myAppMessage.byUserIdEventAt(aliceId, {props: {select: ["eventAt", "userId"]}}).then((messages) => assert.eq([{eventAt: 1, userId: aliceId}, {eventAt: 2, userId: aliceId}, {eventAt: 3, userId: aliceId}], messages))).tapTest("select: 'eventAt userId'", () => myAppMessage.byUserIdEventAt(aliceId, {props: {select: "eventAt userId"}}).then((messages) => assert.eq([{eventAt: 1, userId: aliceId}, {eventAt: 2, userId: aliceId}, {eventAt: 3, userId: aliceId}], messages)));}}};});});
//# sourceMappingURL=Indexes.js.map
