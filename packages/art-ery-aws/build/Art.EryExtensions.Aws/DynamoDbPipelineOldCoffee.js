// Generated by CoffeeScript 1.12.7
(function() {
  var ArtAws, DynamoDb, DynamoDbPipelineOldCoffee, KeyFieldsMixin, Pipeline, Promise, UpdateAfterMixin, Validator, compactFlatten, compare, deepMerge, defineModule, formattedInspect, inspect, intRand, isArray, isFunction, isPlainObject, isString, log, merge, mergeInto, mergeIntoUnless, networkFailure, object, objectWithExistingValues, pipelines, present, ref, ref1, timeout, upperCamelCase, withSort,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('art-standard-lib'), defineModule = ref.defineModule, mergeInto = ref.mergeInto, Promise = ref.Promise, object = ref.object, isPlainObject = ref.isPlainObject, deepMerge = ref.deepMerge, compactFlatten = ref.compactFlatten, inspect = ref.inspect, log = ref.log, merge = ref.merge, compare = ref.compare, Validator = ref.Validator, isString = ref.isString, isFunction = ref.isFunction, withSort = ref.withSort, formattedInspect = ref.formattedInspect, mergeIntoUnless = ref.mergeIntoUnless, objectWithExistingValues = ref.objectWithExistingValues, present = ref.present, isString = ref.isString, timeout = ref.timeout, intRand = ref.intRand, isArray = ref.isArray, upperCamelCase = ref.upperCamelCase;

  networkFailure = require('art-communication-status').networkFailure;

  ref1 = require('art-ery'), Pipeline = ref1.Pipeline, KeyFieldsMixin = ref1.KeyFieldsMixin, pipelines = ref1.pipelines, UpdateAfterMixin = ref1.UpdateAfterMixin;

  DynamoDb = (ArtAws = require('art-aws')).DynamoDb;

  defineModule(module, DynamoDbPipelineOldCoffee = (function(superClass) {
    extend(DynamoDbPipelineOldCoffee, superClass);

    function DynamoDbPipelineOldCoffee() {
      return DynamoDbPipelineOldCoffee.__super__.constructor.apply(this, arguments);
    }

    DynamoDbPipelineOldCoffee.abstractClass();


    /*
    IN:
      indexes: <Object> # a map:
        myIndexName: indexKeyOrProps
    
    indexKeyOrProps:
      <String> indexKey string
      <Object>
        key: <String> indexKey string
        ... other props passed to DynamoDb for index creation; ignored here
    
    OUT: params for Art.Ery.Pipeline's @query method
      Example:
        myQueryName:
          query: generatedQueryHandler = (request) ->
        ...
    
    EFFECT - after passed to @query:
      @handlers
        myQueryName:      generatedQueryHandler
        myQueryNameDesc:  generatedQueryHandlerDesc
    
    generatedQueryHandler Handler API:
      IN:
        REQUIRED: key: hashKeyValue <string>
        OPTIONAL:
          props: where: [sortKey]: # with exactly one of the following:
            eq:           sortValue
            lt:           sortValue
            lte:          sortValue
            gt:           sortValue
            gte:          sortValue
            between:      [sortValueA, sortValueB]  # returns values >= sortValueA and <= sortValueB
            beginsWith:   string-prefix
     */

    DynamoDbPipelineOldCoffee._getAutoDefinedQueries = function(indexes) {
      var fn, indexKey, queries, queryModelName;
      if (!indexes) {
        return {};
      }
      queries = {};
      fn = (function(_this) {
        return function(queryModelName, indexKey) {
          var doDynamoQuery, hashKey, indexName, ref2, sortKey;
          if (indexKey != null ? indexKey.key : void 0) {
            indexKey = indexKey.key;
          }
          if (isString(indexKey)) {
            ref2 = indexKey.split("/"), hashKey = ref2[0], sortKey = ref2[1];
            indexName = indexKey !== _this.getKeyFieldsString() ? queryModelName : void 0;
            doDynamoQuery = function(request, descending) {
              var beginsWith, between, eq, gt, gte, lt, lte, obj, params, ref3, select, sortKeyWhere;
              params = {
                where: (
                  obj = {},
                  obj["" + hashKey] = request.key,
                  obj
                )
              };
              if (indexName != null) {
                params.index = indexName;
              }
              if (descending) {
                params.descending = true;
              }
              if (sortKeyWhere = (ref3 = request.props.where) != null ? ref3[sortKey] : void 0) {
                if (isPlainObject(sortKeyWhere)) {
                  eq = sortKeyWhere.eq, lt = sortKeyWhere.lt, lte = sortKeyWhere.lte, gt = sortKeyWhere.gt, gte = sortKeyWhere.gte, between = sortKeyWhere.between, beginsWith = sortKeyWhere.beginsWith;
                  params.where[sortKey] = merge({
                    eq: eq,
                    lt: lt,
                    lte: lte,
                    gt: gt,
                    gte: gte,
                    between: between,
                    beginsWith: beginsWith
                  });
                } else {
                  params.where[sortKey] = {
                    eq: sortKeyWhere
                  };
                }
              }
              if (select = request.props.select) {
                if (isArray(select)) {
                  select = compactFlatten(select).join(' ');
                }
                if (!isString(select)) {
                  return request.clientFailure("select must be a string or array of strings");
                }
                params.select = select;
              }
              return request.pipeline.queryDynamoDbWithRequest(request, params).then(function(arg) {
                var items;
                items = arg.items;
                return items;
              }).tapCatch(function(error) {
                return log({
                  DynamoDbPipeline_query: {
                    error: error,
                    params: params,
                    request: request
                  }
                });
              });
            };
            queries[queryModelName] = {
              query: function(request) {
                return doDynamoQuery(request);
              },
              dataToKeyString: function(data) {
                return data[hashKey];
              },
              keyFields: [hashKey],
              localSort: function(queryData) {
                return withSort(queryData, function(a, b) {
                  var ret;
                  if (0 === (ret = compare(a[sortKey], b[sortKey]))) {
                    return compare(a.id, b.id);
                  } else {
                    return ret;
                  }
                });
              }
            };
            return queries[queryModelName + "Desc"] = {
              query: function(request) {
                return doDynamoQuery(request, true);
              },
              dataToKeyString: function(data) {
                return data[hashKey];
              },
              keyFields: [hashKey],
              localSort: function(queryData) {
                return withSort(queryData, function(b, a) {
                  var ret;
                  if (0 === (ret = compare(a[sortKey], b[sortKey]))) {
                    return compare(a.id, b.id);
                  } else {
                    return ret;
                  }
                });
              }
            };
          }
        };
      })(this);
      for (queryModelName in indexes) {
        indexKey = indexes[queryModelName];
        fn(queryModelName, indexKey);
      }
      return queries;
    };

    DynamoDbPipelineOldCoffee.getter({
      tablesByNameForVivification: function() {
        return this["class"].getTablesByNameForVivification();
      },
      dynamoDbCreationAttributes: function() {
        var k, out, ref2, v;
        out = {};
        ref2 = this.normalizedFields;
        for (k in ref2) {
          v = ref2[k];
          if (v.dataType === "string" || v.dataType === "number") {
            out[k] = v.dataType;
          }
        }
        return out;
      },
      streamlinedCreateTableParams: function() {
        return merge({
          table: this.tableName,
          globalIndexes: this.globalIndexes,
          localIndexes: this.localIndexes,
          attributes: this.dynamoDbCreationAttributes,
          key: this.keyFieldsString
        }, this._options);
      },
      createTableParams: function() {
        return ArtAws.StreamlinedDynamoDbApi.CreateTable.translateParams(this.streamlinedCreateTableParams);
      }
    });


    /*
    IN:
      request:
        requestProps:
          key
          data: {key: value}
            NOTE: null values are moved for CREATE and converted to REMOVE (attribute)
              actions for UPDATE.
    
          add: {key: value to add} -> dynamodb ADD action
          setDefault: {key: value} -> set attribute if not present
          conditionExpresssion: dynamodb update-of condition expressiong
          returnValues:         art.aws.dynamodb return value selector type
    
      requiresKey: true/false
        true:  key and data will be normalized using the primaryKey fields
        false: there willbe no key
    
      action: (streamlinedDynamoDbParams) -> out
    
    OUT:
      promise.catch (error) ->                # only internalErrors are thrown
      promise.then (clientFailureResponse) -> # if input is invalid, return clientFailure without invoking action
      promise.then (out) ->                   # otherwise, returns action's return value
     */

    DynamoDbPipelineOldCoffee.prototype._artEryToDynamoDbRequest = function(request, options) {
      var add, conditionExpression, consistentRead, data, key, keys, mustExist, ref2, requestType, requiresKey, returnValues, select, setDefault;
      if (options == null) {
        options = {};
      }
      requiresKey = options.requiresKey, mustExist = options.mustExist;
      if (mustExist) {
        requiresKey = true;
      }
      ref2 = request.props, key = ref2.key, data = ref2.data, add = ref2.add, setDefault = ref2.setDefault, conditionExpression = ref2.conditionExpression, returnValues = ref2.returnValues, consistentRead = ref2.consistentRead, keys = ref2.keys, select = ref2.select;
      requestType = request.requestType;
      return this._retryIfServiceUnavailable(request, (function(_this) {
        return function() {
          return Promise.then(function() {
            return request.requireServerOriginOr(!(add || setDefault || conditionExpression || returnValues), "to use add, setDefault, returnValues, or conditionExpression props");
          }).then(function() {
            return request.require(!(add || setDefault) || requestType === "update", "add and setDefault only valid for update requests");
          }).then(function() {
            var k, remove, v;
            if (requiresKey) {
              data = _this.dataWithoutKeyFields(data);
              key = _this.toKeyObject(request.key);
            }
            if (requestType === "update") {
              remove = (function() {
                var results;
                results = [];
                for (k in data) {
                  v = data[k];
                  if (v === null) {
                    results.push(k);
                  }
                }
                return results;
              })();
            }
            data = objectWithExistingValues(data);
            if (options.returnValues) {
              returnValues = options.returnValues;
            }
            if (requestType === "update") {
              returnValues || (returnValues = "allNew");
            }
            conditionExpression || (conditionExpression = mustExist && key);
            if (consistentRead) {
              consistentRead = true;
            }
            return objectWithExistingValues({
              tableName: _this.tableName,
              data: data,
              key: key,
              keys: keys,
              select: select,
              remove: remove,
              add: add,
              setDefault: setDefault,
              returnValues: returnValues,
              conditionExpression: conditionExpression,
              consistentRead: consistentRead
            });
          }).then(options.then, function(arg) {
            var message;
            message = arg.message;
            return request.clientFailure(message);
          });
        };
      })(this));
    };

    return DynamoDbPipelineOldCoffee;

  })(KeyFieldsMixin(UpdateAfterMixin(Pipeline))));

}).call(this);

//# sourceMappingURL=DynamoDbPipelineOldCoffee.js.map
