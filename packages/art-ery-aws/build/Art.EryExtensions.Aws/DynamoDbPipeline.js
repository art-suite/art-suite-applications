"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["KeyFieldsMixinCaf", "UpdateAfterMixin", "Pipeline", "Promise", "pipelines", "isFunction", "DynamoDb", "upperCamelCase", "log", "merge", "formattedInspect", "Error", "isArray", "isString", "mergeInto", "isPlainObject", "compactFlatten", "withSort", "compare", "StreamlinedDynamoDbApi", "objectWithExistingValues", "timeout", "intRand", "networkFailure"], [global, require('./StandardImport')], (KeyFieldsMixinCaf, UpdateAfterMixin, Pipeline, Promise, pipelines, isFunction, DynamoDb, upperCamelCase, log, merge, formattedInspect, Error, isArray, isString, mergeInto, isPlainObject, compactFlatten, withSort, compare, StreamlinedDynamoDbApi, objectWithExistingValues, timeout, intRand, networkFailure) => {let DynamoDbPipeline; return DynamoDbPipeline = Caf.defClass(class DynamoDbPipeline extends KeyFieldsMixinCaf(UpdateAfterMixin(Pipeline)) {}, function(DynamoDbPipeline, classSuper, instanceSuper) {let isServiceUnavailableError, retryIfServiceUnavailable; this.abstractClass(); this.createTablesForAllRegisteredPipelines = function() {return Promise.all(Caf.array(pipelines, (pipeline, name) => pipeline.createTable(), (pipeline, name) => isFunction(pipeline.createTable)));}; this.classGetter({dynamoDb: function() {return DynamoDb.singleton;}}); this.globalIndexes = function(globalIndexes) {this._globalIndexes = globalIndexes; return this.query(this._getAutoDefinedQueries(globalIndexes));}; this.localIndexes = function(localIndexes) {this._localIndexes = localIndexes; return this.query(this._getAutoDefinedQueries(localIndexes));}; this.getter({globalIndexes: function() {return this._options.globalIndexes || this.class._globalIndexes;}, localIndexes: function() {return this._options.localIndexes || this.class._localIndexes;}}); this.primaryKey = function() {let hashKey, keyFields; classSuper.primaryKey.apply(this, arguments); return (([hashKey] = keyFields = this.getKeyFields(), [hashKey]) && (Caf.exists(keyFields) && keyFields.length) === 2) ? this.query(this._getAutoDefinedQueries({[`by${Caf.toString(upperCamelCase(hashKey))}`]: this.getKeyFieldsString()})) : undefined;}; this.getter({status: function() {return this._vivifyTable().then(() => "OK: table exists and is reachable").catch(() => "ERROR: could not connect to the table");}, dynamoDb: function() {return DynamoDb.singleton;}}); this.prototype.queryDynamoDb = function(params) {log.warn("DEPRICATED: queryDynamoDb; use queryDynamoDbWithRequest"); return this._retryIfServiceUnavailable(null, () => this.dynamoDb.query(merge(params, {table: this.tableName})));}; this.prototype.queryDynamoDbWithRequest = function(request, params) {return this._retryIfServiceUnavailable(request, () => this.dynamoDb.query(merge(params, {table: this.tableName})));}; this.prototype.scanDynamoDb = function(params) {return this.dynamoDb.scan(merge(params, {table: this.tableName}));}; this.prototype.withDynamoDb = function(action, params) {return this.dynamoDb[action](merge(params, {table: this.tableName}));}; this.prototype.batchedEach = function(f, options = {}) {let lastEvaluatedKey, limit, batchLimit, inLastEvaluatedKey; lastEvaluatedKey = options.lastEvaluatedKey; limit = options.limit; batchLimit = options.batchLimit; if (limit != null && !(batchLimit != null)) {batchLimit = limit;}; inLastEvaluatedKey = lastEvaluatedKey; return this.getAll({returnResponse: true, props: merge(options.props, {lastEvaluatedKey, limit: batchLimit})}).then(({props: {lastEvaluatedKey}, data}) => {let getMore; getMore = (!limit || limit > data.length) && !!lastEvaluatedKey; log(`got ${Caf.toString(data.length)} records. ${Caf.toString(formattedInspect({getMore, limit, lastEvaluatedKey}))}`); if (lastEvaluatedKey != null) {if (inLastEvaluatedKey === lastEvaluatedKey) {throw new Error(`same last-key ${Caf.toString(inLastEvaluatedKey)}`);};}; return Promise.then(() => f(data)).then(() => getMore ? this.batchedEach(f, merge(options, {lastEvaluatedKey, limit: limit != null && limit - data.length})).then((count) => count + data.length) : data.length);});}; this.handlers({createTable: function() {return this._vivifyTable().then(() => {return {message: "success"};});}, initialize: function(request) {return this._vivifyTable().then(() => {return {message: "success"};});}, getInitializeParams: function() {return this.createTableParams;}, get: function(request) {return this._artEryToDynamoDbRequest(request, {requiresKey: true, then: (params) => this.dynamoDb.getItem(params).then((result) => result.item || request.missing())});}, scan: function(request) {let limit, lastEvaluatedKey; ({limit, lastEvaluatedKey} = request.props); return this.scanDynamoDb({limit, lastEvaluatedKey}).then(({lastEvaluatedKey, items}) => request.success({data: items, props: {lastEvaluatedKey}}));}, getAll: function(request) {return request.subrequest(request.pipeline, "scan", {returnResponse: true, props: request.props});}, batchGet: function(request) {let keys, select; ({keys, select} = request.props); return request.require(isArray(request.props.keys)).then(() => select ? request.require(isString(request.props.select)) : undefined).then(() => this._artEryToDynamoDbRequest(request, {then: (params) => this.dynamoDb.batchGetItem(params).then(({items}) => items)}));}, create: function(request) {return this._artEryToDynamoDbRequest(request, {then: (params) => this.dynamoDb.putItem(params).then(() => request.data)});}, update: function(request) {let createOk; ({createOk} = request.props); return request.requireServerOriginIf(createOk, "to use createOk").then(() => request.rejectIf(createOk && this.getKeyFieldsString() === "id", "createOk not available on tables with auto-generated-ids")).then(() => {let _dynamoDbParams; _dynamoDbParams = null; return this._artEryToDynamoDbRequest(request, {mustExist: !createOk, requiresKey: true, then: (dynamoDbParams) => {_dynamoDbParams = dynamoDbParams; return this.dynamoDb.updateItem(dynamoDbParams).then(({item}) => {let modifiedFields, data, base; return (Caf.exists(base = dynamoDbParams.returnValues) && base.match(/old/i)) ? request.success({props: {oldData: item, data: request.requestDataWithKey}}) : (modifiedFields = this.getFieldsRequestWillModify(request), request.success({props: {data: data = mergeInto(request.requestDataWithKey, item), updatedData: Caf.object(data, (v, k) => modifiedFields[k] != null)}}));}).catch((error) => error.message.match(/ConditionalCheckFailedException/) ? request.missing("Attempted to update a non-existant record.") : (log({DynamoDbPipeline_update: {error, request}}), (() => {throw error;})()));}}).tapCatch((error) => log({ArtEryDynamoDb: {request, _dynamoDbParams}}));});}, delete: function(request) {return this._artEryToDynamoDbRequest(request, {mustExist: true, returnValues: "allOld", then: (deleteItemParams) => this.dynamoDb.deleteItem(deleteItemParams).then(({item}) => item).catch((error) => error.message.match(/ConditionalCheckFailedException/) ? request.missing("Attempted to delete a non-existant record.") : (() => {throw error;})())});}, deleteIfExists: function(request) {let key, data; ({key, data} = request); return request.subrequest(this.pipelineName, "delete", {key, data, returnNullIfMissing: true}).then((result) => result != null ? result : request.success({data: request.requestDataWithKey}));}, createOrUpdate: function(request) {return request.requireServerOrigin().then(() => request.rejectIf(this.getKeyFieldsString() === "id", "createOk not available on tables with auto-generated-ids")).then(() => {let key, data, add, setDefault; ({key, data, add, setDefault} = request.props); return request.subrequest(this.pipelineName, "update", {returnNullIfMissing: true, props: {key, data, add, setDefault}}).then((result) => {let keyFields; keyFields = isPlainObject(key) ? key : (isString(key) && this.toKeyObject) ? this.toKeyObject(key) : undefined; return result != null ? result : request.subrequest(this.pipelineName, "create", {key, data: merge(keyFields, setDefault, data, add)});});});}}); this.prototype.getFieldsRequestWillModify = function(request) {return merge(request.props.setDefault, request.props.add, request.data);}; this._getAutoDefinedQueries = function(indexes) {let queries; if (!indexes) {return {};}; queries = {}; Caf.each2(indexes, (indexKey, queryModelName) => {let hashKey, sortKey, indexName, doDynamoQuery; if (Caf.exists(indexKey) && indexKey.key) {indexKey = indexKey.key;}; return isString(indexKey) ? (([hashKey, sortKey] = indexKey.split("/")), indexName = (indexKey !== this.getKeyFieldsString()) ? queryModelName : undefined, doDynamoQuery = (request, descending) => {let params, sortKeyWhere, eq, lt, lte, gt, gte, between, beginsWith, select, base; params = {where: {[`${Caf.toString(hashKey)}`]: request.key}}; if (indexName != null) {params.index = indexName;}; if (descending) {params.descending = true;}; if (sortKeyWhere = Caf.exists(base = request.props.where) && base[sortKey]) {if (isPlainObject(sortKeyWhere)) {params.where[sortKey] = merge(({eq, lt, lte, gt, gte, between, beginsWith} = sortKeyWhere, {eq, lt, lte, gt, gte, between, beginsWith}));} else {params.where[sortKey] = {eq: sortKeyWhere};};}; if (select = request.props.select) {if (isArray(select)) {select = compactFlatten(select).join(" ");}; if (!isString(select)) {return request.clientFailure("select must be a string or array of strings");}; params.select = select;}; return request.pipeline.queryDynamoDbWithRequest(request, params).then(({items}) => items).tapCatch((error) => log({DynamoDbPipeline_query: {error, params, request}}));}, queries[queryModelName] = {query: (request) => doDynamoQuery(request), dataToKeyString: (data) => data[hashKey], keyFields: [hashKey], localSort: (queryData) => withSort(queryData, (a, b) => {let ret; return (0 === (ret = compare(a[sortKey], b[sortKey]))) ? compare(a.id, b.id) : ret;})}, queries[queryModelName + "Desc"] = {query: (request) => doDynamoQuery(request, true), dataToKeyString: (data) => data[hashKey], keyFields: [hashKey], localSort: (queryData) => withSort(queryData, (b, a) => {let ret; return (0 === (ret = compare(a[sortKey], b[sortKey]))) ? compare(a.id, b.id) : ret;})}) : undefined;}); return queries;}; this.prototype._vivifyTable = function() {let temp; return (((temp = this._vivifyTablePromise) != null ? temp : this._vivifyTablePromise = Promise.resolve().then(() => this.tablesByNameForVivification))).then((tablesByName) => !tablesByName[this.tableName] ? (log.warn(`${Caf.toString(this.getClassName())}#_vivifyTable() dynamoDb table does not exist: ${Caf.toString(this.tableName)}, creating...`), this._createTable()) : undefined);}; this.classGetter({tablesByNameForVivification: function() {let temp; return ((temp = this._tablesByNameForVivificationPromise) != null ? temp : this._tablesByNameForVivificationPromise = this.getDynamoDb().listTables().then(({TableNames}) => Caf.object([TableNames, () => true])));}}); this.getter({tablesByNameForVivification: function() {return DynamoDbPipeline.getTablesByNameForVivification();}, dynamoDbCreationAttributes: function() {return Caf.object(this.normalizedFields, (v, k) => v.dataType, (v, k) => v.dataType === "string" || v.dataType === "number");}, streamlinedCreateTableParams: function() {return merge({globalIndexes: this.globalIndexes, localIndexes: this.localIndexes, table: this.tableName, attributes: this.dynamoDbCreationAttributes, key: this.keyFieldsString, _options: this._options});}, createTableParams: function() {return StreamlinedDynamoDbApi.CreateTable.translateParams(this.streamlinedCreateTableParams);}}); this.prototype._artEryToDynamoDbRequest = function(request, options = {}) {let requiresKey, mustExist, key, data, add, setDefault, conditionExpression, returnValues, consistentRead, keys, select, requestType, temp; requiresKey = options.requiresKey; mustExist = options.mustExist; if (mustExist) {requiresKey = true;}; temp = request.props; key = temp.key; data = temp.data; add = temp.add; setDefault = temp.setDefault; conditionExpression = temp.conditionExpression; returnValues = temp.returnValues; consistentRead = temp.consistentRead; keys = temp.keys; select = temp.select; ({requestType} = request); return this._retryIfServiceUnavailable(request, () => Promise.then(() => request.requireServerOriginOr(!(add || setDefault || conditionExpression || returnValues), "to use add, setDefault, returnValues, or conditionExpression props")).then(() => request.require(!(add || setDefault) || requestType === "update", "add and setDefault only valid for update requests")).then(() => {let remove; if (requiresKey) {data = this.dataWithoutKeyFields(data); key = this.toKeyObject(request.key);}; if (requestType === "update") {remove = Caf.array(data, (v, k) => k, (v, k) => v === null);}; data = objectWithExistingValues(data); if (options.returnValues) {returnValues = options.returnValues;}; if (requestType === "update") {returnValues != null ? returnValues : returnValues = "allNew";}; conditionExpression || (conditionExpression = mustExist && key); if (consistentRead) {consistentRead = true;}; return objectWithExistingValues({tableName: this.tableName, data, key, keys, select, remove, add, setDefault, returnValues, conditionExpression, consistentRead});}).then(options.then, ({message}) => request.clientFailure(message)));}; this.prototype._createTable = function() {return this.dynamoDb.createTable(this.streamlinedCreateTableParams).catch((e) => {log.error(`DynamoDbPipeline#_createTable ${Caf.toString(this.tableName)} FAILED`, e); return (() => {throw e;})();});}; isServiceUnavailableError = function(error) {return error.message.match(/Service *Unavailable/i);}; this.prototype._retryIfServiceUnavailable = retryIfServiceUnavailable = function(request, action, retriesRemaining = 2) {return Promise.then(() => action()).catch((error) => isServiceUnavailableError(error) ? (retriesRemaining > 0) ? timeout(10 + intRand(20)).then(() => retryIfServiceUnavailable(request, action, retriesRemaining - 1)) : request ? request.toResponse(networkFailure).then((response) => response.toPromise()) : (() => {throw error;})() : (() => {throw error;})());};});});});
//# sourceMappingURL=DynamoDbPipeline.js.map
