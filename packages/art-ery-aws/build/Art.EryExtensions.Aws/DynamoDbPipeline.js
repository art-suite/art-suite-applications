"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Promise", "pipelines", "isFunction", "DynamoDb", "upperCamelCase", "isArray", "isString", "mergeInto", "log", "merge", "formattedInspect", "Error", "timeout", "intRand", "networkFailure"], [global, require('./StandardImport')], (Promise, pipelines, isFunction, DynamoDb, upperCamelCase, isArray, isString, mergeInto, log, merge, formattedInspect, Error, timeout, intRand, networkFailure) => {let DynamoDbPipeline; return DynamoDbPipeline = Caf.defClass(class DynamoDbPipeline extends require('./DynamoDbPipelineOldCoffee') {}, function(DynamoDbPipeline, classSuper, instanceSuper) {let isServiceUnavailableError, retryIfServiceUnavailable; this.abstractClass(); this.createTablesForAllRegisteredPipelines = function() {return Promise.all(Caf.array(pipelines, (pipeline, name) => pipeline.createTable(), (pipeline, name) => isFunction(pipeline.createTable)));}; this.classGetter({dynamoDb: function() {return DynamoDb.singleton;}, tablesByNameForVivification: function() {let temp; return ((temp = this._tablesByNameForVivificationPromise) != null ? temp : this._tablesByNameForVivificationPromise = this.getDynamoDb().listTables().then(({TableNames}) => Caf.object(TableNames, () => true)));}}); this.globalIndexes = function(globalIndexes) {this._globalIndexes = globalIndexes; return this.query(this._getAutoDefinedQueries(globalIndexes));}; this.localIndexes = function(localIndexes) {this._localIndexes = localIndexes; return this.query(this._getAutoDefinedQueries(localIndexes));}; this.getter({globalIndexes: function() {return this._options.globalIndexes || this.class._globalIndexes;}, localIndexes: function() {return this._options.localIndexes || this.class._localIndexes;}}); this.primaryKey = function() {let hashKey, keyFields; classSuper.primaryKey.apply(this, arguments); return (([hashKey] = keyFields = this.getKeyFields(), [hashKey]) && (Caf.exists(keyFields) && keyFields.length) === 2) ? this.query(this._getAutoDefinedQueries({[`by${Caf.toString(upperCamelCase(hashKey))}`]: this.getKeyFieldsString()})) : undefined;}; this.getter({status: function() {return this._vivifyTable().then(() => "OK: table exists and is reachable").catch(() => "ERROR: could not connect to the table");}, dynamoDb: function() {return DynamoDb.singleton;}}); this.handlers({createTable: function() {return this._vivifyTable().then(() => {return {message: "success"};});}, initialize: function() {return this._vivifyTable().then(() => {return {message: "success"};});}, getInitializeParams: function() {return this.createTableParams;}, get: function(request) {return this._artEryToDynamoDbRequest(request, {requiresKey: true, then: (params) => this.dynamoDb.getItem(params).then((result) => result.item || request.missing())});}, scan: function(request) {let limit, lastEvaluatedKey; ({limit, lastEvaluatedKey} = request.props); return this.scanDynamoDb({limit, lastEvaluatedKey}).then(({lastEvaluatedKey, items}) => request.success({data: items, props: {lastEvaluatedKey}}));}, getAll: function(request) {return request.subrequest(request.pipeline, "scan", {returnResponse: true, props: request.props});}, batchGet: function(request) {let keys, select, temp; temp = request.props; keys = temp.keys; select = temp.select; return request.require(isArray(request.props.keys)).then(() => select ? request.require(isString(request.props.select)) : undefined).then(() => this._artEryToDynamoDbRequest(request, {then: (params) => this.dynamoDb.batchGetItem(params).then(({items}) => items)}));}, create: function(request) {return this._artEryToDynamoDbRequest(request, {then: (params) => this.dynamoDb.putItem(params).then(() => request.data)});}, update: function(request) {let createOk; ({createOk} = request.props); return request.requireServerOriginIf(createOk, "to use createOk").then(() => request.rejectIf(createOk && this.getKeyFieldsString() === "id", "createOk not available on tables with auto-generated-ids")).then(() => {let _dynamoDbParams; _dynamoDbParams = null; return this._artEryToDynamoDbRequest(request, {mustExist: !createOk, requiresKey: true, then: (dynamoDbParams) => {_dynamoDbParams = dynamoDbParams; return this.dynamoDb.updateItem(dynamoDbParams).then(({item}) => {let modifiedFields, data, base; return (Caf.exists(base = dynamoDbParams.returnValues) && base.match(/old/i)) ? request.success({props: {oldData: item, data: request.requestDataWithKey}}) : (modifiedFields = this.getFieldsRequestWillModify(request), request.success({props: {data: data = mergeInto(request.requestDataWithKey, item), updatedData: Caf.object(data, null, (v, k) => modifiedFields[k] != null)}}));}).catch((error) => error.message.match(/ConditionalCheckFailedException/) ? request.missing("Attempted to update a non-existant record.") : (log({DynamoDbPipeline_update: {error, request}}), (() => {throw error;})()));}}).tapCatch((error) => log({ArtEryDynamoDb: {request, _dynamoDbParams}}));});}, delete: function(request) {return this._artEryToDynamoDbRequest(request, {mustExist: true, returnValues: "allOld", then: (deleteItemParams) => this.dynamoDb.deleteItem(deleteItemParams).then(({item}) => item).catch((error) => error.message.match(/ConditionalCheckFailedException/) ? request.missing("Attempted to delete a non-existant record.") : (() => {throw error;})())});}}); this.prototype.queryDynamoDbWithRequest = function(request, params) {return this._retryIfServiceUnavailable(request, () => this.dynamoDb.query(merge(params, {table: this.tableName})));}; this.prototype.scanDynamoDb = function(params) {return this.dynamoDb.scan(merge(params, {table: this.tableName}));}; this.prototype.withDynamoDb = function(action, params) {return this.dynamoDb[action](merge(params, {table: this.tableName}));}; this.prototype.getFieldsRequestWillModify = function(request) {return merge(request.props.setDefault, request.props.add, request.data);}; this.prototype.batchedEach = function(f, options = {}) {let lastEvaluatedKey, limit, batchLimit, inLastEvaluatedKey; lastEvaluatedKey = options.lastEvaluatedKey; limit = options.limit; batchLimit = options.batchLimit; if (limit != null && !(batchLimit != null)) {batchLimit = limit;}; inLastEvaluatedKey = lastEvaluatedKey; return this.getAll({returnResponse: true, props: merge(options.props, {lastEvaluatedKey, limit: batchLimit})}).then(({props: {lastEvaluatedKey}, data}) => {let getMore; getMore = (!limit || limit > data.length) && !!lastEvaluatedKey; if (options.verbose) {log(`got ${Caf.toString(data.length)} records. ${Caf.toString(formattedInspect({getMore, limit, lastEvaluatedKey}))}`);}; if (lastEvaluatedKey != null) {if (inLastEvaluatedKey === lastEvaluatedKey) {throw new Error(`same last-key ${Caf.toString(inLastEvaluatedKey)}`);};}; return Promise.then(() => f(data)).then(() => getMore ? this.batchedEach(f, merge(options, {lastEvaluatedKey, limit: limit != null && limit - data.length})).then((count) => count + data.length) : data.length);});}; isServiceUnavailableError = function(error) {return error.message.match(/Service *Unavailable/i);}; this.prototype._retryIfServiceUnavailable = retryIfServiceUnavailable = function(request, action, retriesRemaining = 2) {return Promise.then(() => action()).catch((error) => isServiceUnavailableError(error) ? (retriesRemaining > 0) ? timeout(10 + intRand(20)).then(() => retryIfServiceUnavailable(request, action, retriesRemaining - 1)) : request ? request.toResponse(networkFailure).then((response) => response.toPromise()) : (() => {throw error;})() : (() => {throw error;})());}; this.prototype._createTable = function() {return this.dynamoDb.createTable(this.streamlinedCreateTableParams).catch((e) => {log.error(`DynamoDbPipelineOldCoffee#_createTable ${Caf.toString(this.tableName)} FAILED`, e); return (() => {throw e;})();});}; this.prototype._vivifyTable = function() {return this._vivifyTablePromise || (this._vivifyTablePromise = Promise.resolve().then(() => this.tablesByNameForVivification.then((tablesByName) => !tablesByName[this.tableName] ? this._createTable() : undefined)));};});});});
//# sourceMappingURL=DynamoDbPipeline.js.map
