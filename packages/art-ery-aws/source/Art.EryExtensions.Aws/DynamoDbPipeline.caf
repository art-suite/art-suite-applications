import &StandardImport

class DynamoDbPipeline extends &DynamoDbPipelineOldCoffee
  @abstractClass()
  ###########################################
    Class API
  ###########################################
  @createTablesForAllRegisteredPipelines: ->
    Promise.all array pipeline, name from pipelines when isFunction pipeline.createTable
      pipeline.createTable()

  @classGetter
    dynamoDb: -> DynamoDb.singleton
    tablesByNameForVivification: ->
      @_tablesByNameForVivificationPromise ?=
        @getDynamoDb().listTables().then ({TableNames}) =>
          object from TableNames with true

  ###########################################
    Indexes
  ###########################################
  @globalIndexes: (globalIndexes) ->
    @_globalIndexes = globalIndexes
    @query @_getAutoDefinedQueries globalIndexes

  @localIndexes: (localIndexes) ->
    @_localIndexes = localIndexes
    @query @_getAutoDefinedQueries localIndexes

  @getter
    globalIndexes: -> @_options.globalIndexes || @class._globalIndexes
    localIndexes:  -> @_options.localIndexes  || @class._localIndexes

  @primaryKey: ->
    super
    if ([hashKey] = keyFields = @getKeyFields()) && keyFields?.length == 2
      @query @_getAutoDefinedQueries
        "by#{upperCamelCase hashKey}": @getKeyFieldsString()

  ###########################################
    Instance Getters
  ###########################################

  @getter
    status: ->
      @_vivifyTable()
      .then -> "OK: table exists and is reachable"
      .catch -> "ERROR: could not connect to the table"
    dynamoDb: -> DynamoDb.singleton

  ###########################################
    Initialization Handlers
  ###########################################
  @handlers
    # TODO: createTable -- depricate??? use initialize instead?
    createTable:          -> @_vivifyTable().then -> message: "success"
    initialize:           -> @_vivifyTable().then -> message: "success"
    getInitializeParams:  -> @createTableParams

  ###########################################
    Bulk Read Handlers
  ###########################################
  @handlers
    ### scan
      limit: number (optional)
      lastEvaluatedKey:
        use the lastEvaluatedKey that was returned from the previous call, if it was set
    scan: (request) ->
      {limit, lastEvaluatedKey} = request.props
      @scanDynamoDb {limit, lastEvaluatedKey}
      .then ({lastEvaluatedKey, items}) ->
        request.success
          data:   items
          props:  {lastEvaluatedKey}

    getAll: (request) ->
      request.subrequest request.pipeline, "scan", returnResponse: true, props: request.props

    batchGet: (request) ->
      request.props extract keys, select
      request.require isArray request.props.keys
      .then -> if select then request.require isString request.props.select
      .then -> @_artEryToDynamoDbRequest
        request
        then: (params) ->
          @dynamoDb.batchGetItem params
          .then ({items}) -> items

  ###############################
    CRUD Handlers
  ###############################
  @handlers
    get: (request) ->
      @_artEryToDynamoDbRequest
        request
        requiresKey: true
        then: (params) ->
          @dynamoDb.getItem params
          .then (result) -> result.item || request.missing()

    ### create
      TODO: make create fail if the item already exists
        WHY? we have after-triggers that need to only trigger on a real create - not a replace
        AND filters like ValidationFilter assume create is a real create and update is a real update...
        NOTE: replace should be considered an update...
        NOTE: We have createOrUpdate if you really want both.

        ADD "replaceOk" prop
          Only replace existing items if explicitly requested:
          {replaceOk} = request.props
          This will mostly be used internally. Use createOrUpdate for
          that behavior externally.

      HOW to do 'replaceOk':

        http://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_PutItem.html
        To prevent a new item from replacing an existing item, use a conditional
        expression that contains the attribute_not_exists function with the name of
        the attribute being used as the partition key for the table. Since every
        record must contain that attribute, the attribute_not_exists function will
        only succeed if no matching item exists.

    create: (request) ->
      @_artEryToDynamoDbRequest request, then: (params) ->
        @dynamoDb.putItem params
        .then -> request.data

    ### update
      IN: response.props:
        createOk: true/falsish
          NOTE:
            A) can only use on tables which don't auto-generate-ids

      OUT:
        if record didn't exist:
          if createOk
            record was created
          response.status == missing
        else
          data: all fields with their current values (returnValues: 'allNew')

      TODO:
        support request.props.add and request.props.setDefault
          for both: requireOriginatedOnServer
    update: (request) ->
      {createOk} = request.props
      request.requireServerOriginIf createOk, "" to use createOk
      .then -> request.rejectIf createOk && @getKeyFieldsString() == 'id', "" createOk not available on tables with auto-generated-ids
      .then ->
        _dynamoDbParams = null
        @_artEryToDynamoDbRequest
          request
          mustExist:    !createOk
          requiresKey:  true
          then: (dynamoDbParams) ->
            _dynamoDbParams = dynamoDbParams
            @dynamoDb.updateItem dynamoDbParams
            .then ({item}) ->
              if dynamoDbParams.returnValues?.match /old/i
                request.success
                  props:
                    oldData:  item
                    data:     request.requestDataWithKey

              else
                modifiedFields = @getFieldsRequestWillModify request
                request.success
                  props: {}
                    data = mergeInto request.requestDataWithKey, item
                    updatedData: object v, k from data when modifiedFields[k]?

            .catch (error) ->
              if error.message.match /ConditionalCheckFailedException/
                request.missing "Attempted to update a non-existant record."
              else
                log DynamoDbPipeline_update: {error, request}
                throw error

        .tapCatch (error) -> log ArtEryDynamoDb: {} request, _dynamoDbParams

    ### updateBulk - TODO
      IN: data: array of objects compatible with a single 'update'
      Make sure to also update getFieldsRequestWillModify to correctly merge down all fields in the builk-update.
        This'll ensure UserOwnedFilter properly handles authorization
    ###

    ### delete
      OUT:
        if record didn't exist:
          response.status == missing
        else
          data: keyFields & values
    delete: (request) ->
      @_artEryToDynamoDbRequest
        request
        mustExist: true
        returnValues: :allOld
        then: (deleteItemParams) ->
          @dynamoDb.deleteItem deleteItemParams
          .then ({item}) -> item
          .catch (error) ->
            if error.message.match /// ConditionalCheckFailedException
              request.missing "" Attempted to delete a non-existant record.
            else throw error

  ################################
    Compound Handlers
  ################################
  @handlers
    ### deleteIfExists
      This calls 'get' first, then calls 'delete' if it exists. Therefor 'delete' hooks
      will only fire if the record actually exists.

      OUT: promise.then (response) -> response.data == key(s)
    deleteIfExists: (request) ->
      {key, data} = request
      request.subrequest @pipelineName, "delete", {key, data, returnNullIfMissing: true}
      .then (result) ->
        result ? request.success data: request.requestDataWithKey

    ### createOrUpdate
      This calls 'update' and possibly 'create', so hooks on update OR create will be correctly triggered.
      NOTE: Only after-update OR after-create filters/events will be processed - NOT BOTH!
        Which is the whole reason this exists, really - so the correct after-filters-events fire.

      TODO:
        The new version should do this:
        get {key, returnNullIfMissing: true}
        .then (exists) ->
          if exists
            update {key, data}
            .catch (doesntExists???) ->
              Promise.reject raceConditionOccured: true if doesntExists
            # NOTE - ignoring the race-condition with 'delete'
          else
            create {key, data}
            .catch (exists???) ->
              Promise.reject raceConditionOccured: true if exists
        .catch ({raceConditionOccured}) ->
          if raceConditionOccured && 3 > retryCount = 1 + props.retryCount ? 0
            createOrUpdate {
              key
              props: merge props, {retryCount}
            }
          else
            throw original-error
    createOrUpdate: (request) ->
      request.requireServerOrigin()
      .then =>
        request.rejectIf @getKeyFieldsString() == 'id', "createOk not available on tables with auto-generated-ids"
      .then =>
        {key, data, add, setDefault} = request.props
        request.subrequest @pipelineName, "update", returnNullIfMissing: true, props: {key, data, add, setDefault}
        .then (result) =>
          keyFields = if isPlainObject(key) then key else if isString(key) && @toKeyObject then @toKeyObject key
          result ? request.subrequest @pipelineName, "create", {key, data: merge keyFields, setDefault, data, add}

  #####################
    Helpers
  #####################
  queryDynamoDbWithRequest:  (request, params) ->
    @_retryIfServiceUnavailable request, -> @dynamoDb.query merge params, table: @tableName

  scanDynamoDb:   (params)         -> @dynamoDb.scan       merge params, table: @tableName
  withDynamoDb:   (action, params) -> @dynamoDb[action]    merge params, table: @tableName

  getFieldsRequestWillModify: (request) -> merge request.props.setDefault, request.props.add, request.data

  ### batchedEach
    iterate over entire table
    IN:
      f: (listOfRecords) -> # out ignored; throw to abort
      options:
        limit: stop after this many entries found
        batchLimit: limit the number of entries returned per batch
        verbose: t/f log progress
    OUT: count
  batchedEach: (f, options = {}) ->
    options extract lastEvaluatedKey, limit, batchLimit
    batchLimit = limit if limit? && !batchLimit?

    inLastEvaluatedKey = lastEvaluatedKey
    @getAll returnResponse: true, props: merge options.props, {} lastEvaluatedKey, limit: batchLimit
    .then ({props:{lastEvaluatedKey}, data}) ->
      getMore = (!limit || limit > data.length) && !!lastEvaluatedKey
      log "got #{data.length} records. #{formattedInspect {getMore, limit, lastEvaluatedKey}}" if options.verbose
      throw new Error "same last-key #{inLastEvaluatedKey}" if inLastEvaluatedKey == lastEvaluatedKey if lastEvaluatedKey?

      Promise
      .then -> f data
      .then ->
        if getMore
          @batchedEach f, merge options, {lastEvaluatedKey, limit: limit? && limit - data.length}
          .then (count) -> count + data.length

        else data.length

  isServiceUnavailableError = (error) -> error.message.match /Service *Unavailable/i

  ############################3
    PRIVATE
  ############################3
  _retryIfServiceUnavailable: retryIfServiceUnavailable = (request, action, retriesRemaining = 2) ->
    Promise.then -> action()
    .catch (error) ->
      if isServiceUnavailableError error
        if retriesRemaining > 0
          timeout 10 + intRand 20
          .then -> retryIfServiceUnavailable request, action, retriesRemaining - 1

        else if request
          request.toResponse networkFailure
          .then (response) -> response.toPromise()

        else
          throw error

      else
        throw error

  _createTable: ->
    @dynamoDb.createTable @streamlinedCreateTableParams
    .catch (e) ->
      log.error "DynamoDbPipelineOldCoffee#_createTable #{@tableName} FAILED", e
      throw e

  _vivifyTable: ->
    @_vivifyTablePromise ||= Promise.resolve().then =>
      @tablesByNameForVivification
      .then (tablesByName) =>
        unless tablesByName[@tableName]
          # log.warn "#{@getClassName()}#_vivifyTable() dynamoDb table does not exist: #{@tableName}, creating..."
          @_createTable()

