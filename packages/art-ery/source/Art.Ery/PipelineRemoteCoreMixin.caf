import &StandardImport, {} &Request

(superClass) -> class PipelineRemoteCoreMixin extends superClass
  @abstractClass()

  ################################
    Declarative Interface
  ################################
  @remoteServer:    (@_remoteServer)    -> # override default (see config.remoteServer)
  @apiRoot:         (@_apiRoot)         -> # override default (see config.apiRoot)

  ################################
    GETTERS
  ################################
  @getter
    apiReport: (options) ->
      options extract? server, publicOnly
      object type from @requestTypes when !publicOnly || @getPublicRequestTypes()[type]
        {method, url} = Request.getRestClientParamsForArtEryRequest
          server:   @remoteServer || server
          type:     type
          restPath: @restPath
        "#{method.toLocaleUpperCase()}": url

    isRemoteClient:   -> !!@remoteServer
    apiRoot:          -> @class._apiRoot || config._apiRoot
    remoteServer:     -> @class._remoteServer || config.remoteServer

    location: ->
      if @remoteServer && config.location != :server
            :client
      else  config.location

    # RestCore - eventually we should have a way to plug in different transport layers
    restPath:       -> @_restPath ?= "" /#{config.apiRoot}/#{@name}
    restPathRegex:  -> @_restPathRegex ?=
      ///i
        ^
        #{escapeRegExp @restPath}
        (?:-([a-z0-9_]+))?          # optional request-type (if missing, it is derived from the HTTP method)
        (?:\/([^?]+))?       # optional key
        (?=\?|$)

  ################################
    Requests
  ################################
  handleRequest: (request) ->
    if @location == :client && @remoteServer
      request.sendRemoteRequest @remoteServer

    else super

  ##########################
    OVERRIDES
  ##########################
  getRequestProcessingReport: (location = @location) ->
    object requestType from @requestTypes
      compactFlatten []
        array filter in @getBeforeFilters {requestType, location} with inspectedObjectLiteral filter.getName()
        inspectedObjectLiteral if location == "client" then "[remote request]" else "[local handler]"
        array filter in @getAfterFilters  {requestType, location} with inspectedObjectLiteral filter.getName()

  getPipelineReport: ->
    merge
      super
      clientSideRequestProcessing: @getRequestProcessingReport :client
      serverSideRequestProcessing: @getRequestProcessingReport :server
