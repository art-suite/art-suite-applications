import &StandardImport

###
  A) Populate context.dataUpdates
  B) if Neptune.Art.Flux is defined, and this is the root request or resposne
     Perform 'local updates'
  TODO:
    Eventually we will want a way to say that some record updates should not be returned client-side.
    First pass
      - data has already gone through the after-pipeline, so any after-filters can removed fields
        the current user can't see. TODO: create privacy filters
      - if data is empty, then don't add it to updates. Nothing to add anyway. DONE


# 2023 Question/Note: Do we properly handle updates where a field of a record was set to NULL?
#   If we strip NULLs in return objects, then the client-side update, if it's a merge and not a replace,
#   wouldn't get the NULL-out signal.
class DataUpdatesFilter extends &Filter

  # for subrequests, this will still be on the server
  # for root requests, there is work to do on both the client and server
  @location :both
  @group :outer

  @after all: (response) ->
    if response.isRootRequest

      switch response.location
      when :client
        response
        .tap (response) -> @sendDataEvents response

      when :server :both
        response.withMergedPropsWithoutNulls {dataUpdates, dataDeletes} = response.context

    else
      response extract key, type, responseData, pipelineName, context

      groupName =
        if response.isUpdateRequest() then :dataUpdates
        else if response.isDeleteRequest() then :dataDeletes

      if groupName
        switch
        when responseData is Array
          each record in responseData
            key = response.pipeline.toKeyString record
            vivifyObjectPathAndSet context, groupName, pipelineName, key, record

        when key, response.pipeline.isRecord responseData
          responseData ?=
            response.pipeline.toKeyObject? key || responseData
            || {}

          key ?= response.pipeline.toKeyString responseData
          vivifyObjectPathAndSet context, groupName, pipelineName, key, responseData

      response

  sendDataEvents: (response) ->
    @sendDataUpdateEvents response.pipelines, response.responseProps.dataUpdates
    @sendDataDeleteEvents response.pipelines, response.responseProps.dataDeletes

  sendDataUpdateEvents: (pipelines, dataUpdates) ->
    each dataUpdatesByKey, pipelineName in dataUpdates || []
      each data, key in dataUpdatesByKey
        pipelines[pipelineName].dataUpdated key, data

  sendDataDeleteEvents: (pipelines, dataDeletes) ->
    each dataDeletesByKey, pipelineName in dataDeletes || []
      each data, key in dataDeletesByKey
        pipelines[pipelineName].dataDeleted key, data
