import &StandardImport
ArtEry = require :./namespace

# validator must be initialized after Request and Pipeline have bene defined
_validator = null
requestConstructorValidator = ->
  _validator ?= new Validator
    pipeline:           required: instanceof: ArtEry.Pipeline
    type:               required: fieldType: :string
    session:            required: fieldType: :object
    parentRequest:      instanceof: ArtEry.Request
    originatedOnServer: :boolean
    props:              :object
    key:                :string

###
  new Request(options)

  IN: options:
    see requestConstructorValidator for the validated options
    below are special-case options

    props: {}
      Any props you want.
      Common props:

      data: - generaly one record's data or an array of record data
      key:  - generally the ID for one record OR the complete set of parameters for a get-query

    # aliases - if either data/key are provided in both props and in these aliases,
    #   these aliases have priority
    data: >> @props.data
    key:  >> @props.key

    NOTE: Request doesn't care about @data, the alias is proved only as a convenience
    NOTE: Request only cares about @key for two things:
      - REST urls
      - cachedGet

      In general, type: "get" and key: "string" is a CACHEABLE request.
      This is why it must be a string.
      Currently there are no controls for HOW cacheable type-get is, though.
      All other requests are NOT cacheable.

  CONCEPTS

    context:

      This is the only mutable part of the request. It establishes one shared context for
      a request, all its clones, subrequests, responses and response clones.

      The primary purpose is for subrequests to coordinate their actions with the primary
      request. Currently this is only used server-side.

      There are two contexts when using a remote server: The client-side context is not
      shared with the server-side context. A new context is created server-side when
      responding to the request.

      BUT - there is only one context if location == "both" - if we are running without
      a remote server.
class Request extends &RequestResponseBase
  constructor: (options = {}) ->
    @_filterLog ?= []
      name:   :created
      stack:  @_creationStack
      time:   currentSecond()

    @_type = options.type
    @_pipeline = options.pipeline
    @_session = options.session
    @_originatedOnServer = options.originatedOnServer

    @_originalRequest ?= options.originalRequest ? @
    @_parentRequest = options.parentRequest

    @_props = options.props ? {}
    @_remoteRequest = options.remoteRequest

    @_verbose   = options.verbose
    @_context   = options.context
    @_startTime = null

    key = options.key ? @_props.key
    options.key = @_props.key = @pipeline.toKeyString key if key?
    @_props.data = options.data if options.data?

    requestConstructorValidator().validate options, context: "create Art.Ery.Request options", logErrors: true

    throw new Error "options.requestOptions is DEPRICATED - use options.props" if options.requestOptions
