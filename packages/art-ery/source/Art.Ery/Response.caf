import &StandardImport, &Config, {} &Request

responseValidator = new Validator
  request:  [] :required instanceof: Request
  status:   :required :communicationStatus
  session:  :object
  props:    :object

###
  TODO: Merge Response back into Request

    Turns out, Response has very little special functionality.
    At this point, the RequestuestResponseBase / Request / Response class structure
    actually requires more code than just one, Request class would.

  What to add to Request:

    @writeOnceProperty "responseStatus responseSession responseProps"

    @getter
      hasResponse: -> !!@responseStatus

    Split out: filterLog into beforeFilterLog and afterFilterLog.

    new Response

    IN:
      request: Request (required)
      status: CommunicationStatus (required)
      props: plainObject with all JSON values
      session: plainObject with all JSON values

      data: JSON value
        data is an alias for @props.data
        EFFECT: replaces @props.data
        NOTE: for clientRequest, @props.data is the value returned unless returnResponse/returnResponseObject is requested

      remoteRequest: remoteResponse:
        Available for inspecting what exactly went over-the-wire.
        Otherwise ignored by Response

class Response extends &RequestResponseBase

  constructor: (options) ->
    responseValidator.validate options, context: "Art.Ery.Response options", logErrors: true
    super merge options, {} options.request.creationStack

    @_request = options.request
    @_status = options.status
    @_session = options.session
    @_remoteRequest = options.remoteRequest
    @_remoteResponse = options.remoteResponse
    @_props = options.props ? {}

    throw new Error "options.requestOptions is DEPRICATED - use options.props" if options.requestOptions

    @_props.data = options.data if options.data?

    @_session ?= if neq @request.session, @request.originalRequest.session
      @request.session

    @_endTime = null

    @setGetCache() if @type == :create || @type == :get
