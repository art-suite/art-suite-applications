import &StandardImport, &PrefetchedRecordsCache

class ArtEryModel extends KeyFieldsMixin ArtModel
  @abstractClass()

  ## createModel
    ALIASES
      both pipelines and models will have the same set of aliases
      This skips the aliases in pipelines and calls createModel only once
      which will in turn create all the model aliases.
      It's important that all the model aliases are the same model-instance object.

    OUT: singleton for new AnonymousArtEryModel class
  @createModel: (pipeline) ->
    {aliases} = pipeline
    name = pipeline.getName()
    return if models[name]

    hotReloadKey = "ArtEryModel:#{name}"

    class AnonymousArtEryModel extends ArtEryModel
      @_name: ucName = upperCamelCase name
      @keyFields pipeline.keyFields if pipeline.keyFields
      @pipeline pipeline
      @aliases aliases if aliases
      @getHotReloadKey: -> hotReloadKey

  @defineModelsForAllPipelines: =>
    each pipeline, name in pipelines when name == pipeline.getName()
      @createModel pipeline

    models

  @bindWithArtEry: =>
    PipelineRegistry.on register: ({name, pipeline}) -> @createModel pipeline

    @defineModelsForAllPipelines()

  @pipeline: (@_pipeline) -> @_pipeline
  @getter
    pipelineName: -> @_pipeline.getName()
    :pipeline
    propsToKey: -> @_pipeline.propsToKey

  ########################
  # Constructor
  ########################
  constructor: ->
    @_updateSerializers = {}
    @_pipeline = @class._pipeline
    @_defineQueryModels()
    @_bindPipelineMethods()
    @_pipeline.subscribe (type, key, data) ->
      switch type
      when :update then @dataUpdated key, data
      when :delete then @dataDeleted key, data

  ########################
  # Queries
  ########################
  _defineQueryModels: ->
    @_queryModels = array pipelineQuery in @_pipeline.queries with @_createQueryModel pipelineQuery

  ## _createQueryModel
    IN: {options, queryName}
    queryName can either be
      pre2020-style:
        format: pluralized pipeline name - by - fields
        e.g. postsByUserId

      2020-style-naming:
        format: by - fields
        e.g. byUserId

      Either way, the art-model will be named:
        format: pluralized pipeline name - by - fields
        e.g. postsByUserId

    Benefits of 2020-style query names:
      By dropping the pipeline-name as part of the queryName, we get several advantages:

        DRY:
          Pipeline definitions:
            2020 version:
              class Message extends Pipeline
                @query byUserId: (request) -> ...
                @publicRequestTypes :byUserId

            instead of pre2020:
              class Message extends Pipeline
                @query messagesByUserId: (request) -> ...
                @publicRequestTypes :messagesByUserId

          The REST api becomes:
            2020 version:       /post/byUserId/abc123
            instead of pre2020: /post/postsByUserId/abc123

        And all the DRY means an objective improvement:

          It is now possible to re-use pipeline query definitions across pipelines:

            class UserOwned extends Pipeline
              @query byUserId: (request) -> ...
              @publicRequestTypes :byUserId

            class Message extends UserOwned
            class Post extends UserOwned

          NOTE: I actually haven't tested that the inheritance part works yet...
  _createQueryModel: ({options, queryName}) ->
    options extract localMerge, localSort, dataToKeyString, keyFields

    recordsModel = @
    pipeline = @_pipeline

    class ArtEryQueryModelChild extends &ArtEryQueryModel
      @_name: upperCamelCase
        if /^by/.test queryName
          "#{pluralize pipeline.name} #{queryName}"
        else
          queryName

      _pipeline:      pipeline
      _recordsModel:  recordsModel
      _queryName:     queryName

      @keyFields keyFields if keyFields

      # Overrides
      # TODO: add propsToKey
      each v, k in merge {} localMerge, localSort, dataToKeyString
        @prototype[k] = v

    .singleton

  ########################
  # ArtModel Overrides
  ########################
  loadData: (key) ->
    prefetchedRecordsCache.get @pipelineName, key                               # LinkFieldsFilterV2
    ? @_pipeline.get {} key, returnNullIfMissing: true, props: include: "auto"  # include: :auto is for LinkFieldsFilterV1

  ################################################
  # DataUpdatesFilter callbacks
  ################################################
  ## dataUpdated
    TODO: What if the field that changes effects @dataToKeyString???
      Basically, then TWO query results for one query-model need updated - the old version gets a "delete"
      The new version gets the normal update.

      We -could- do a modelStore.get and see if we have a local copy of the single record before we
      replace it. However, we often won't. However again, we may not NEED this often.

      Basically, the question becomes how do we get the old data - if we need it and it actually matters.

      The ArtEry Pipeline knows its queries - and in theory could know the fields which effect queries.
      DataUpdatesFilter could detect all this before: update. If it detects it, it could GET the old
      record, and then set responseProps.oldData: oldData. Then, DataUpdatesFilter could pass
      oldData into dataUpdated. DONE.

      OK - I added the oldData input, and I attempt to get it from the modelStore if it isn't set.
      I think the code is right for handling the case where we need to update to queries.

      TODO: We need to do the Server-Side "fetch the old data if queries-keys will change" outline above.
      TODO: DataUpdatesFilter needs change the protocol to return oldData, too, if needed - there may be more than one oldData per request.
      TODO: DataUpdatesFilter needs to pass in: response.props.oldData[key]
  dataUpdated: (key, data) ->
    oldData = @getModelRecord(key)?.data
    mergedData = merge oldData, data

    @updateModelRecord key, (oldRecord) -> merge oldRecord, data: merge oldRecord.data, data

    each queryModel in @_queryModels
      oldQueryKey = oldData && queryModel.dataToKeyString oldData
      queryKey    = queryModel.dataToKeyString mergedData

      queryModel.dataDeleted oldQueryKey, oldData if oldQueryKey && oldQueryKey != queryKey
      queryModel.dataUpdated queryKey, mergedData if queryKey

  dataDeleted: (key, dataOrKey) ->
    @updateModelRecord key, status: missing

    dataOrKey && each queryModel in @_queryModels
      queryKey = queryModel.toKeyString dataOrKey
      queryKey && queryModel.dataDeleted queryKey, dataOrKey

  ##########################
  # PRIVATE
  ##########################

  ## _bindPipelineMethods
    Bind all concrete methods defined on @_pipeline
    and set them on the model prototype
    as long as there isn't already a model-prototype method with that name.

    Specifically: create & update are already defined above
      since they need to do extra work to ensure the ModelStore is
      updated properly.
  _bindPipelineMethods: ->
    abstractPrototype = @_pipeline.class.getAbstractPrototype()
    each v, k in @_pipeline when !@[k] && !abstractPrototype[k] && isFunction v
      @[k] = fastBind v, @_pipeline
