import &StandardImport, &PrefetchedRecordsCache, {}
  &Response
  &Request
  &Filter
  &DatabaseFilters
  &Session
  &Config
  &Filters
  &PipelineRegistry
  &RequestResponseBase

###
  TODO: (July2019)
  Factor out all ArtFlux-related stuff
    ArtEry should be independent of ArtFlux or any other client-side state-management-system.

    Remaining:

      artModelMixins -
        This lets you customize what time of Object is created
        for your models. ArtEry shouldn't know anything about creating models, though...

        However, I DO want a way to declare this info in the Pipeline declaration
        to reduce redundency.

      query:
        Another declaration passed directly to ArtFlux

      aliases:
        Another declaration passed directly to ArtFlux

    Perhaps we need a subclass: PipelineWithFluxModel?

  Namespaced-Registry

    I still don't quite know how I want to do this, but I want BOTH ArtFlux (ArtModels?)
    and ArtEry (ArtPipelines?) to have namespaced registries so you can merge as many
    packages as you want based on ArtSuite without name-conflicts in their registries.

class Pipeline extends &PipelineCore
  # copy-paste this line to any sub-class that shouldn't auto-register
  @abstractClass()

  @postCreateConcreteClass: ({hotReloaded}) ->
    @_defineQueryHandlers()
    @_initFields()
    super

  @getAliases: -> @_aliases ? {}

  @addDatabaseFilters: (options) ->
    @filter DatabaseFilters.createDatabaseFilters options, @

  @addDatabaseFiltersV2: (options) ->
    @filter DatabaseFilters.createDatabaseFilters
      merge
        linkFilterVersion: 2
        options
      @

  getPrefetchedRecord: (key) ->
    prefetchedRecordsCache.get @pipelineName, key

  toKeyString: (key) ->
    return key unless key?
    if isString key
      key
    else if @dataToKeyString && isPlainObject key
      @dataToKeyString key
    else
      throw new Error "override toKeyString or dataToKeyString for non-string-keys like: #{formattedInspect key}"


  ###########################
  # Overrides
  ###########################

  ## isRecord (override as needed)
    # used by Request/Response.withTransformedRecords
  isRecord: (data) -> isPlainObject(data) && present data?.id

  ## getFieldsRequestWillModify (override as needed)
    # called by UserOwnedFilter.before.update for correct authorization validation
    # overriden by Art.Ery.Aws.DynamoDb to support "add" and "setDefault" for a correct modifications-list
  getFieldsRequestWillModify: (request) -> request.data ? {}

  ###########################
  # Declarative API
  ###########################

  @extendableProperty
    artModelMixins: []
    publicRequestTypes: {}

  # Database declarables
  @extendableProperty
    queries: {}
    fields: {}

  @publicRequestTypes: (values...) ->
    publicRequestTypes = {}
    each v in compactFlatten values
      each k in w v
        publicRequestTypes[k] = true
    @extendPublicRequestTypes publicRequestTypes

  # delcare handlers and publicRequestTypes as one
  @publicHandlers: (maps...) ->
    each map in maps
      @handlers map
      @publicRequestTypes Object.keys map

  ###
    @artModelMixin adds a mixin to artModelMixins

    When createing FluxModels for this pipeline (via ArtEryFluxModel.createModel for example),
    both the records model and each query-model will get these mixins.

    Example:
      class MyPipeline extends Pipeline
        @artModelMixin FluxModelMixinA
        @artModelMixin FluxModelMixinB

      # this action
      ArtEryFluxModel.defineModelsForAllPipelines()

      # defines this model:
      class MyPipeline extends FluxModelMixinB FluxModelMixinA ArtEryFluxModel
  @artModelMixin: (_mixin) -> @extendArtModelMixins _mixin

  @remoteServer:    (@_remoteServer)    -> # override default (see config.remoteServer)
  @apiRoot:         (@_apiRoot)         -> # override default (see config.apiRoot)
  @tableNamePrefix: (@_tableNamePrefix) -> # override default (see config.tableNamePrefix)

  ### query
    declare a query - used by ArtEryFlux

    IN: map:
      queryName: map:
        class properties for anonymous subclass of ArtEryQueryFluxModel

    queryName is used as both the ArtFlux model-name AND the ArtEry request-type:
      Example:
        # invoke query
        myPipeline.myQueryName key: queryKey

        # subscribe to Model in FluxComponent
        @subscriptions
          myQueryName: queryKey
  @query: (map) ->
    @extendQueries object options, queryName from map with @_normalizeQuery queryName, options

  ### aliases

    INPUT: zero or more strings or arrays of strings
      - arbitrary nesting of arrays is OK
      - nulls are OK, they are ignored
    OUTPUT: null

    NOTE: @aliases can only be called once

    example:
      class Post extends Pipeline
        @aliases "chapterPost"

    purpose:
      - used by ArtEryFluxComponent to make model aliases
        (see FluxModel.aliases)
  @aliases: (args...)->
    @_aliases = object v, k from args with-key lowerCamelCase v with true
    @

  ######################
  # constructor
  ######################
  constructor: (@_options = {}) ->

  getPrefixedTableName: (tableName) -> "#{@tableNamePrefix}#{tableName}"

  ### cachedGet - convenient alias altenative to request.cachedGet that matches the new subrequest patterns
    IN:
      request: - the request this will be a subrequest-of
      key: <String> (default: request.key)

    EFFECT:
      calls request.cachedGet. Note, cachedGet's cache is stored in request's context
  cachedGet: (request, key) ->
    request.cachedGet @pipelineName, key ? request.key

  @classGetter
    pipelineName: -> @_pipelineName || decapitalize @getName()
    pluralPipelineName: ->
      return @_pluralPipelineName if @_pluralPipelineName
      parts = getCodeWords @getPipelineName()
      parts.push pluralize parts.pop()
      @_pluralPipelineName = lowerCamelCase parts

  toString: -> @pipelineName
  getLogName: (requestType) -> "#{requestType}-handler"

  @getter
    :options
    pipelineName: -> @class.getPipelineName()
    tableNamePrefix: -> @class._tableNamePrefix || config.tableNamePrefix
    tableName: -> @getPrefixedTableName @name
    normalizedFields: ->
      nf = {}
      each v, k in @fields
        nf[k] = normalizeFieldProps v
      nf

    name:     -> @_name     ||= @_options.name    || decapitalize @class.getName()
    session:  -> @_session  ||= @_options.session || Session.singleton
    handlerRequestTypesMap: (_into = {}) ->
      mergeInto _into, @handlers
      _into

    filterRequestTypesMap: (_into = {}) ->
      each filter in @filters
        mergeInto _into, filter.beforeFilters
      _into

    requestTypesMap: (_into = {})-> @getHandlerRequestTypesMap @getFilterRequestTypesMap _into

    requestTypes:     -> Object.keys @requestTypesMap
    aliases:          -> Object.keys @class.getAliases()
    inspectedObjects: -> inspectedObjectLiteral @name
    isRemoteClient:   -> !!@remoteServer
    apiRoot:          -> @class._apiRoot || config._apiRoot
    remoteServer:     -> @class._remoteServer || config.remoteServer

    location: ->
      if @remoteServer && config.location != :server
            :client
      else  config.location

    restPath:       -> @_restPath ?= "" /#{config.apiRoot}/#{@name}
    restPathRegex:  -> @_restPathRegex ?=
      ///i
        ^
        #{escapeRegExp @restPath}
        (?:-([a-z0-9_]+))?          # optional request-type (if missing, it is derived from the HTTP method)
        (?:\/([^?]+))?       # optional key
        (?=\?|$)

    groupedFilters: -> @_groupedFilters ?= Pipeline.groupFilters @filters

    beforeFilters: (request) ->
      if request then array filter in @beforeFilters when filter.getBeforeFilter request
      else @_beforeFilters ?= @groupedFilters.slice().reverse()

    afterFilters: (request) ->
      if request then array filter in @afterFilters  when filter.getAfterFilter  request
      else @groupedFilters

    status: -> :OK

    filterChain: -> @_filterChain ?= compactFlatten([@, @groupedFilters]).reverse()

  # use a stable sort
  @groupFilters: (filters) ->
    priorityLevels = []
    each {priority} in filters
      pushIfNotPresent priorityLevels, priority

    sortedFilters = []
    each priorityLevels in (priorityLevels.sort (a, b) -> a - b)
      each filter in filters when priorityLevels == filter.priority
        sortedFilters.push filter

    sortedFilters

  ###############################
  # Development Reports
  ###############################
  getRequestProcessingReport: (location = @location) ->
    object requestType from @requestTypes
      compactFlatten []
        array filter in @getBeforeFilters {requestType, location} with inspectedObjectLiteral filter.getName()
        inspectedObjectLiteral if location == "client" then "[remote request]" else "[local handler]"
        array filter in @getAfterFilters {requestType, location} with inspectedObjectLiteral filter.getName()

  @getter
    pipelineReport: (processingLocation)->
      out =
        tableName: @tableName
        fields: object fieldProps from @fields
          each k in Object.keys(fieldProps).sort() into out = {}
            v = fieldProps[k]
            unless isFunction v
              out[k] = v

      if processingLocation
        out["#{processingLocation}Processing"] = @getRequestProcessingReport "client"
      else
        out.clientSideRequestProcessing = @getRequestProcessingReport "client"
        out.serverSideRequestProcessing = @getRequestProcessingReport "server"
        out.serverlessDevelopmentRequestProcessing = @getRequestProcessingReport "both"

      out

    apiReport: (options = {}) ->
      {server, publicOnly} = options
      object type from @requestTypes when !publicOnly || @getPublicRequestTypes()[type]
        {method, url} = Request.getRestClientParamsForArtEryRequest
          server: @remoteServer || server
          type: type
          restPath: @restPath
        "#{method.toLocaleUpperCase()}": url

  ###################
  # RequestHandler API
  ###################
  # SEE RequestHandler
  handleRequest: (request) ->
    if request.isResponse
      throw new Error "HARD DEPRICATED"

    if @location == "client" && @remoteServer
      request.sendRemoteRequest @remoteServer

    else if handler = @handlers[request.type]
      @applyHandler request, handler, "handler"
      .then (response) ->
        unless response.isResponse
          request.failure "#{@pipelineName}.#{request.type} request was not handled"
        else
          response
    else
      request.failure "#{@pipelineName}: No handler for request type: #{formattedInspect request.type}"

  ###################
  # propsToKey (primarilly used by ArtEryFluxModel)
  ###################

  @getter
    propsToKey: -> @_propsToKey ?= do ->
      recordType = @pipelineName
      (props, stateField) ->
        propsField = stateField ? recordType
        props[propsField]?.id ? props[propsField + "Id"]

  ###################
  # PRIVATE
  ###################

  ### _defineQueryHandlers
    query handler-functions: (request) -> response or any other value allowed for handlers
  @_defineQueryHandlers: ->
    handlers = @getHandlers()
    array pipelineQuery, k in @getQueries() when !handlers[k]
      handlers = @extendHandlers k, pipelineQuery.options.query

  @_normalizeQuery: (queryName, options) ->
    options = query: options if isFunction options
    unless isFunction(options.query) && options.query.length > 0
      throw new Error
        """
          query function must have at least one argument:

          #{formattedInspect {queryName, options}}"

    {queryName, options}

  @_initFields: ->
    each filter in @getFilters() with @extendFields filter.fields
