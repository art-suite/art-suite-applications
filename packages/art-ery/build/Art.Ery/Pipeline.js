"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["DatabaseFilters", "merge", "prefetchedRecordsCache", "isString", "isPlainObject", "Error", "formattedInspect", "present", "lowerCamelCase", "Object", "normalizeFieldProps", "config", "escapeRegExp", "compactFlatten", "inspectedObjectLiteral", "isFunction"], [global, require('./StandardImport'), require('./PrefetchedRecordsCache'), {DatabaseFilters: require('./DatabaseFilters')}], (DatabaseFilters, merge, prefetchedRecordsCache, isString, isPlainObject, Error, formattedInspect, present, lowerCamelCase, Object, normalizeFieldProps, config, escapeRegExp, compactFlatten, inspectedObjectLiteral, isFunction) => {let Pipeline; return Pipeline = Caf.defClass(class Pipeline extends require('./PipelineDbCoreMixin')(require('./PipelineRemoteCoreMixin')(require('./PipelinePublicRequestsMixin')(require('./PipelineCore')))) {}, function(Pipeline, classSuper, instanceSuper) {this.abstractClass(); this.postCreateConcreteClass = function({hotReloaded}) {this._defineQueryHandlers(); this._initFields(); return classSuper.postCreateConcreteClass.apply(this, arguments);}; this.getAliases = function() {let temp; return ((temp = this._aliases) != null ? temp : {});}; this.addDatabaseFilters = function(options) {return this.filter(DatabaseFilters.createDatabaseFilters(options, this));}; this.addDatabaseFiltersV2 = function(options) {return this.filter(DatabaseFilters.createDatabaseFilters(merge({linkFilterVersion: 2}, options), this));}; this.prototype.getPrefetchedRecord = function(key) {return prefetchedRecordsCache.get(this.pipelineName, key);}; this.prototype.toKeyString = function(key) {if (!(key != null)) {return key;}; return isString(key) ? key : (this.dataToKeyString && isPlainObject(key)) ? this.dataToKeyString(key) : (() => {throw new Error(`override toKeyString or dataToKeyString for non-string-keys like: ${Caf.toString(formattedInspect(key))}`);})();}; this.prototype.isRecord = function(data) {return isPlainObject(data) && present(Caf.exists(data) && data.id);}; this.prototype.getFieldsRequestWillModify = function(request) {let temp; return ((temp = request.data) != null ? temp : {});}; this.extendableProperty({artModelMixins: []}); this.extendableProperty({queries: {}, fields: {}}); this.artModelMixin = function(_mixin) {return this.extendArtModelMixins(_mixin);}; this.remoteServer = function(_remoteServer) {this._remoteServer = _remoteServer;}; this.apiRoot = function(_apiRoot) {this._apiRoot = _apiRoot;}; this.tableNamePrefix = function(_tableNamePrefix) {this._tableNamePrefix = _tableNamePrefix;}; this.query = function(map) {return this.extendQueries(Caf.object(map, (options, queryName) => this._normalizeQuery(queryName, options)));}; this.aliases = function(...args) {this._aliases = Caf.object(args, (v, k) => true, null, null, (v, k) => lowerCamelCase(v)); return this;}; this.prototype.getPrefixedTableName = function(tableName) {return `${Caf.toString(this.tableNamePrefix)}${Caf.toString(tableName)}`;}; this.getter({aliases: function() {return Object.keys(this.class.getAliases());}, normalizedFields: function() {let nf; nf = {}; Caf.each2(this.fields, (v, k) => nf[k] = normalizeFieldProps(v)); return nf;}, tableNamePrefix: function() {return this.class._tableNamePrefix || config.tableNamePrefix;}, tableName: function() {return this.getPrefixedTableName(this.name);}, restPath: function() {let temp; return ((temp = this._restPath) != null ? temp : this._restPath = `/${Caf.toString(config.apiRoot)}/${Caf.toString(this.name)}`);}, restPathRegex: function() {let temp; return ((temp = this._restPathRegex) != null ? temp : this._restPathRegex = RegExp(`^${Caf.toString(escapeRegExp(this.restPath))}(?:-([a-z0-9_]+))?(?:\\/([^?]+))?(?=\\?|\$)`, 'i'));}, status: function() {return "OK";}}); this.prototype.getRequestProcessingReport = function(location = this.location) {return Caf.object(this.requestTypes, (requestType) => compactFlatten([Caf.array(this.getBeforeFilters({requestType, location}), (filter) => inspectedObjectLiteral(filter.getName())), inspectedObjectLiteral((location === "client") ? "[remote request]" : "[local handler]"), Caf.array(this.getAfterFilters({requestType, location}), (filter) => inspectedObjectLiteral(filter.getName()))]));}; this.prototype.getPipelineReport = function(processingLocation) {return merge(instanceSuper.getPipelineReport.apply(this, arguments), {fields: Caf.object(this.fields, (fieldProps) => {let out; return Caf.each2(Object.keys(fieldProps).sort(), (k) => {let v; v = fieldProps[k]; return !isFunction(v) ? out[k] = v : undefined;}, null, out = {});}), clientSideRequestProcessing: this.getRequestProcessingReport("client"), serverSideRequestProcessing: this.getRequestProcessingReport("server")});}; this.prototype.handleRequest = function(request) {return (this.location === "client" && this.remoteServer) ? request.sendRemoteRequest(this.remoteServer) : instanceSuper.handleRequest.apply(this, arguments);}; this.getter({propsToKey: function() {let temp; return ((temp = this._propsToKey) != null ? temp : this._propsToKey = (() => {let recordType; recordType = this.pipelineName; return (props, stateField) => {let propsField, temp1, base; propsField = stateField != null ? stateField : recordType; return ((temp1 = Caf.exists(base = props[propsField]) && base.id) != null ? temp1 : props[propsField + "Id"]);};})());}}); this._defineQueryHandlers = function() {let handlers; handlers = this.getHandlers(); return Caf.array(this.getQueries(), (pipelineQuery, k) => handlers = this.extendHandlers(k, pipelineQuery.options.query), (pipelineQuery, k) => !handlers[k]);}; this._normalizeQuery = function(queryName, options) {if (isFunction(options)) {options = {query: options};}; if (!(isFunction(options.query) && options.query.length > 0)) {throw new Error(`query function must have at least one argument:\n\n${Caf.toString(formattedInspect({queryName, options}))}"`);}; return {queryName, options};}; this._initFields = function() {return Caf.each2(this.getFilters(), (filter) => this.extendFields(filter.fields));};});});});
//# sourceMappingURL=Pipeline.js.map
