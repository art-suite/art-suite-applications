"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["compactFlatten", "w", "Object", "Filter", "lowerCamelCase", "decapitalize", "getCodeWords", "pluralize", "normalizeFieldProps", "mergeInto", "inspectedObjectLiteral", "isFunction", "pushIfNotPresent", "isPlainObject", "log", "isString", "getDetailedRequestTracingEnabled", "Error", "Promise", "Request", "merge", "cleanStackTrace", "formattedInspect", "push", "removeFirstMatch", "isArray", "sendRemoteRequest", "currentSecond", "present", "config", "getPipelineRestPath", "getPipelineRestPathRegex", "apiReport", "DatabaseFilters"], [global, require('./StandardImport'), require('art-validation'), require('./Config'), require('./RestClientLib'), require('./RestServerLib'), {DatabaseFilters: require('./DatabaseFilters')}], (compactFlatten, w, Object, Filter, lowerCamelCase, decapitalize, getCodeWords, pluralize, normalizeFieldProps, mergeInto, inspectedObjectLiteral, isFunction, pushIfNotPresent, isPlainObject, log, isString, getDetailedRequestTracingEnabled, Error, Promise, Request, merge, cleanStackTrace, formattedInspect, push, removeFirstMatch, isArray, sendRemoteRequest, currentSecond, present, config, getPipelineRestPath, getPipelineRestPathRegex, apiReport, DatabaseFilters) => {let Pipeline; return Pipeline = Caf.defClass(class Pipeline extends require('./RequestHandler') {constructor(_deprecatedOptions) {super(...arguments); this._subscribers = {}; this._querySubscribers = {}; if (_deprecatedOptions) {throw new Error("DEPRECATED: constructor options. For custom session, use: @registry new PipelineRegistry");};};}, function(Pipeline, classSuper, instanceSuper) {let noOptions, mostRecentSessionUpdatedAt; this.abstractClass(); this.register = function() {this.singletonClass(); return this.getRegistry().register(this);}; this.postCreateConcreteClass = function({hotReloaded}) {this._defineQueryHandlers(); this._defineClientHandlerMethods(); this._initFields(); if (!hotReloaded) {this.register();}; return classSuper.postCreateConcreteClass.apply(this, arguments);}; this.getAliases = function() {return this._aliases || {};}; this.extendableProperty({queries: {}, filters: [], handlers: {}, clientApiMethodList: [], fields: {}, publicRequestTypes: {}}); this.publicRequestTypes = function(...values) {let publicRequestTypes; publicRequestTypes = {}; Caf.each2(compactFlatten(values), (v) => Caf.each2(w(v), (k) => publicRequestTypes[k] = true)); return this.extendPublicRequestTypes(publicRequestTypes);}; this.publicHandlers = function(...maps) {return Caf.each2(maps, (map) => {this.handlers(map); return this.publicRequestTypes(Object.keys(map));});}; this.filter = function(filter) {return this.extendFilters(Filter.preprocessFilters(filter));}; this.handler = this.extendHandlers; this.handlers = this.extendHandlers; this.query = function(map) {return this.extendQueries(Caf.object(map, (options, queryName) => this._normalizeQuery(queryName, options)));}; this.aliases = function(...args) {this._aliases = Caf.object(args, (v, k) => true, null, null, (v, k) => lowerCamelCase(v)); return this;}; this.classGetter({pipelineName: function() {let temp; return ((temp = this._pipelineName) != null ? temp : decapitalize(this.getName()));}, pluralPipelineName: function() {let parts; if (this._pluralPipelineName) {return this._pluralPipelineName;}; parts = getCodeWords(this.getPipelineName()); parts.push(pluralize(parts.pop())); return this._pluralPipelineName = lowerCamelCase(parts);}}); this.getter({name: function() {return this.class.pipelineName;}, pipelineName: function() {return this.class.pipelineName;}, session: function() {return this.registry.session;}, normalizedFields: function() {let nf; nf = {}; Caf.each2(this.fields, (v, k) => nf[k] = normalizeFieldProps(v)); return nf;}, handlerRequestTypesMap: function(_into = {}) {return mergeInto(_into, this.handlers);}, filterRequestTypesMap: function(_into = {}) {return Caf.each2(this.filters, (filter) => mergeInto(_into, filter.beforeFilters), null, _into);}, requestTypesMap: function(_into = {}) {return this.getHandlerRequestTypesMap(this.getFilterRequestTypesMap(_into));}, requestTypes: function() {let temp; return ((temp = this._requestTypes) != null ? temp : this._requestTypes = Object.keys(this.requestTypesMap));}, aliases: function() {let temp; return ((temp = this._aliases) != null ? temp : this._aliases = Object.keys(this.class.getAliases()));}, groupedFilters: function() {let temp; return ((temp = this._groupedFilters) != null ? temp : this._groupedFilters = Pipeline.groupFilters(this.filters));}, beforeFilters: function() {let temp; return ((temp = this._beforeFilters) != null ? temp : this._beforeFilters = this.groupedFilters.slice().reverse());}, afterFilters: function() {return this.groupedFilters;}, filterChain: function() {return this._filterChain || (this._filterChain = compactFlatten([this, this.groupedFilters]).reverse());}}); this.prototype.toString = function() {return this.pipelineName;}; this.prototype.getLogName = function(requestType) {return `${Caf.toString(requestType)}-handler`;}; this.prototype.getRequestProcessingReport = function(location = this.location) {return Caf.object(this.requestTypes, (requestType) => compactFlatten([Caf.array(this.getBeforeFilters({requestType, location}), (filter) => inspectedObjectLiteral(filter.getName())), inspectedObjectLiteral((location === "client") ? "[remote request]" : "[local handler]"), Caf.array(this.getAfterFilters({requestType, location}), (filter) => inspectedObjectLiteral(filter.getName()))]));}; this.getter({pipelineReport: function(processingLocation) {let out; out = {tableName: this.tableName, fields: Caf.object(this.fields, (fieldProps) => {let out2; return Caf.each2(Object.keys(fieldProps).sort(), (k) => {let v; v = fieldProps[k]; return !isFunction(v) ? out2[k] = v : undefined;}, null, out2 = {});})}; if (processingLocation) {out[`${Caf.toString(processingLocation)}Processing`] = this.getRequestProcessingReport("client");} else {out.clientSideRequestProcessing = this.getRequestProcessingReport("client"); out.serverSideRequestProcessing = this.getRequestProcessingReport("server"); out.serverlessDevelopmentRequestProcessing = this.getRequestProcessingReport("both");}; return out;}, inspectedObjects: function() {return {name: this.name, publicRequestTypes: Object.keys(this.publicRequestTypes).sort(), requestTypes: Caf.array(this.requestTypes).sort(), subscriberCounts: Caf.object(this._subscribers, (subscribers) => subscribers.length), querySubscriberCounts: Caf.object(this._querySubscribers, (querySubs) => Caf.object(querySubs, (subscribers) => subscribers.length))};}}); this.groupFilters = function(filters) {let priorityLevels, sortedFilters; priorityLevels = []; Caf.each2(filters, ({priority}) => pushIfNotPresent(priorityLevels, priority)); sortedFilters = []; Caf.each2(priorityLevels.sort((a, b) => a - b), (priorityLevels) => Caf.each2(filters, (filter) => sortedFilters.push(filter), (filter) => priorityLevels === filter.priority)); return sortedFilters;}; this.prototype.getBeforeFilters = function(request) {return Caf.array(this.beforeFilters, null, (filter) => filter.getBeforeFilter(request));}; this.prototype.getAfterFilters = function(request) {return Caf.array(this.afterFilters, null, (filter) => filter.getAfterFilter(request));}; this.prototype.cachedGet = function(request, key) {return request.cachedGet(this.pipelineName, key != null ? key : request.key);}; this.prototype.createRequest = function(type, options) {let stack; if (!isPlainObject(options)) {log.warn("DEPRICATED - options must be an object now");}; if (isString(options)) {options = {key: options};}; if (getDetailedRequestTracingEnabled()) {stack = (new Error).stack;}; return Promise.then(() => options.session || this.session.loadedDataPromise).tapCatch((error) => log.error({Pipeline_createRequest: {message: "Error getting session", info: {pipelineName: this.pipelineName, type, options}, error}})).then((sessionData) => new Request(merge(options, {type, pipeline: this, session: sessionData, creationStack: stack}))).catch((error) => {if (stack != null) {error.stack = cleanStackTrace(stack);}; error.message += `\n\ninside ${Caf.toString(this.name)}.` + formattedInspect({createRequest: {type, options}}); return (() => {throw error;})();});}; this.prototype.subscribe = function(key, subscriber, queryName) {let subscribersForKey, temp, base; return !(Caf.in(subscriber, subscribersForKey = ((temp = (base = this._getSubscribers(queryName))[key]) != null ? temp : base[key] = []))) ? (push(subscribersForKey, subscriber), this.subscriberAdded(key, subscriber, queryName), subscriber) : undefined;}; this.prototype.unsubscribe = function(key, subscriber, queryName) {let subscribers, subscribersForKey; subscribers = this._getSubscribers(queryName); return (subscribersForKey = subscribers[key]) ? (removeFirstMatch(subscribersForKey, subscriber), (subscribersForKey.length === 0) ? (delete subscribers[key], this.subscriberRemoved(key, subscriber, queryName), subscriber) : undefined) : undefined;}; this.prototype._getSubscribers = function(queryName) {let temp, base; return queryName ? (!this.queries[queryName] ? (() => {throw new Error(`Query does not exist. Model: ${Caf.toString(this.name)}. Query: ${Caf.toString(queryName)}. Existing queries: ${Caf.toString(Object.keys(this.queries).join(", "))}`);})() : undefined, ((temp = (base = this._querySubscribers)[queryName]) != null ? temp : base[queryName] = {})) : this._subscribers;}; this.prototype.subscriberAdded = function(key, subscriber, queryName) {}; this.prototype.subscriberRemoved = function(key, subscriber, queryName) {}; this.prototype.dataUpdated = function(key, data) {return this._sendDataSubscriptionEvent("update", key, data);}; this.prototype.dataDeleted = function(key, data) {return this._sendDataSubscriptionEvent("delete", key, data);}; this.prototype._sendDataSubscriptionEvent = function(eventType, key, data) {let dataArray; return isArray(dataArray = data) ? Caf.each2(dataArray, (data) => this._sendDataSubscriptionEventSingle(eventType, key, data)) : this._sendDataSubscriptionEventSingle(eventType, key, data);}; this.prototype._sendDataSubscriptionEventSingle = function(eventType, key, data) {Caf.each2(this._subscribers[key], (subscriber) => subscriber(eventType, key, data)); return data && Caf.each2(this._querySubscribers, (querySubscribers, queryName) => {let queryKey; queryKey = this.queries[queryName].toKeyString(data); return Caf.each2(querySubscribers[queryKey], (subscriber) => subscriber(eventType, key, data, queryKey));});}; this.prototype.isUpdateRequestType = function(actionType) {return /^(create|update)/.test(actionType);}; this.prototype.isDeleteRequestType = function(actionType) {return /^delete/.test(actionType);}; this._defineQueryHandlers = function() {let handlers; handlers = this.getHandlers(); return Caf.each2(this.getQueries(), (pipelineQuery, k) => handlers = this.extendHandlers(k, pipelineQuery.options.query), (pipelineQuery, k) => !handlers[k]);}; this._normalizeQuery = function(queryName, options) {let dataToKeyString, toKeyString; if (isFunction(options)) {options = {query: options};}; if (!(isFunction(options.query) && options.query.length > 0)) {throw new Error(`query function must have at least one argument:\n\n${Caf.toString(formattedInspect({queryName, options}))}"`);}; ({dataToKeyString} = options); toKeyString = dataToKeyString ? (dataOrKey) => isPlainObject(dataOrKey) ? dataToKeyString(dataOrKey) : dataOrKey : (key) => (key != null) ? key.toString() : key; return {queryName, options, toKeyString};}; this._defineClientRequestMethod = function(requestType) {let temp, base; if (!(Caf.in(requestType, this.getClientApiMethodList()))) {this.extendClientApiMethodList(requestType);}; return ((temp = (base = this.prototype)[requestType]) != null ? temp : base[requestType] = function(a, b, c) {return this._processClientRequest(requestType, a, b, c);});}; this._defineClientHandlerMethods = function() {Caf.each2(this.getHandlers(), (__, name) => this._defineClientRequestMethod(name)); return Caf.each2(this.getPublicRequestTypes(), (__, name) => this._defineClientRequestMethod(name));}; this._initFields = function() {return Caf.each2(this.getFilters(), (filter) => this.extendFields(filter.fields));}; this.prototype._normalizeRequest = function(request) {return isPlainObject(request) ? new Request(merge(request, {pipeline: this})) : request;}; this.prototype.handleRequest = function(request) {let handler; if (request.isResponse) {throw new Error("HARD DEPRICATED");}; return (this.location === "client" && this.remoteServer) ? sendRemoteRequest(request) : (handler = this.handlers[request.type]) ? this.applyHandler(request, handler, "handler").then((response) => !response.isResponse ? request.failure(`${Caf.toString(this.pipelineName)}.${Caf.toString(request.type)} request was not handled`) : response) : request.failure(`${Caf.toString(this.pipelineName)}: No handler for request type: ${Caf.toString(formattedInspect(request.type))}`);}; this.prototype._processRequest = function(request) {let haveHandler, isPublicRequestType; haveHandler = !!this.handlers[request.type]; isPublicRequestType = !!this.getPublicRequestTypes()[request.type]; return !(haveHandler || isPublicRequestType) ? Promise.then(() => request.clientFailure({data: {message: `'${Caf.toString(request.type)}' is an invalid request type`, validRequestTypes: Object.keys(this.handlers)}})) : request.requireServerOriginOr(isPublicRequestType, "to issue non-public requests").then(() => this.filterChain[0].handleRequest(request, this.filterChain, 0)).tap((response) => !response.isResponse ? log.error({"not response!": response}) : undefined);}; noOptions = {}; this.prototype._processClientRequest = function(type, a, b, c) {let parentRequest, options, requestStartTime; if (!(a != null)) {a = b; b = c;}; if (a != null && a instanceof Request) {parentRequest = a; a = b; b = c;}; options = isString(a) ? merge({key: a}, b) : a != null ? a : noOptions; return parentRequest ? parentRequest.subrequest(this, type, (options !== noOptions) ? options : {props: parentRequest.props}) : (requestStartTime = currentSecond(), this.createRequest(type, options).then((request) => this._processRequest(request)).then((response) => this._processResponseSession(response, requestStartTime)).then((response) => response.toPromise(options)));}; mostRecentSessionUpdatedAt = 0; this.prototype._processResponseSession = function(response, requestStartTime) {let responseSession, currentSession, message; if (responseSession = response.responseSession) {currentSession = this.session.data; message = (requestStartTime > mostRecentSessionUpdatedAt) ? (mostRecentSessionUpdatedAt = requestStartTime, this.session.data = responseSession, "updated") : "out-of-order update blocked";}; return response;}; this.prototype.toKeyString = function(key) {return (() => {switch (false) {case !(!(key != null) || isString(key)): return key; case !(this.dataToKeyString && isPlainObject(key)): return this.dataToKeyString(key); default: return (() => {throw new Error(`override toKeyString or dataToKeyString for non-string-keys like: ${Caf.toString(formattedInspect(key))}`);})();};})();}; this.getter({propsToKey: function() {let temp; return ((temp = this._propsToKey) != null ? temp : this._propsToKey = (() => {let recordType; recordType = this.pipelineName; return (props, stateField) => {let propsField, temp1, base; propsField = stateField != null ? stateField : recordType; return ((temp1 = Caf.exists(base = props[propsField]) && base.id) != null ? temp1 : props[propsField + "Id"]);};})());}}); this.prototype.isRecord = function(data) {return isPlainObject(data) && present(Caf.exists(data) && data.id);}; this.prototype.getFieldsRequestWillModify = function(request) {let temp; return ((temp = request.data) != null ? temp : {});}; this.getter({isRemoteClient: function() {return !!this.remoteServer;}, apiRoot: function() {let temp; return ((temp = this.class._apiRoot) != null ? temp : config._apiRoot);}, remoteServer: function() {let temp; return ((temp = this.class._remoteServer) != null ? temp : config.remoteServer);}, restPath: function() {let temp; return ((temp = this._restPath) != null ? temp : this._restPath = getPipelineRestPath(this));}, restPathRegex: function() {let temp; return ((temp = this._restPathRegex) != null ? temp : this._restPathRegex = getPipelineRestPathRegex(this));}, location: function() {return (this.remoteServer && config.location !== "server") ? "client" : config.location;}}); this.remoteServer = function(_remoteServer) {this._remoteServer = _remoteServer;}; this.apiRoot = function(_apiRoot) {this._apiRoot = _apiRoot;}; this.getter({apiReport: function(options = {}) {return apiReport(this, options);}}); this.addDatabaseFilters = function(options) {return this.filter(DatabaseFilters.createDatabaseFilters(options, this));}; this.addDatabaseFiltersV2 = function(options) {return this.filter(DatabaseFilters.createDatabaseFilters(merge({linkFilterVersion: 2}, options), this));}; this.tableNamePrefix = function(_tableNamePrefix) {this._tableNamePrefix = _tableNamePrefix;}; this.prototype.getPrefixedTableName = function(tableName) {return `${Caf.toString(this.tableNamePrefix)}${Caf.toString(tableName)}`;}; this.getter({tableNamePrefix: function() {let temp; return ((temp = this.class._tableNamePrefix) != null ? temp : config.tableNamePrefix);}, tableName: function() {return this.getPrefixedTableName(this.name);}, prefetchedRecordsCache: function() {return this.registry.prefetchedRecordsCache;}}); this.prototype.getPrefetchedRecord = function(key) {return this.prefetchedRecordsCache.get(this.pipelineName, key);};});});});
//# sourceMappingURL=Pipeline.js.map
