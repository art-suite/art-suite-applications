// Generated by CoffeeScript 1.12.7
(function() {
  var BaseObject, CommunicationStatus, DatabaseFilters, Filter, Filters, Pipeline, PipelineRegistry, Promise, Request, RequestResponseBase, Response, Session, arrayToTruthMap, cleanStackTrace, compactFlatten, config, currentSecond, decapitalize, defineModule, each, escapeRegExp, formattedInspect, getCodeWords, getDetailedRequestTracingEnabled, getEnv, inspect, inspectedObjectLiteral, isClass, isFunction, isPlainArray, isPlainObject, isString, log, lowerCamelCase, merge, mergeInto, missing, normalizeFieldProps, object, peek, plainObjectsDeepEq, pluralize, prefetchedRecordsCache, present, pushIfNotPresent, ref, reverseForEach, success, toDate, w,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ref = require('./StandardImport'), each = ref.each, object = ref.object, compactFlatten = ref.compactFlatten, BaseObject = ref.BaseObject, reverseForEach = ref.reverseForEach, Promise = ref.Promise, log = ref.log, isPlainObject = ref.isPlainObject, inspect = ref.inspect, isString = ref.isString, isClass = ref.isClass, isFunction = ref.isFunction, inspect = ref.inspect, CommunicationStatus = ref.CommunicationStatus, merge = ref.merge, isPlainArray = ref.isPlainArray, decapitalize = ref.decapitalize, defineModule = ref.defineModule, mergeInto = ref.mergeInto, arrayToTruthMap = ref.arrayToTruthMap, lowerCamelCase = ref.lowerCamelCase, peek = ref.peek, inspectedObjectLiteral = ref.inspectedObjectLiteral, escapeRegExp = ref.escapeRegExp, formattedInspect = ref.formattedInspect, pushIfNotPresent = ref.pushIfNotPresent, w = ref.w, currentSecond = ref.currentSecond, toDate = ref.toDate, plainObjectsDeepEq = ref.plainObjectsDeepEq, getCodeWords = ref.getCodeWords, pluralize = ref.pluralize, present = ref.present, getEnv = ref.getEnv, success = ref.success, missing = ref.missing, getDetailedRequestTracingEnabled = ref.getDetailedRequestTracingEnabled, cleanStackTrace = ref.cleanStackTrace;

  normalizeFieldProps = require('art-validation').normalizeFieldProps;

  prefetchedRecordsCache = require('./PrefetchedRecordsCache').prefetchedRecordsCache;

  Response = require('./Response');

  Request = require('./Request');

  Filter = require('./Filter');

  DatabaseFilters = require('./DatabaseFilters');

  Session = require('./Session');

  config = require('./Config').config;

  Filters = require('./Filters');

  PipelineRegistry = require('./PipelineRegistry');

  RequestResponseBase = require('./RequestResponseBase');


  /*
  TODO: (July2019)
    Factor out all ArtFlux-related stuff
      ArtEry should be independent of ArtFlux or any other client-side state-management-system.
  
      Remaining:
  
        fluxModelMixins -
          This lets you customize what time of Object is created
          for your models. ArtEry shouldn't know anything about creating models, though...
  
          However, I DO want a way to declare this info in the Pipeline declaration
          to reduce redundency.
  
        query:
          Another declaration passed directly to ArtFlux
  
        aliases:
          Another declaration passed directly to ArtFlux
  
      Perhaps we need a subclass: PipelineWithFluxModel?
  
    Namespaced-Registry
  
      I still don't quite know how I want to do this, but I want BOTH ArtFlux (ArtModels?)
      and ArtEry (ArtPipelines?) to have namespaced registries so you can merge as many
      packages as you want based on ArtSuite without name-conflicts in their registries.
   */

  defineModule(module, Pipeline = (function(superClass) {
    var instantiateFilter, mostRecentSessionUpdatedAt, noOptions, preprocessFilter;

    extend(Pipeline, superClass);

    Pipeline.register = function() {
      this.singletonClass();
      return PipelineRegistry.register(this);
    };

    Pipeline.abstractClass();

    Pipeline.postCreateConcreteClass = function(arg) {
      var hotReloaded;
      hotReloaded = arg.hotReloaded;
      this._defineQueryHandlers();
      this._defineClientHandlerMethods();
      this._initFields();
      if (!hotReloaded) {
        this.register();
      }
      return Pipeline.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
    };

    Pipeline.instantiateFilter = instantiateFilter = function(filter) {
      if (isClass(filter)) {
        return new filter;
      } else if (isFunction(filter)) {
        return filter(this);
      } else if (filter instanceof Filter) {
        return filter;
      } else if (isPlainObject(filter)) {
        return new Filter(filter);
      } else {
        throw "invalid filter: " + (inspect(filter)) + " " + (filter instanceof Filter);
      }
    };

    Pipeline.getAliases = function() {
      return this._aliases || {};
    };

    Pipeline.addDatabaseFilters = function(options) {
      return this.filter(DatabaseFilters.createDatabaseFilters(options, this));
    };

    Pipeline.addDatabaseFiltersV2 = function(options) {
      return this.filter(DatabaseFilters.createDatabaseFilters(merge({
        linkFilterVersion: 2
      }, options), this));
    };

    Pipeline.prototype.getPrefetchedRecord = function(key) {
      return prefetchedRecordsCache.get(this.pipelineName, key);
    };

    Pipeline.prototype.toKeyString = function(key) {
      if (key == null) {
        return key;
      }
      if (isString(key)) {
        return key;
      } else if (this.dataToKeyString && isPlainObject(key)) {
        return this.dataToKeyString(key);
      } else {
        throw new Error("override toKeyString or dataToKeyString for non-string-keys like: " + (formattedInspect(key)));
      }
    };

    Pipeline.prototype.isRecord = function(data) {
      return isPlainObject(data) && present(data != null ? data.id : void 0);
    };

    Pipeline.prototype.getFieldsRequestWillModify = function(request) {
      var ref1;
      return (ref1 = request.data) != null ? ref1 : {};
    };

    Pipeline.extendableProperty({
      queries: {},
      filters: [],
      handlers: {},
      clientApiMethodList: [],
      fields: {},
      fluxModelMixins: [],
      publicRequestTypes: {}
    });

    Pipeline.publicRequestTypes = function() {
      var i, j, k, len, len1, publicRequestTypes, ref1, ref2, v, values;
      values = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      publicRequestTypes = {};
      ref1 = compactFlatten(values);
      for (i = 0, len = ref1.length; i < len; i++) {
        v = ref1[i];
        ref2 = w(v);
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          k = ref2[j];
          publicRequestTypes[k] = true;
        }
      }
      return this.extendPublicRequestTypes(publicRequestTypes);
    };

    Pipeline.publicHandlers = function() {
      var i, len, map, maps, results;
      maps = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      results = [];
      for (i = 0, len = maps.length; i < len; i++) {
        map = maps[i];
        this.handlers(map);
        results.push(this.publicRequestTypes(Object.keys(map)));
      }
      return results;
    };


    /*
    @artModelMixen adds a mixin to fluxModelMixins
    
    When createing FluxModels for this pipeline (via ArtEryFluxModel.createModel for example),
    both the records model and each query-model will get these mixins.
    
    Example:
      class MyPipeline extends Pipeline
        @artModelMixen FluxModelMixinA
        @artModelMixen FluxModelMixinB
    
       * this action
      ArtEryFluxModel.defineModelsForAllPipelines()
    
       * defines this model:
      class MyPipeline extends FluxModelMixinB FluxModelMixinA ArtEryFluxModel
     */

    Pipeline.artModelMixen = function(mixin) {
      return this.extendFluxModelMixins(mixin);
    };


    /*
    define a single filter OR an array of filters to define.
    
    NOTE: the order of filter definitions matter:
      last-defined filters FIRST in the before-filter sequence
      last-defined filters LAST in the after-filter sequence
    
      Example request processing sequence:
    
        filterDefinedLast.beforeFilter
          filterDefinedSecond.beforeFilter
            filterDefinedFirst.beforeFilter
              handler
            filterDefinedFirst.afterFilter
          filterDefinedSecond.afterFilter
        filterDefinedLast.afterFilter
    
    IN:
      name: "myFilter"                    # only used for debug purposes
      location: "server"/"client"/"both"  # where the filter will be applied
      before: map:
        requestType: (request) ->
          OUT one of these (or a promise returning one of these):
            request
            - the same request if nothing was filtered
            - a new request with the new, filtered values
    
            response in the form of:
            - new Response
            - null        >> request.missing()
            - string      >> request.success data: message: string
            - plainObject >> request.success data: plainObject
            - plainArray  >> request.success data: plainArray
            NOTE, if a response is returned, it shortcircuits the handler and all other
              filters. The response is returned directly to the caller.
    
      after: map:
        requestType: (response) ->
          OUT: same or new response
             NOTE: all after-filters are applied if the handler generated the first response object
             UNLESS there is an error, in which case the error is returned directly.
     */

    Pipeline.filter = function(filter) {
      return this.extendFilters(preprocessFilter(filter));
    };


    /*
    add one or more handlers
    
    IN map:
      requestType: (request) ->
        IN: ArtEry.Request instance
        OUT:
          ArtEry.Response instance
        OR
          plain data which will be wrapped up in an ArtEry.Response instance
    
    @handler and @handlers are aliases.
     */

    Pipeline.handler = Pipeline.extendHandlers;

    Pipeline.handlers = Pipeline.extendHandlers;

    Pipeline.remoteServer = function(_remoteServer) {
      this._remoteServer = _remoteServer;
    };

    Pipeline.apiRoot = function(_apiRoot) {
      this._apiRoot = _apiRoot;
    };

    Pipeline.tableNamePrefix = function(_tableNamePrefix) {
      this._tableNamePrefix = _tableNamePrefix;
    };


    /*
    declare a query - used by ArtEryFlux
    
    IN: map:
      queryName: map:
        class properties for anonymous subclass of ArtEryQueryFluxModel
    
    queryName is used as both the ArtFlux model-name AND the ArtEry request-type:
      Example:
         * invoke query
        myPipeline.myQueryName key: queryKey
    
         * subscribe to Model in FluxComponent
        @subscriptions
          myQueryName: queryKey
     */

    Pipeline.query = function(map) {
      return this.extendQueries(object(map, (function(_this) {
        return function(options, queryName) {
          return _this._normalizeQuery(queryName, options);
        };
      })(this)));
    };


    /*
    aliases
    
    INPUT: zero or more strings or arrays of strings
      - arbitrary nesting of arrays is OK
      - nulls are OK, they are ignored
    OUTPUT: null
    
    NOTE: @aliases can only be called once
    
    example:
      class Post extends Pipeline
        @aliases "chapterPost"
    
    purpose:
      - used by ArtEryFluxComponent to make model aliases
        (see FluxModel.aliases)
     */

    Pipeline.aliases = function() {
      var map;
      this._aliases = each(arguments, map = {}, function(v, k) {
        return map[lowerCamelCase(v)] = true;
      });
      return this;
    };

    function Pipeline(_options) {
      this._options = _options != null ? _options : {};
      this.getPrefixedTableName = bind(this.getPrefixedTableName, this);
      Pipeline.__super__.constructor.apply(this, arguments);
    }

    Pipeline.prototype.getPrefixedTableName = function(tableName) {
      return "" + this.tableNamePrefix + tableName;
    };


    /* cachedGet - convenient alias altenative to request.cachedGet that matches the new subrequest patterns
      IN:
        request: - the request this will be a subrequest-of
        key: <String> (default: request.key)
    
      EFFECT:
        calls request.cachedGet. Note, cachedGet's cache is stored in request's context
     */

    Pipeline.prototype.cachedGet = function(request, key) {
      return request.cachedGet(this.pipelineName, key != null ? key : request.key);
    };

    Pipeline.classGetter({
      pipelineName: function() {
        return this._pipelineName || decapitalize(this.getName());
      },
      pluralPipelineName: function() {
        var parts;
        if (this._pluralPipelineName) {
          return this._pluralPipelineName;
        }
        parts = getCodeWords(this.getPipelineName());
        parts.push(pluralize(parts.pop()));
        return this._pluralPipelineName = lowerCamelCase(parts);
      }
    });

    Pipeline.prototype.toString = function() {
      return this.pipelineName;
    };

    Pipeline.prototype.getLogName = function(requestType) {
      return requestType + "-handler";
    };

    Pipeline.getter("options", {
      pipelineName: function() {
        return this["class"].getPipelineName();
      },
      tableNamePrefix: function() {
        return this["class"]._tableNamePrefix || config.tableNamePrefix;
      },
      tableName: function() {
        return this.getPrefixedTableName(this.name);
      },
      normalizedFields: function() {
        var k, nf, ref1, v;
        nf = {};
        ref1 = this.fields;
        for (k in ref1) {
          v = ref1[k];
          nf[k] = normalizeFieldProps(v);
        }
        return nf;
      },
      name: function() {
        return this._name || (this._name = this._options.name || decapitalize(this["class"].getName()));
      },
      session: function() {
        return this._session || (this._session = this._options.session || Session.singleton);
      },
      handlerRequestTypesMap: function(into) {
        if (into == null) {
          into = {};
        }
        mergeInto(into, this.handlers);
        return into;
      },
      filterRequestTypesMap: function(into) {
        var filter, i, len, ref1;
        if (into == null) {
          into = {};
        }
        ref1 = this.filters;
        for (i = 0, len = ref1.length; i < len; i++) {
          filter = ref1[i];
          mergeInto(into, filter.beforeFilters);
        }
        return into;
      },
      requestTypesMap: function(into) {
        if (into == null) {
          into = {};
        }
        return this.getHandlerRequestTypesMap(this.getFilterRequestTypesMap(into));
      },
      requestTypes: function() {
        return Object.keys(this.requestTypesMap);
      },
      aliases: function() {
        return Object.keys(this["class"].getAliases());
      },
      inspectedObjects: function() {
        return inspectedObjectLiteral(this.name);
      },
      isRemoteClient: function() {
        return !!this.remoteServer;
      },
      apiRoot: function() {
        return this["class"]._apiRoot || config._apiRoot;
      },
      remoteServer: function() {
        return this["class"]._remoteServer || config.remoteServer;
      },
      location: function() {
        if (this.remoteServer && config.location !== "server") {
          return "client";
        } else {
          return config.location;
        }
      },
      restPath: function() {
        return this._restPath || (this._restPath = "/" + config.apiRoot + "/" + this.name);
      },
      restPathRegex: function() {
        return this._restPathRegex || (this._restPathRegex = RegExp("^" + (escapeRegExp(this.restPath)) + "(?:-([a-z0-9_]+))?(?:\\/([^?]+))?(?=\\?|$)", "i"));
      },
      groupedFilters: function() {
        return this._groupedFilters || (this._groupedFilters = Pipeline.groupFilters(this.filters));
      },
      beforeFilters: function() {
        return this._beforeFilters || (this._beforeFilters = this.groupedFilters.slice().reverse());
      },
      afterFilters: function() {
        return this.groupedFilters;
      },
      status: function() {
        return "OK";
      },
      filterChain: function() {
        return this._filterChain || (this._filterChain = compactFlatten([this, this.groupedFilters]).reverse());
      }
    });

    Pipeline.groupFilters = function(filters) {
      var filter, i, j, l, len, len1, len2, priority, priorityLevels, ref1, sortedFilters;
      priorityLevels = [];
      for (i = 0, len = filters.length; i < len; i++) {
        priority = filters[i].priority;
        pushIfNotPresent(priorityLevels, priority);
      }
      sortedFilters = [];
      ref1 = priorityLevels.sort(function(a, b) {
        return a - b;
      });
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        priorityLevels = ref1[j];
        for (l = 0, len2 = filters.length; l < len2; l++) {
          filter = filters[l];
          if (priorityLevels === filter.priority) {
            sortedFilters.push(filter);
          }
        }
      }
      return sortedFilters;
    };

    Pipeline.prototype.getBeforeFilters = function(request) {
      var filter, i, len, ref1, results;
      ref1 = this.beforeFilters;
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        filter = ref1[i];
        if (filter.getBeforeFilter(request)) {
          results.push(filter);
        }
      }
      return results;
    };

    Pipeline.prototype.getAfterFilters = function(request) {
      var filter, i, len, ref1, results;
      ref1 = this.afterFilters;
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        filter = ref1[i];
        if (filter.getAfterFilter(request)) {
          results.push(filter);
        }
      }
      return results;
    };

    Pipeline.prototype.createRequest = function(type, options) {
      var stack;
      if (!isPlainObject(options)) {
        log.warn("DEPRICATED - options must be an object now");
      }
      if (isString(options)) {
        options = {
          key: options
        };
      }
      if (getDetailedRequestTracingEnabled()) {
        stack = (new Error).stack;
      }
      return Promise.then((function(_this) {
        return function() {
          return options.session || _this.session.loadedDataPromise;
        };
      })(this)).tapCatch((function(_this) {
        return function(error) {
          return log.error({
            Pipeline_createRequest: {
              message: "Error getting session",
              info: {
                pipelineName: _this.pipelineName,
                type: type,
                options: options
              },
              error: error
            }
          });
        };
      })(this)).then((function(_this) {
        return function(sessionData) {
          return new Request(merge(options, {
            type: type,
            pipeline: _this,
            session: sessionData,
            creationStack: stack
          }));
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          if (stack != null) {
            error.stack = cleanStackTrace(stack);
          }
          error.message += ("\n\ninside " + _this.name + ".") + formattedInspect({
            createRequest: {
              type: type,
              options: options
            }
          });
          throw error;
        };
      })(this));
    };

    Pipeline.prototype.getRequestProcessingReport = function(location) {
      if (location == null) {
        location = this.location;
      }
      return object(this.requestTypes, (function(_this) {
        return function(requestType) {
          var filter;
          return compactFlatten([
            (function() {
              var i, len, ref1, results;
              ref1 = this.getBeforeFilters({
                requestType: requestType,
                location: location
              });
              results = [];
              for (i = 0, len = ref1.length; i < len; i++) {
                filter = ref1[i];
                results.push(inspectedObjectLiteral(filter.getName()));
              }
              return results;
            }).call(_this), inspectedObjectLiteral(location === "client" ? "[remote request]" : "[local handler]"), (function() {
              var i, len, ref1, results;
              ref1 = this.getAfterFilters({
                requestType: requestType,
                location: location
              });
              results = [];
              for (i = 0, len = ref1.length; i < len; i++) {
                filter = ref1[i];
                results.push(inspectedObjectLiteral(filter.getName()));
              }
              return results;
            }).call(_this)
          ]);
        };
      })(this));
    };

    Pipeline.getter({
      pipelineReport: function(processingLocation) {
        var out;
        out = {
          tableName: this.tableName,
          fields: object(this.fields, function(fieldProps) {
            return each(Object.keys(fieldProps).sort(), out = {}, function(k) {
              var v;
              v = fieldProps[k];
              if (!isFunction(v)) {
                return out[k] = v;
              }
            });
          })
        };
        if (processingLocation) {
          out[processingLocation + "Processing"] = this.getRequestProcessingReport("client");
        } else {
          out.clientSideRequestProcessing = this.getRequestProcessingReport("client");
          out.serverSideRequestProcessing = this.getRequestProcessingReport("server");
          out.serverlessDevelopmentRequestProcessing = this.getRequestProcessingReport("both");
        }
        return out;
      },
      apiReport: function(options) {
        var publicOnly, server;
        if (options == null) {
          options = {};
        }
        server = options.server, publicOnly = options.publicOnly;
        return object(this.requestTypes, {
          when: publicOnly && (function(_this) {
            return function(type) {
              return _this.getPublicRequestTypes()[type];
            };
          })(this),
          "with": (function(_this) {
            return function(type) {
              var method, obj, ref1, url;
              ref1 = Request.getRestClientParamsForArtEryRequest({
                server: _this.remoteServer || server,
                type: type,
                restPath: _this.restPath
              }), method = ref1.method, url = ref1.url;
              return (
                obj = {},
                obj["" + (method.toLocaleUpperCase())] = url,
                obj
              );
            };
          })(this)
        });
      }
    });

    Pipeline.prototype.handleRequest = function(request) {
      var handler;
      if (request.isResponse) {
        throw new Error("HARD DEPRICATED");
      }
      if (this.location === "client" && this.remoteServer) {
        return request.sendRemoteRequest(this.remoteServer);
      } else if (handler = this.handlers[request.type]) {
        return this.applyHandler(request, handler, "handler").then((function(_this) {
          return function(response) {
            if (!response.isResponse) {
              return request.failure(_this.pipelineName + "." + request.type + " request was not handled");
            } else {
              return response;
            }
          };
        })(this));
      } else {
        return request.failure(this.pipelineName + ": No handler for request type: " + (formattedInspect(request.type)));
      }
    };

    Pipeline.getter({
      propsToKey: function() {
        return this._propsToKey != null ? this._propsToKey : this._propsToKey = (function(_this) {
          return function() {
            var recordType;
            recordType = _this.pipelineName;
            return function(props, stateField) {
              var propsField, ref1, ref2;
              propsField = stateField != null ? stateField : recordType;
              return (ref1 = (ref2 = props[propsField]) != null ? ref2.id : void 0) != null ? ref1 : props[propsField + "Id"];
            };
          };
        })(this)();
      }
    });

    preprocessFilter = function(filter) {
      var f, i, len, results;
      if (isPlainArray(filter)) {
        results = [];
        for (i = 0, len = filter.length; i < len; i++) {
          f = filter[i];
          if (f) {
            results.push(instantiateFilter(f));
          }
        }
        return results;
      } else {
        return instantiateFilter(filter);
      }
    };


    /*
    query handler-functions: (request) -> response or any other value allowed for handlers
     */

    Pipeline._defineQueryHandlers = function() {
      var handlers, k, pipelineQuery, ref1, results;
      handlers = this.getHandlers();
      ref1 = this.getQueries();
      results = [];
      for (k in ref1) {
        pipelineQuery = ref1[k];
        if (!handlers[k]) {
          results.push(handlers = this.extendHandlers(k, pipelineQuery.options.query));
        }
      }
      return results;
    };

    Pipeline._normalizeQuery = function(queryName, options) {
      if (isFunction(options)) {
        options = {
          query: options
        };
      }
      if (!(isFunction(options.query) && options.query.length > 0)) {
        throw new Error("query function must have at least one argument:\n\n" + (formattedInspect({
          queryName: queryName,
          options: options
        })) + "\"");
      }
      return {
        queryName: queryName,
        options: options
      };
    };

    Pipeline.prototype._normalizeRequest = function(request) {
      if (isPlainObject(request)) {
        return new Request(merge(request, {
          pipeline: this
        }));
      } else {
        return request;
      }
    };

    Pipeline.prototype._processRequest = function(request) {
      var haveHandler, isPublicRequestType;
      haveHandler = !!this.handlers[request.type];
      isPublicRequestType = !!this.getPublicRequestTypes()[request.type];
      if (!(haveHandler || isPublicRequestType)) {
        return Promise.then((function(_this) {
          return function() {
            return request.clientFailure({
              data: {
                message: "'" + request.type + "' is an invalid request type",
                validRequestTypes: Object.keys(_this.handlers)
              }
            });
          };
        })(this));
      } else {
        return request.requireServerOriginOr(isPublicRequestType, "to issue non-public requests").then((function(_this) {
          return function() {
            return _this.filterChain[0].handleRequest(request, _this.filterChain, 0);
          };
        })(this)).then(function(response) {
          if (!response.isResponse) {
            log.error({
              "not response!": response
            });
          }
          return response;
        });
      }
    };


    /*
    IN:
      LEGAL SIGNATURES:
        type, options?
        type, key?, options?
        type, parentRequest?, options?
        type, parentRequest?, key?, options?
    
      type:           request type string
      parentRequest:  if present, this becomes a subreqest
      key:            merged with options: merge {key}, options
      options:
        Passed directly to:
          Request constructor
          AND response.toPromise
    
    OUT: SEE: response.toPromise
     */

    noOptions = {};

    Pipeline.prototype._processClientRequest = function(type, a, b, c) {
      var options, parentRequest, requestStartTime;
      if (a == null) {
        a = b;
        b = c;
      }
      if ((a != null) && a instanceof RequestResponseBase) {
        parentRequest = a;
        a = b;
        b = c;
      }
      options = isString(a) ? merge({
        key: a
      }, b) : a != null ? a : noOptions;
      if (parentRequest) {
        return parentRequest.subrequest(this, type, options !== noOptions ? options : {
          props: parentRequest.props
        });
      } else {
        requestStartTime = currentSecond();
        return this.createRequest(type, options).then((function(_this) {
          return function(request) {
            return _this._processRequest(request);
          };
        })(this)).then((function(_this) {
          return function(response) {
            return _this._processResponseSession(response, requestStartTime);
          };
        })(this)).then((function(_this) {
          return function(response) {
            return response.toPromise(options);
          };
        })(this));
      }
    };


    /* _processResponseSession
      mostRecentSessionUpdatedAt ensures we don't update the session out of order
      RULE: the current session reflects the response from the most recently INITIATED request.
      In other words, if a request stalls, takes a long time to update, and comes back with
      a session update AFTER some other session updates from more recently-initiated requests,
      that session-update is ignored.
      keywords: update session
    
      ALTERNATIVES CONSIDERED
      - could use a server-side timestamp to ensure no out-of-order session updates
        SUBOPTION A: order by time server RECEIVED the request
        SUBOPTION B: order by time server COMPLETED the request
        I decided this made less sense. It's really the order the user initiated
        events that matters. If a user initiates a log-in or log-out request AFTER
        some other slow request, the log-in/log-out should take precidence.
        Extreme example: user logs in, which takes forever, then initiates a log-out,
          if the log-in returns AFTER the log-out, it should be ignored.
     */

    mostRecentSessionUpdatedAt = 0;

    Pipeline.prototype._processResponseSession = function(response, requestStartTime) {
      var currentSession, responseSession;
      responseSession = response.responseSession;
      if (responseSession) {
        currentSession = this.session.data;
        if (requestStartTime > mostRecentSessionUpdatedAt) {
          mostRecentSessionUpdatedAt = requestStartTime;
          this.session.data = responseSession;
        }
      }
      return response;
    };

    Pipeline._defineClientRequestMethod = function(requestType) {
      var base;
      if (indexOf.call(this.getClientApiMethodList(), requestType) < 0) {
        this.extendClientApiMethodList(requestType);
      }
      return (base = this.prototype)[requestType] || (base[requestType] = function(a, b, c) {
        return this._processClientRequest(requestType, a, b, c);
      });
    };

    Pipeline._defineClientHandlerMethods = function() {
      var __, handler, name, ref1, ref2;
      ref1 = this.getHandlers();
      for (name in ref1) {
        handler = ref1[name];
        this._defineClientRequestMethod(name);
      }
      ref2 = this.getPublicRequestTypes();
      for (name in ref2) {
        __ = ref2[name];
        this._defineClientRequestMethod(name);
      }
      return null;
    };

    Pipeline._initFields = function() {
      var filter, i, len, ref1, results;
      ref1 = this.getFilters();
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        filter = ref1[i];
        results.push(this.extendFields(filter.fields));
      }
      return results;
    };

    return Pipeline;

  })(require('./RequestHandler')));

}).call(this);

//# sourceMappingURL=Pipeline.js.map
