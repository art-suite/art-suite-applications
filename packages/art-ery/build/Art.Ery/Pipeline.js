"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["isPlainArray", "isClass", "isFunction", "Filter", "isPlainObject", "inspect", "PipelineRegistry", "DatabaseFilters", "merge", "prefetchedRecordsCache", "isString", "Error", "formattedInspect", "present", "compactFlatten", "w", "Object", "lowerCamelCase", "decapitalize", "getCodeWords", "pluralize", "config", "normalizeFieldProps", "Session", "mergeInto", "inspectedObjectLiteral", "escapeRegExp", "pushIfNotPresent", "log", "getDetailedRequestTracingEnabled", "Promise", "Request", "cleanStackTrace", "removeFirstMatch", "isArray", "RequestResponseBase", "currentSecond"], [global, require('./StandardImport'), require('art-validation'), require('./PrefetchedRecordsCache'), require('./Config'), {Response: require('./Response'), Request: require('./Request'), Filter: require('./Filter'), DatabaseFilters: require('./DatabaseFilters'), Session: require('./Session'), Filters: require('./Filters'), PipelineRegistry: require('./PipelineRegistry'), RequestResponseBase: require('./RequestResponseBase')}], (isPlainArray, isClass, isFunction, Filter, isPlainObject, inspect, PipelineRegistry, DatabaseFilters, merge, prefetchedRecordsCache, isString, Error, formattedInspect, present, compactFlatten, w, Object, lowerCamelCase, decapitalize, getCodeWords, pluralize, config, normalizeFieldProps, Session, mergeInto, inspectedObjectLiteral, escapeRegExp, pushIfNotPresent, log, getDetailedRequestTracingEnabled, Promise, Request, cleanStackTrace, removeFirstMatch, isArray, RequestResponseBase, currentSecond) => {let preprocessFilter, instantiateFilter, Pipeline; preprocessFilter = function(filter) {return isPlainArray(filter) ? Caf.each2(filter, (f) => instantiateFilter(f), (f) => f) : instantiateFilter(filter);}; instantiateFilter = function(filter) {return isClass(filter) ? new filter : isFunction(filter) ? filter(this) : (filter instanceof Filter) ? filter : isPlainObject(filter) ? new Filter(filter) : (() => {throw `invalid filter: ${Caf.toString(inspect(filter))} ${Caf.toString(filter instanceof Filter)}`;})();}; return Pipeline = Caf.defClass(class Pipeline extends require('./RequestHandler') {constructor(_options = {}) {super(...arguments); this._options = _options; this._subscribers = [];};}, function(Pipeline, classSuper, instanceSuper) {let noOptions, mostRecentSessionUpdatedAt; this.abstractClass(); this.register = function() {this.singletonClass(); return PipelineRegistry.register(this);}; this.postCreateConcreteClass = function({hotReloaded}) {this._defineQueryHandlers(); this._defineClientHandlerMethods(); this._initFields(); if (!hotReloaded) {this.register();}; return classSuper.postCreateConcreteClass.apply(this, arguments);}; this.instantiateFilter = instantiateFilter; this.getAliases = function() {return this._aliases || {};}; this.addDatabaseFilters = function(options) {return this.filter(DatabaseFilters.createDatabaseFilters(options, this));}; this.addDatabaseFiltersV2 = function(options) {return this.filter(DatabaseFilters.createDatabaseFilters(merge({linkFilterVersion: 2}, options), this));}; this.prototype.getPrefetchedRecord = function(key) {return prefetchedRecordsCache.get(this.pipelineName, key);}; this.prototype.toKeyString = function(key) {return (() => {switch (false) {case !(!(key != null) || isString(key)): return key; case !(this.dataToKeyString && isPlainObject(key)): return this.dataToKeyString(key); default: return (() => {throw new Error(`override toKeyString or dataToKeyString for non-string-keys like: ${Caf.toString(formattedInspect(key))}`);})();};})();}; this.prototype.isRecord = function(data) {return isPlainObject(data) && present(Caf.exists(data) && data.id);}; this.prototype.getFieldsRequestWillModify = function(request) {let temp; return ((temp = request.data) != null ? temp : {});}; this.extendableProperty({queries: {}, filters: [], handlers: {}, clientApiMethodList: [], fields: {}, publicRequestTypes: {}}); this.publicRequestTypes = function(...values) {let publicRequestTypes; publicRequestTypes = {}; Caf.each2(compactFlatten(values), (v) => Caf.each2(w(v), (k) => publicRequestTypes[k] = true)); return this.extendPublicRequestTypes(publicRequestTypes);}; this.publicHandlers = function(...maps) {return Caf.each2(maps, (map) => {this.handlers(map); return this.publicRequestTypes(Object.keys(map));});}; this.filter = function(filter) {return this.extendFilters(preprocessFilter(filter));}; this.handler = this.extendHandlers; this.handlers = this.extendHandlers; this.remoteServer = function(_remoteServer) {this._remoteServer = _remoteServer;}; this.apiRoot = function(_apiRoot) {this._apiRoot = _apiRoot;}; this.tableNamePrefix = function(_tableNamePrefix) {this._tableNamePrefix = _tableNamePrefix;}; this.query = function(map) {return this.extendQueries(Caf.object(map, (options, queryName) => this._normalizeQuery(queryName, options)));}; this.aliases = function(...args) {this._aliases = Caf.object(args, (v, k) => true, null, null, (v, k) => lowerCamelCase(v)); return this;}; this.prototype.getPrefixedTableName = function(tableName) {return `${Caf.toString(this.tableNamePrefix)}${Caf.toString(tableName)}`;}; this.prototype.cachedGet = function(request, key) {return request.cachedGet(this.pipelineName, key != null ? key : request.key);}; this.classGetter({pipelineName: function() {let temp; return ((temp = this._pipelineName) != null ? temp : decapitalize(this.getName()));}, pluralPipelineName: function() {let parts; if (this._pluralPipelineName) {return this._pluralPipelineName;}; parts = getCodeWords(this.getPipelineName()); parts.push(pluralize(parts.pop())); return this._pluralPipelineName = lowerCamelCase(parts);}}); this.prototype.toString = function() {return this.pipelineName;}; this.prototype.getLogName = function(requestType) {return `${Caf.toString(requestType)}-handler`;}; this.getter("options", {pipelineName: function() {return this.class.getPipelineName();}, tableNamePrefix: function() {let temp; return ((temp = this.class._tableNamePrefix) != null ? temp : config.tableNamePrefix);}, tableName: function() {return this.getPrefixedTableName(this.name);}, normalizedFields: function() {let nf; nf = {}; Caf.each2(this.fields, (v, k) => nf[k] = normalizeFieldProps(v)); return nf;}, name: function() {let temp, temp1; return ((temp = this._name) != null ? temp : this._name = ((temp1 = this._options.name) != null ? temp1 : decapitalize(this.class.getName())));}, session: function() {let temp, temp1; return ((temp = this._session) != null ? temp : this._session = ((temp1 = this._options.session) != null ? temp1 : Session.singleton));}, handlerRequestTypesMap: function(_into = {}) {mergeInto(_into, this.handlers); return _into;}, filterRequestTypesMap: function(_into = {}) {Caf.each2(this.filters, (filter) => mergeInto(_into, filter.beforeFilters)); return _into;}, requestTypesMap: function(_into = {}) {return this.getHandlerRequestTypesMap(this.getFilterRequestTypesMap(_into));}, requestTypes: function() {return Object.keys(this.requestTypesMap);}, aliases: function() {return Object.keys(this.class.getAliases());}, inspectedObjects: function() {return inspectedObjectLiteral(this.name);}, isRemoteClient: function() {return !!this.remoteServer;}, apiRoot: function() {let temp; return ((temp = this.class._apiRoot) != null ? temp : config._apiRoot);}, remoteServer: function() {let temp; return ((temp = this.class._remoteServer) != null ? temp : config.remoteServer);}, location: function() {return (this.remoteServer && config.location !== "server") ? "client" : config.location;}, restPath: function() {let temp; return ((temp = this._restPath) != null ? temp : this._restPath = `/${Caf.toString(config.apiRoot)}/${Caf.toString(this.name)}`);}, restPathRegex: function() {let temp; return ((temp = this._restPathRegex) != null ? temp : this._restPathRegex = RegExp(`^${Caf.toString(escapeRegExp(this.restPath))}(?:-([a-z0-9_]+))?(?:\\/([^?]+))?(?=\\?|\$)`, 'i'));}, groupedFilters: function() {let temp; return ((temp = this._groupedFilters) != null ? temp : this._groupedFilters = Pipeline.groupFilters(this.filters));}, beforeFilters: function() {let temp; return ((temp = this._beforeFilters) != null ? temp : this._beforeFilters = this.groupedFilters.slice().reverse());}, afterFilters: function() {return this.groupedFilters;}, status: function() {return "OK";}, filterChain: function() {return this._filterChain || (this._filterChain = compactFlatten([this, this.groupedFilters]).reverse());}}); this.groupFilters = function(filters) {let priorityLevels, sortedFilters; priorityLevels = []; Caf.each2(filters, ({priority}) => pushIfNotPresent(priorityLevels, priority)); sortedFilters = []; Caf.each2(priorityLevels.sort((a, b) => a - b), (priorityLevels) => Caf.each2(filters, (filter) => sortedFilters.push(filter), (filter) => priorityLevels === filter.priority)); return sortedFilters;}; this.prototype.getBeforeFilters = function(request) {return Caf.array(this.beforeFilters, null, (filter) => filter.getBeforeFilter(request));}; this.prototype.getAfterFilters = function(request) {return Caf.array(this.afterFilters, null, (filter) => filter.getAfterFilter(request));}; this.prototype.createRequest = function(type, options) {let stack; if (!isPlainObject(options)) {log.warn("DEPRICATED - options must be an object now");}; if (isString(options)) {options = {key: options};}; if (getDetailedRequestTracingEnabled()) {stack = (new Error).stack;}; return Promise.then(() => options.session || this.session.loadedDataPromise).tapCatch((error) => log.error({Pipeline_createRequest: {message: "Error getting session", info: {pipelineName: this.pipelineName, type, options}, error}})).then((sessionData) => new Request(merge(options, {type, pipeline: this, session: sessionData, creationStack: stack}))).catch((error) => {if (stack != null) {error.stack = cleanStackTrace(stack);}; error.message += `\n\ninside ${Caf.toString(this.name)}.` + formattedInspect({createRequest: {type, options}}); return (() => {throw error;})();});}; this.prototype.subscribe = function(subscriber) {return pushIfNotPresent(this._subscribers, subscriber);}; this.prototype.unsubscribe = function(subscriber) {return removeFirstMatch(this._subscribers, subscriber);}; this.prototype.dataUpdated = function(key, data) {return this._sendDataSubscriptionEvent("update", key, data);}; this.prototype.dataDeleted = function(key, data) {return this._sendDataSubscriptionEvent("delete", key, data);}; this.prototype._sendDataSubscriptionEvent = function(eventType, key, data) {let dataArray; return isArray(dataArray = data) ? Caf.each2(this._subscribers, (subscriber) => Caf.each2(dataArray, (data) => subscriber(eventType, key, data))) : Caf.each2(this._subscribers, (subscriber) => subscriber(eventType, key, data));}; this.prototype.isUpdateRequestType = function(actionType) {return /^(create|update)/.test(actionType);}; this.prototype.isDeleteRequestType = function(actionType) {return /^delete/.test(actionType);}; this.prototype.getRequestProcessingReport = function(location = this.location) {return Caf.object(this.requestTypes, (requestType) => compactFlatten([Caf.array(this.getBeforeFilters({requestType, location}), (filter) => inspectedObjectLiteral(filter.getName())), inspectedObjectLiteral((location === "client") ? "[remote request]" : "[local handler]"), Caf.array(this.getAfterFilters({requestType, location}), (filter) => inspectedObjectLiteral(filter.getName()))]));}; this.getter({pipelineReport: function(processingLocation) {let out; out = {tableName: this.tableName, fields: Caf.object(this.fields, (fieldProps) => {let out2; return Caf.each2(Object.keys(fieldProps).sort(), (k) => {let v; v = fieldProps[k]; return !isFunction(v) ? out2[k] = v : undefined;}, null, out2 = {});})}; if (processingLocation) {out[`${Caf.toString(processingLocation)}Processing`] = this.getRequestProcessingReport("client");} else {out.clientSideRequestProcessing = this.getRequestProcessingReport("client"); out.serverSideRequestProcessing = this.getRequestProcessingReport("server"); out.serverlessDevelopmentRequestProcessing = this.getRequestProcessingReport("both");}; return out;}, apiReport: function(options = {}) {let server, publicOnly; ({server, publicOnly} = options); return Caf.object(this.requestTypes, (type) => {let method, url; ({method, url} = Request.getRestClientParamsForArtEryRequest({server: this.remoteServer || server, type, restPath: this.restPath})); return {[method.toLocaleUpperCase()]: url};}, (type) => !publicOnly || this.getPublicRequestTypes()[type]);}}); this.prototype.handleRequest = function(request) {let handler; if (request.isResponse) {throw new Error("HARD DEPRICATED");}; return (this.location === "client" && this.remoteServer) ? request.sendRemoteRequest(this.remoteServer) : (handler = this.handlers[request.type]) ? this.applyHandler(request, handler, "handler").then((response) => !response.isResponse ? request.failure(`${Caf.toString(this.pipelineName)}.${Caf.toString(request.type)} request was not handled`) : response) : request.failure(`${Caf.toString(this.pipelineName)}: No handler for request type: ${Caf.toString(formattedInspect(request.type))}`);}; this.getter({propsToKey: function() {let temp; return ((temp = this._propsToKey) != null ? temp : this._propsToKey = (() => {let recordType; recordType = this.pipelineName; return (props, stateField) => {let propsField, temp1, base; propsField = stateField != null ? stateField : recordType; return ((temp1 = Caf.exists(base = props[propsField]) && base.id) != null ? temp1 : props[propsField + "Id"]);};})());}}); this._defineQueryHandlers = function() {let handlers; handlers = this.getHandlers(); return Caf.each2(this.getQueries(), (pipelineQuery, k) => handlers = this.extendHandlers(k, pipelineQuery.options.query), (pipelineQuery, k) => !handlers[k]);}; this._normalizeQuery = function(queryName, options) {let dataToKeyString, toKeyString; if (isFunction(options)) {options = {query: options};}; if (!(isFunction(options.query) && options.query.length > 0)) {throw new Error(`query function must have at least one argument:\n\n${Caf.toString(formattedInspect({queryName, options}))}"`);}; ({dataToKeyString} = options); toKeyString = dataToKeyString ? (dataOrKey) => isPlainObject(dataOrKey) ? dataToKeyString(dataOrKey) : dataOrKey : (key) => (key != null) ? key.toString() : key; return {queryName, options, toKeyString};}; this.prototype._normalizeRequest = function(request) {return isPlainObject(request) ? new Request(merge(request, {pipeline: this})) : request;}; this.prototype._processRequest = function(request) {let haveHandler, isPublicRequestType; haveHandler = !!this.handlers[request.type]; isPublicRequestType = !!this.getPublicRequestTypes()[request.type]; return !(haveHandler || isPublicRequestType) ? Promise.then(() => request.clientFailure({data: {message: `'${Caf.toString(request.type)}' is an invalid request type`, validRequestTypes: Object.keys(this.handlers)}})) : request.requireServerOriginOr(isPublicRequestType, "to issue non-public requests").then(() => this.filterChain[0].handleRequest(request, this.filterChain, 0)).tap((response) => {let key, data; if (!response.isResponse) {log.error({"not response!": response});}; return response.isSuccessful ? (({key, data} = response), response.isUpdateRequest() ? this.dataUpdated(key != null ? key : this.toKeyString(data), data) : undefined, response.isDeleteRequest() ? this.dataDeleted(key != null ? key : this.toKeyString(data), data) : undefined) : undefined;});}; noOptions = {}; this.prototype._processClientRequest = function(type, a, b, c) {let parentRequest, options, requestStartTime; if (!(a != null)) {a = b; b = c;}; if (a != null && a instanceof RequestResponseBase) {parentRequest = a; a = b; b = c;}; options = isString(a) ? merge({key: a}, b) : a != null ? a : noOptions; return parentRequest ? parentRequest.subrequest(this, type, (options !== noOptions) ? options : {props: parentRequest.props}) : (requestStartTime = currentSecond(), this.createRequest(type, options).then((request) => this._processRequest(request)).then((response) => this._processResponseSession(response, requestStartTime)).then((response) => response.toPromise(options)));}; mostRecentSessionUpdatedAt = 0; this.prototype._processResponseSession = function(response, requestStartTime) {let responseSession, currentSession, message; if (responseSession = response.responseSession) {currentSession = this.session.data; message = (requestStartTime > mostRecentSessionUpdatedAt) ? (mostRecentSessionUpdatedAt = requestStartTime, this.session.data = responseSession, "updated") : "out-of-order update blocked";}; return response;}; this._defineClientRequestMethod = function(requestType) {let temp, base; if (!(Caf.in(requestType, this.getClientApiMethodList()))) {this.extendClientApiMethodList(requestType);}; return ((temp = (base = this.prototype)[requestType]) != null ? temp : base[requestType] = function(a, b, c) {return this._processClientRequest(requestType, a, b, c);});}; this._defineClientHandlerMethods = function() {Caf.each2(this.getHandlers(), (__, name) => this._defineClientRequestMethod(name)); return Caf.each2(this.getPublicRequestTypes(), (__, name) => this._defineClientRequestMethod(name));}; this._initFields = function() {return Caf.each2(this.getFilters(), (filter) => this.extendFields(filter.fields));};});});});
//# sourceMappingURL=Pipeline.js.map
