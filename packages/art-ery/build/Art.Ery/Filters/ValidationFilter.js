// Generated by CoffeeScript 1.12.7
(function() {
  var ErrorWithInfo, Filter, Promise, ValidationFilter, Validator, defineModule, log, merge, pluralize, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('art-standard-lib'), defineModule = ref.defineModule, pluralize = ref.pluralize, log = ref.log, merge = ref.merge, Promise = ref.Promise, ErrorWithInfo = ref.ErrorWithInfo;

  Validator = require('art-validation').Validator;

  Filter = require('../Filter');


  /*
  TODO!!!
   * BUG: ValidationFilter doesn't validated the TimestampFilter's fields! (when using createDatabaseFilters)
   * PROBLEM: ValidationFilter only validates the fields it is passed.
   * SOLUTION: we need it to always validate all fields declared for the pipeline.
   * createDatabaseFilters needs to change order: it needs to run ValidationFilter last.
  
  I almost want to rename this "FieldTypesFilter" - since it both validates and preprocesses.
  It should actually also have an @after pass that at least converts timestamps back into Dates.
   */

  defineModule(module, ValidationFilter = (function(superClass) {
    extend(ValidationFilter, superClass);

    ValidationFilter.location("both");

    function ValidationFilter(options) {
      ValidationFilter.__super__.constructor.apply(this, arguments);
      this._exclusive = options != null ? options.exclusive : void 0;
      this._validator = new Validator(this.fields);
    }

    ValidationFilter.before({
      create: function(request) {
        return this._validate("validateCreate", request);
      },
      update: function(request) {
        return this._validate("validateUpdate", request);
      }
    });

    ValidationFilter.prototype._validate = function(method, request) {
      return Promise.then((function(_this) {
        return function() {
          var context, data, fields, k, rejection, unexpectedFields, v, validatedData;
          context = request.requestString;
          validatedData = _this._validator[method](request.data, {
            context: context
          });
          data = request.location === "client" ? _this._validator.preprocess(request.data) : validatedData;
          rejection = (function() {
            if (this._exclusive) {
              fields = request.pipeline.fields;
              unexpectedFields = null;
              for (k in data) {
                v = data[k];
                if (!fields[k]) {
                  (unexpectedFields || (unexpectedFields = [])).push(k);
                }
              }
              if (unexpectedFields) {
                throw new ErrorWithInfo(context + " failed. " + (pluralize(unexpectedFields.length, "Unexpected field")) + ": " + (unexpectedFields.join(', ')), {
                  unexpected: unexpectedFields
                });
              }
            }
          }).call(_this);
          return rejection || request.withData(data);
        };
      })(this))["catch"](function(exception) {
        var info, message;
        message = exception.message, info = exception.info;
        return request.clientFailure({
          data: merge(info, {
            message: "ValidationFilter: " + message
          }),
          errorProps: {
            exception: exception
          }
        });
      });
    };

    return ValidationFilter;

  })(Filter));

}).call(this);

//# sourceMappingURL=ValidationFilter.js.map
