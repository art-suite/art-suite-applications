// Generated by CoffeeScript 1.12.7
(function() {
  var Filter, LinkFieldsFilter, Promise, array, defineModule, each, formattedInspect, isPlainArray, isPlainObject, isString, log, merge, missing, networkFailure, normalizeFieldProps, objectWithout, ref, ref1, shallowClone, timeout, wordsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('art-standard-lib'), objectWithout = ref.objectWithout, timeout = ref.timeout, array = ref.array, timeout = ref.timeout, isPlainObject = ref.isPlainObject, formattedInspect = ref.formattedInspect, each = ref.each, wordsArray = ref.wordsArray, log = ref.log, defineModule = ref.defineModule, merge = ref.merge, isString = ref.isString, shallowClone = ref.shallowClone, isPlainArray = ref.isPlainArray, Promise = ref.Promise;

  Filter = require('../Filter');

  normalizeFieldProps = require('art-validation').normalizeFieldProps;

  ref1 = require('art-communication-status'), missing = ref1.missing, networkFailure = ref1.networkFailure;

  defineModule(module, LinkFieldsFilter = (function(superClass) {
    var booleanProps;

    extend(LinkFieldsFilter, superClass);

    LinkFieldsFilter.location("server");


    /*
    IN:
      fields:
         * object mapping the linked fields (not the ID fields for those linked fileds)
         * EX:
        user:
             * any art-validation legal field description
             * Additional options:
            autoCreate:   true/false
              if set, when request-type == "create"
                if this field is set with an object without and id
                  then it will FIRST create the linked-to-object
                  then it will set the id-field with the linked-to-object
    
              if this field is set with an object WITH an id
                (I think this applies to both create and update request-types)
                will automatically set the id-field to the matching id
    
            pipelineName: string
              override the default pipelineName
              default: field-name (in this example: 'user')
    
            include: true/false
              if true, then when returning instances of this object, it will also
              fetch the linked field's object. In this case, it will set 'user' to
              the value returned from: pipelines.user.get userId
              (This is how it is actually fetched: request.cachedGet 'user', userId)
     */

    function LinkFieldsFilter(options) {
      var fieldName, fieldProps, fields, props, ref2;
      fields = {};
      this._linkFields = LinkFieldsFilter.normalizeLinkFields(options.fields);
      ref2 = this._linkFields;
      for (fieldName in ref2) {
        fieldProps = ref2[fieldName];
        props = merge(fieldProps, {
          fieldType: "trimmedString"
        });
        delete props.idFieldName;
        fields[fieldProps.idFieldName] = normalizeFieldProps(props);
      }
      LinkFieldsFilter.__super__.constructor.call(this, merge(options, {
        fields: fields
      }));
    }

    LinkFieldsFilter.getter("linkFields");

    LinkFieldsFilter.prototype.preprocessRequest = function(request) {
      var data, pipeline, postIncludeLinkedFieldData, processedData, ref2, session, type;
      type = request.type, pipeline = request.pipeline, data = (ref2 = request.data) != null ? ref2 : {}, session = request.session;

      /*
      Pass includedData from the requestProps to the ultimate responseProps.
      IncludedData is removed from 'data' so it isn't writen in this pipeline's record, but instead,
      if autoCreate/vivifiy is true, it is written to its own pipeline and linked in.
      
      postIncludeLinkedFieldData allows us to return the includedData in the response without
      re-reading the data back with additional requests.
       */
      postIncludeLinkedFieldData = null;
      processedData = merge(data);
      return Promise.all(array(this._linkFields, {
        when: function(arg, fieldName) {
          var idFieldName;
          idFieldName = arg.idFieldName;
          return !data[idFieldName] && data[fieldName];
        },
        "with": (function(_this) {
          return function(arg, fieldName, __, linkedFieldData) {
            var autoCreate, idFieldName, pipelineName;
            idFieldName = arg.idFieldName, autoCreate = arg.autoCreate, pipelineName = arg.pipelineName;
            return Promise.then(function() {
              if (linkedFieldData.id) {
                return linkedFieldData;
              } else if (autoCreate) {
                return request.subrequest(pipelineName, "create", {
                  props: {
                    include: false,
                    data: linkedFieldData
                  }
                });
              } else {
                throw new Error("New record-data provided for " + fieldName + ", but autoCreate is not enabled for this field. " + fieldName + ": " + (formattedInspect(linkedFieldData)));
              }
            }).then(function(linkedFieldData) {
              (postIncludeLinkedFieldData || (postIncludeLinkedFieldData = {}))[fieldName] = linkedFieldData;
              processedData[idFieldName] = linkedFieldData.id;
              return delete processedData[fieldName];
            });
          };
        })(this)
      })).then(function() {
        return request["with"]({
          data: processedData,
          props: merge(request.props, postIncludeLinkedFieldData && {
            postIncludeLinkedFieldData: postIncludeLinkedFieldData
          })
        });
      });
    };

    booleanProps = wordsArray("link required include autoCreate");

    LinkFieldsFilter.normalizeLinkFields = function(linkFields) {
      var lf;
      return each(linkFields, lf = {}, function(fieldProps, fieldName) {
        var autoCreate, include, link, props, ref2, required;
        ref2 = normalizeFieldProps(fieldProps), link = ref2.link, include = ref2.include, required = ref2.required, autoCreate = ref2.autoCreate;
        if (link) {
          lf[fieldName] = props = {
            pipelineName: isString(link) ? link : fieldName,
            idFieldName: fieldName + "Id"
          };
          if (autoCreate) {
            props.autoCreate = true;
          }
          if (include) {
            props.include = true;
          }
          if (required) {
            return props.required = true;
          }
        }
      });
    };

    LinkFieldsFilter.prototype.includeLinkedFields = function(response, data) {
      var fieldName, id, idFieldName, include, linkedData, pipelineName, postIncludeLinkedFieldData, promises, ref2, requestData, requestIncludeProp;
      requestData = response.requestData, (ref2 = response.requestProps, postIncludeLinkedFieldData = ref2.postIncludeLinkedFieldData);
      requestIncludeProp = response.rootRequest.props.include !== false && response.requestProps.include !== false;
      linkedData = shallowClone(data);
      promises = (function() {
        var ref3, ref4, results;
        ref3 = this._linkFields;
        results = [];
        for (fieldName in ref3) {
          ref4 = ref3[fieldName], idFieldName = ref4.idFieldName, pipelineName = ref4.pipelineName, include = ref4.include;
          if (include && (id = linkedData[idFieldName])) {
            results.push((function(_this) {
              return function(id, fieldName, idFieldName, pipelineName, include) {
                var attemptGetLinkedField;
                return Promise.then(attemptGetLinkedField = function() {
                  var linkData;
                  if (linkData = (requestData != null ? requestData[fieldName] : void 0) || (postIncludeLinkedFieldData != null ? postIncludeLinkedFieldData[fieldName] : void 0)) {
                    return merge({
                      id: id
                    }, linkData);
                  } else if (requestIncludeProp) {
                    return response.cachedGet(pipelineName, id);
                  }
                }).then(function(value) {
                  if (value != null) {
                    return linkedData[fieldName] = value;
                  }
                })["catch"](function(response) {
                  if (response.status !== missing) {
                    log.error("LinkFieldsFilter: error including " + fieldName + ". " + idFieldName + ": " + id + ". pipelineName: " + pipelineName + ". Error: " + response, response.error);
                  }
                  return null;
                });
              };
            })(this)(id, fieldName, idFieldName, pipelineName, include));
          }
        }
        return results;
      }).call(this);
      return Promise.all(promises).then(function() {
        return linkedData;
      });
    };

    LinkFieldsFilter.before({
      create: function(request) {
        return this.preprocessRequest(request).then((function(_this) {
          return function(request) {
            return _this._validate("validateCreate", request);
          };
        })(this));
      },
      update: function(request) {
        return this.preprocessRequest(request).then((function(_this) {
          return function(request) {
            return _this._validate("validateUpdate", request);
          };
        })(this));
      }
    });

    LinkFieldsFilter.after({
      all: function(response) {
        if (response.type === "delete") {
          return response;
        }
        return response.withTransformedRecords((function(_this) {
          return function(record) {
            return _this.includeLinkedFields(response, record);
          };
        })(this));
      }
    });

    return LinkFieldsFilter;

  })(require('./ValidationFilter')));

}).call(this);

//# sourceMappingURL=LinkFieldsFilter.js.map
