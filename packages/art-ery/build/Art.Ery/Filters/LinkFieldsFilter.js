"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["shallowClone", "Promise", "merge", "missing", "log", "normalizeFieldProps", "isString", "Error", "formattedInspect"], [global, require('../StandardImport')], (shallowClone, Promise, merge, missing, log, normalizeFieldProps, isString, Error, formattedInspect) => {let LinkFieldsFilter; return LinkFieldsFilter = Caf.defClass(class LinkFieldsFilter extends require('./ValidationFilter') {constructor(options) {let linkFields; super(merge(options, {fields: Caf.object(linkFields = LinkFieldsFilter.normalizeLinkFields(options.fields), (fieldProps, fieldName) => {let props; props = merge(fieldProps, {fieldType: "trimmedString"}); delete props.idFieldName; return normalizeFieldProps(props);}, null, null, (fieldProps, fieldName) => fieldProps.idFieldName)})); this._linkFields = linkFields;};}, function(LinkFieldsFilter, classSuper, instanceSuper) {let booleanProps; this.location("server"); this.getter("linkFields"); this.before({create: function(request) {return this.preprocessRequest(request).then((request) => this._validate("validateCreate", request));}, update: function(request) {return this.preprocessRequest(request).then((request) => this._validate("validateUpdate", request));}}); this.after({all: function(response) {if (response.type === "delete") {return response;}; return response.withTransformedRecords((record) => this.includeLinkedFields(response, record));}}); this.prototype.includeLinkedFields = function(response, data) {let requestData, postIncludeLinkedFieldData, requestIncludeProp, linkedData; requestData = response.requestData; postIncludeLinkedFieldData = response.requestProps.postIncludeLinkedFieldData; requestIncludeProp = response.rootRequest.props.include !== false && response.requestProps.include !== false; linkedData = shallowClone(data); return Promise.all(Caf.array(this._linkFields, ({idFieldName, pipelineName, include}, fieldName) => {let id, attemptGetLinkedField; id = linkedData[idFieldName]; return Promise.then(attemptGetLinkedField = () => {let linkData; return (linkData = Caf.exists(requestData) && requestData[fieldName] || Caf.exists(postIncludeLinkedFieldData) && postIncludeLinkedFieldData[fieldName]) ? merge({id}, linkData) : requestIncludeProp ? response.cachedGet(pipelineName, id) : undefined;}).then((value) => (value != null) ? linkedData[fieldName] = value : undefined).catch((response) => {if (!(response.status === missing)) {log.error(`LinkFieldsFilter: error including ${Caf.toString(fieldName)}. ${Caf.toString(idFieldName)}: ${Caf.toString(id)}. pipelineName: ${Caf.toString(pipelineName)}. Error: ${Caf.toString(response)}`, response.error);}; return null;});}, ({idFieldName, pipelineName, include}, fieldName) => include && linkedData[idFieldName])).then(() => linkedData);}; booleanProps = ["link", "required", "include", "autoCreate"]; this.normalizeLinkFields = function(linkFields) {let lf; return Caf.each2(linkFields, (fieldProps, fieldName) => {let link, include, required, autoCreate, props; ({link, include, required, autoCreate} = normalizeFieldProps(fieldProps)); return link ? (lf[fieldName] = props = {pipelineName: isString(link) ? link : fieldName, idFieldName: fieldName + "Id"}, autoCreate ? props.autoCreate = true : undefined, include ? props.include = true : undefined, required ? props.required = true : undefined) : undefined;}, null, lf = {});}; this.prototype.preprocessRequest = function(request) {let type, pipeline, data, session, postIncludeLinkedFieldData, processedData, temp; type = request.type; pipeline = request.pipeline; data = (undefined !== (temp = request.data)) ? temp : {}; session = request.session; postIncludeLinkedFieldData = null; processedData = merge(data); return Promise.all(Caf.array(this._linkFields, ({idFieldName, autoCreate, pipelineName}, fieldName) => Promise.then(() => {let linkedFieldData; linkedFieldData = data[fieldName]; return linkedFieldData.id ? linkedFieldData : autoCreate ? request.subrequest(pipelineName, "create", {props: {include: false, data: linkedFieldData}}) : (() => {throw new Error(`New record-data provided for ${Caf.toString(fieldName)}, but autoCreate is not enabled for this field. ${Caf.toString(fieldName)}: ${Caf.toString(formattedInspect(linkedFieldData))}`);})();}).then((linkedFieldData) => {(postIncludeLinkedFieldData || (postIncludeLinkedFieldData = {}))[fieldName] = linkedFieldData; processedData[idFieldName] = linkedFieldData.id; return delete processedData[fieldName];}), ({idFieldName, autoCreate, pipelineName}, fieldName) => !data[idFieldName] && data[fieldName])).then(() => request.with({data: processedData, props: merge(request.props, postIncludeLinkedFieldData && {postIncludeLinkedFieldData})}));};});});});
//# sourceMappingURL=LinkFieldsFilter.js.map
