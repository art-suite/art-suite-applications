"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["merge", "normalizeFieldProps", "log", "isString", "vivifyObjectPathAndSet", "Promise", "Error", "formattedInspect", "Array"], [global, require('../StandardImport')], (merge, normalizeFieldProps, log, isString, vivifyObjectPathAndSet, Promise, Error, formattedInspect, Array) => {let LinkFieldsFilter2; return LinkFieldsFilter2 = Caf.defClass(class LinkFieldsFilter2 extends require('./ValidationFilter') {constructor(options) {let _linkFields; super(merge(options, {fields: LinkFieldsFilter2._getIdFieldsFromLinkFields(_linkFields = LinkFieldsFilter2._normalizeLinkFields(options.fields))})); this._linkFields = _linkFields;};}, function(LinkFieldsFilter2, classSuper, instanceSuper) {let pipelinesLinkedFieldFilters, getLinkedFieldFilterForPipeline; this.location("server"); this.getter("linkFields"); this.before({create: function(request) {return this._preprocessRequest(request).then((request) => this._validate("validateCreate", request));}, update: function(request) {return this._preprocessRequest(request).then((request) => this._validate("validateUpdate", request));}}); this.after({all: function(response) {return (!response.isRootRequest || (response.requestProps.prefetch === false || response.requestProps.include === false || response.type === "delete")) ? response : this._prefetchRecords(response, response.pipeline, response.responseData).then((dataUpdates) => response.withMergedProps({dataUpdates}));}}); pipelinesLinkedFieldFilters = {}; this.getLinkedFieldFilterForPipeline = getLinkedFieldFilterForPipeline = function(pipeline) {let registryFieldFilters, temp, temp1; registryFieldFilters = ((temp = pipelinesLinkedFieldFilters[pipeline.registry.uniqueName]) != null ? temp : pipelinesLinkedFieldFilters[pipeline.registry.uniqueName] = {}); return ((temp1 = registryFieldFilters[pipeline.name]) != null ? temp1 : registryFieldFilters[pipeline.name] = Caf.find(pipeline.filters, null, (filter) => filter.linkFields) || false);}; this._getIdFieldsFromLinkFields = function(linkFields) {return Caf.object(linkFields, (fieldProps, fieldName) => {let props; props = merge(fieldProps, {fieldType: "trimmedString"}); delete props.idFieldName; return normalizeFieldProps(props);}, null, null, (fieldProps, fieldName) => fieldProps.idFieldName);}; this._normalizeLinkFields = function(linkFields) {let normalizedLinkFields; return Caf.each2(linkFields, (fieldProps, fieldName) => {let include, prefetch, required, autoCreate, link, props, temp; return (temp = normalizeFieldProps(fieldProps), include = temp.include, prefetch = temp.prefetch, required = temp.required, autoCreate = temp.autoCreate, link = temp.link) ? (include ? log.warn("DEPRICATED: 'include'. Use 'prefetch' instead.") : undefined, normalizedLinkFields[fieldName] = props = {pipelineName: isString(link) ? link : fieldName, idFieldName: fieldName + "Id"}, autoCreate ? props.autoCreate = true : undefined, (prefetch || include) ? props.prefetch = true : undefined, required ? props.required = true : undefined) : undefined;}, null, normalizedLinkFields = {});}; this.prototype._setPrefetch = function(request, pipelineName, key, value) {return vivifyObjectPathAndSet(request.context, "dataUpdates", pipelineName, key, value);}; this.prototype._preprocessRequest = function(request) {let processedData, pipelines, preprocessRequestFailure; processedData = merge(request.data); pipelines = request.pipelines; preprocessRequestFailure = null; return Promise.all(Caf.array(this.linkFields, ({idFieldName, autoCreate, pipelineName}, fieldName) => {let linkedFieldData; if (!isString(pipelineName)) {throw new Error("pipelineName is not a string!");}; return (linkedFieldData = processedData[fieldName]) ? Promise.then(() => linkedFieldData.id ? linkedFieldData : (!autoCreate ? preprocessRequestFailure = request.rejectWithClientFailure(`New record-data provided for ${Caf.toString(fieldName)}, but autoCreate is not enabled for this field. ${Caf.toString(fieldName)}: ${Caf.toString(formattedInspect(linkedFieldData))}`) : undefined, !pipelines[pipelineName] ? preprocessRequestFailure = request.rejectWithClientFailure(`Linked pipeline not found: ${Caf.toString(formattedInspect({pipelineName}))}`) : undefined, pipelines[pipelineName].create(request, {props: {include: false, data: linkedFieldData}}).tap((linkedFieldData) => this._setPrefetch(request, pipelineName, linkedFieldData.id, linkedFieldData)))).tap(({id}) => {processedData[idFieldName] = id; return delete processedData[fieldName];}) : undefined;})).then(() => preprocessRequestFailure != null ? preprocessRequestFailure : request.withData(processedData));}; this.prototype._prefetchRecord = function(request, pipelineName, key) {let base, base1; return Promise.resolve((key != null) ? Caf.exists(base = request.context.dataUpdates) && (Caf.exists(base1 = base[pipelineName]) && base1[key]) || request.cachedGetWithoutInclude(pipelineName, key).then((record) => this._setPrefetch(request, pipelineName, key, record)) : undefined);}; this.prototype._prefetchRecords = function(request, pipeline, data) {return Promise.then(() => {let linkFields; return (() => {switch (false) {case !(Caf.is(data, Array)): return Promise.all(Caf.array(data, (record) => this._prefetchRecords(request, pipeline, record))); case !(Caf.isF(pipeline.isRecord) && pipeline.isRecord(data) && (linkFields = getLinkedFieldFilterForPipeline(pipeline).linkFields)): return Promise.all(Caf.array(linkFields, ({include, prefetch, idFieldName, pipelineName: _pipelineName}, k) => this._prefetchRecord(request, _pipelineName, data[idFieldName]), ({include, prefetch, idFieldName, pipelineName: _pipelineName}, k) => include || prefetch));};})();}).then(() => request.context.dataUpdates);};});});});
//# sourceMappingURL=LinkFieldsFilter2.js.map
