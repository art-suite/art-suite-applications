"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Array", "vivifyObjectPathAndSet", "Neptune", "Function"], [global, require('./StandardImport')], (Array, vivifyObjectPathAndSet, Neptune, Function) => {let DataUpdatesFilter; return DataUpdatesFilter = Caf.defClass(class DataUpdatesFilter extends require('../Filter') {}, function(DataUpdatesFilter, classSuper, instanceSuper) {let updateRequestTypeRegExp, deleteRequestTypeRegExp, updateDataUpdatesContext; updateRequestTypeRegExp = /^(create|update)/; deleteRequestTypeRegExp = /^delete/; this.location("both"); this.group("outer"); updateDataUpdatesContext = function(response, context) {let key, type, responseData, pipelineName, groupName, base; key = response.key; type = response.type; responseData = response.responseData; pipelineName = response.pipelineName; context != null ? context : context = response.context; if (groupName = (() => {switch (false) {case !updateRequestTypeRegExp.test(type): return "dataUpdates"; case !deleteRequestTypeRegExp.test(type): return "dataDeletes";};})()) {switch (false) {case !(Caf.is(responseData, Array)): Caf.each2(responseData, (record) => {key = response.pipeline.toKeyString(record); return vivifyObjectPathAndSet(context, groupName, pipelineName, key, record);}); break; case !key: case !response.pipeline.isRecord(responseData): responseData != null ? responseData : responseData = Caf.isF((base = response.pipeline).toKeyObject) && base.toKeyObject(key || responseData) || {}; key != null ? key : key = response.pipeline.toKeyString(responseData); vivifyObjectPathAndSet(context, groupName, pipelineName, key, responseData);};}; return context;}; this.after({all: function(response) {let dataUpdates, dataDeletes; return response.isRootRequest ? (() => {switch (response.location) {case "client": return response.tap((response) => this.models ? this.applyFluxUpdates(response) : undefined); case "server": case "both": return response.withMergedPropsWithoutNulls(({dataUpdates, dataDeletes} = response.context, {dataUpdates, dataDeletes}));};})() : (updateDataUpdatesContext(response), response);}}); this.prototype.applyFluxUpdates = function(response) {let dataUpdates, dataDeletes, temp; temp = response.responseProps; dataUpdates = temp.dataUpdates; dataDeletes = temp.dataDeletes; this.applyModelDataUpdates(dataUpdates); this.applyModelDataDeletes(dataDeletes); if (updateRequestTypeRegExp.test(response.type)) {this.applyModelDataUpdates(updateDataUpdatesContext(response, {}).dataUpdates);}; return deleteRequestTypeRegExp.test(response.type) ? this.applyModelDataDeletes(updateDataUpdatesContext(response, {}).dataDeletes) : undefined;}; this.getter({models: function() {let base; return Caf.exists(base = Neptune.Art.Flux) && base.models;}}); this.prototype.applyModelDataUpdates = function(dataUpdates) {return Caf.each2(dataUpdates, (dataUpdatesByKey, pipelineName) => Caf.each2(dataUpdatesByKey, (data, key) => this.models[pipelineName].dataUpdated(key, data)), (dataUpdatesByKey, pipelineName) => {let base; return Caf.is(Caf.exists(base = this.models[pipelineName]) && base.dataUpdated, Function);});}; this.prototype.applyModelDataDeletes = function(dataDeletes) {return Caf.each2(dataDeletes, (dataDeletesByKey, pipelineName) => Caf.each2(dataDeletesByKey, (data, key) => this.models[pipelineName].dataDeleted(key, data)), (dataDeletesByKey, pipelineName) => {let base; return Caf.is(Caf.exists(base = this.models[pipelineName]) && base.dataDeleted, Function);});};});});});
//# sourceMappingURL=DataUpdatesFilter.js.map
