"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["getLinkedFieldFilterForPipeline", "Array", "Object", "merge", "hasProperties", "objectKeyCount"], [global, require('../StandardImport'), require('./LinkFieldsFilter2')], (getLinkedFieldFilterForPipeline, Array, Object, merge, hasProperties, objectKeyCount) => {let LinkFieldsFilter2LegacyApiEncode; return LinkFieldsFilter2LegacyApiEncode = Caf.defClass(class LinkFieldsFilter2LegacyApiEncode extends require('../Filter') {}, function(LinkFieldsFilter2LegacyApiEncode, classSuper, instanceSuper) {let legacyEncodeA, legacyEncodeB, purgeDataUpdates; this.after({all: function(response) {let responseProps, dataUpdates, dataUpdatesToPurge; return ((responseProps = response.responseProps, dataUpdates = responseProps.dataUpdates) && !response.requestProps.acceptLinkFieldsFilter2Encoding) ? (dataUpdatesToPurge = {}, response.withMergedPropsWithoutNulls({data: legacyEncodeA(response.pipelineName, dataUpdates, response.data, dataUpdatesToPurge), dataUpdates: response.context.dataUpdates = purgeDataUpdates(dataUpdates, dataUpdatesToPurge)})) : response;}}); legacyEncodeA = function(pipelineName, dataUpdates, data, dataUpdatesToPurge) {let linkFields; return (linkFields = getLinkedFieldFilterForPipeline(pipelineName).linkFields) ? (() => {switch (false) {case !(Caf.is(data, Array)): return Caf.array(data, (record) => legacyEncodeB(linkFields, dataUpdates, record, dataUpdatesToPurge)); case !(Caf.is(data, Object)): return legacyEncodeB(linkFields, dataUpdates, data, dataUpdatesToPurge); default: return data;};})() : data;}; legacyEncodeB = function(linkFields, dataUpdates, record, dataUpdatesToPurge) {return Caf.object(linkFields, ({idFieldName, pipelineName}) => {let data, id, base, temp; if (data = Caf.exists(base = dataUpdates[pipelineName]) && base[id = record[idFieldName]]) {(((temp = dataUpdatesToPurge[pipelineName]) != null ? temp : dataUpdatesToPurge[pipelineName] = {}))[id] = true;}; return legacyEncodeA(pipelineName, dataUpdates, data, dataUpdatesToPurge);}, null, merge(record));}; purgeDataUpdates = function(dataUpdates, dataUpdatesToPurge) {let out; return hasProperties(dataUpdatesToPurge) ? (out = {}, Caf.each2(dataUpdates, (records, pipelineName) => {let purgeRecords; return !(purgeRecords = dataUpdatesToPurge[pipelineName]) ? out[pipelineName] = records : (objectKeyCount(records) !== objectKeyCount(purgeRecords)) ? out[pipelineName] = Caf.object(records, null, (record, key) => !purgeRecords[key]) : undefined;}), hasProperties(out) && out || null) : dataUpdates;};});});});
//# sourceMappingURL=LinkFieldsFilter2LegacyApiEncode.js.map
