"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Validator", "w", "Request", "failure", "serverFailure", "clientFailure", "peek", "compactFlatten", "log", "success", "missing", "merge", "isPlainObject", "objectKeyCount", "isPlainArray", "config", "Promise", "RequestError", "formattedInspect", "cleanStackTrace", "getDetailedRequestTracingExplanation", "getCleanStackTraceWarning", "Error", "neq"], [global, require('./StandardImport'), {Request: require('./Request')}], (Validator, w, Request, failure, serverFailure, clientFailure, peek, compactFlatten, log, success, missing, merge, isPlainObject, objectKeyCount, isPlainArray, config, Promise, RequestError, formattedInspect, cleanStackTrace, getDetailedRequestTracingExplanation, getCleanStackTraceWarning, Error, neq) => {let responseValidator, Response; responseValidator = new Validator({request: w("required", {instanceof: Request}), status: w("required communicationStatus"), session: "object", props: "object"}); return Response = Caf.defClass(class Response extends require('./RequestResponseBase') {constructor(options) {let temp, temp1; super(merge(options, {creationStack: options.request.creationStack})); responseValidator.validate(options, {context: "Art.Ery.Response options", logErrors: true}); this.request = options.request; this.status = options.status; this.session = options.session; this.remoteRequest = options.remoteRequest; this.remoteResponse = options.remoteResponse; this.props = ((temp = options.props) != null ? temp : {}); if (options.requestOptions) {throw new Error("options.requestOptions is DEPRICATED - use options.props");}; if (options.data != null) {this._props.data = options.data;}; ((temp1 = this._session) != null ? temp1 : this._session = neq(this.request.session, this.request.originalRequest.session) ? this.request.session : undefined); this._endTime = null; if (this.type === "create" || this.type === "get") {this.setGetCache();};};}, function(Response, classSuper, instanceSuper) {this.prototype.isResponse = true; this.property("request", "props", "session", "remoteResponse", "remoteRequest"); this.setter("status"); this.getter({status: function() {let temp; return ((temp = (this._status === failure) ? (() => {switch (this.location) {case "server": return serverFailure; case "client": return clientFailure;};})() : undefined) != null ? temp : this._status);}, failed: function() {return this._status === failure || this._status === serverFailure;}, data: function() {return this._props.data;}, session: function() {let temp; return ((temp = this._session) != null ? temp : this.request.session);}, responseData: function() {return this._props.data;}, responseProps: function() {return this._props;}, responseSession: function() {return this._session;}, beforeFilterLog: function() {return this.request.filterLog || [];}, handledBy: function() {return !this.failed && peek(this.request.filterLog);}, rawRequestLog: function() {return compactFlatten([this.beforeFilterLog, this.afterFilterLog]);}, requestLog: function() {let startTime, endTime, firstTime, lastTime, lastProps, out; ({startTime, endTime} = this); firstTime = lastTime = startTime; lastProps = null; out = Caf.array(this.rawRequestLog, ({name, time}) => {if (!(firstTime != null)) {firstTime = lastTime = time;}; Caf.exists(lastProps) && (lastProps.deltaMs = (time - lastTime) * 1000 | 0); lastProps = {name, timeMs: 0, wallMs: (time - firstTime) * 1000 | 0}; lastTime = time; return lastProps;}); log({startTime, lastTime, _endTime: this._endTime}); Caf.exists(lastProps) && (lastProps.deltaMs = (endTime - lastTime) * 1000 | 0); return out;}, afterFilterLog: function() {return this._filterLog || [];}, isSuccessful: function() {return this._status === success;}, isMissing: function() {return this._status === missing;}, notSuccessful: function() {return this._status !== success;}, description: function() {return `${Caf.toString(this.requestString)}: ${Caf.toString(this.status)}`;}, propsForClone: function() {return {request: this.request, status: this.status, props: this.props, session: this._session, filterLog: this._filterLog, remoteRequest: this.remoteRequest, remoteResponse: this.remoteResponse, errorProps: this.errorProps};}, propsForResponse: function() {return this.propsForClone;}, summary: function() {return {response: merge({status: this.status, props: this.props, errorProps: this.errorProps})};}, plainObjectsResponse: function(fields) {return Caf.object(fields || {status: this.status, props: this.props, beforeFilterLog: this.beforeFilterLog, afterFilterLog: this.afterFilterLog, session: this._session}, null, (v) => (() => {switch (false) {case !isPlainObject(v): return objectKeyCount(v) > 0; case !isPlainArray(v): return v.length > 0; default: return v !== undefined;};})());}, responseForRemoteRequest: function() {return this.getPlainObjectsResponse(!config.returnProcessingInfoToClient ? {status: this.status, props: this.props, session: this._session} : undefined);}}); this.prototype.withMergedSession = function(session) {return Promise.resolve(session).then((session) => new this.class(merge(this.propsForClone, {session: merge(this.session, session)})));}; this.prototype.toPromise = function(options) {let returnNullIfMissing, returnResponse, returnResponseObject, data, isSuccessful, isMissing, temp; if (Caf.exists(options)) {returnNullIfMissing = options.returnNullIfMissing; returnResponse = options.returnResponse; returnResponseObject = options.returnResponseObject;}; temp = this; data = temp.data; isSuccessful = temp.isSuccessful; isMissing = temp.isMissing; returnResponse || (returnResponse = returnResponseObject); if (isMissing && returnNullIfMissing) {data = null; isSuccessful = true;}; return isSuccessful ? Promise.resolve(returnResponse ? this : data) : Promise.reject(this._getRejectionError());}; this.prototype._getRejectionError = function() {let exception, temp, temp1, base, base1, base2, base3, base4, from, into, i1, temp2; return this._preparedRejectionError || (this._preparedRejectionError = new RequestError({message: compactFlatten([((temp = ((temp1 = Caf.exists(base = this.responseData) && base.message) != null ? temp1 : Caf.exists(base1 = this.responseProps) && base1.message)) != null ? temp : Caf.exists(base2 = this.errorProps) && (Caf.exists(base3 = base2.exception) && base3.message)), "", `request: ${Caf.toString(this.pipeline)}.${Caf.toString(this.type)}`, formattedInspect({status: this.status, session: this.session, props: this.requestProps})]).join("\n"), type: this.type, status: this.status, requestData: this.requestData, responseData: this.responseData, sourceLib: "ArtEry", response: this, stack: compactFlatten([(exception = Caf.exists(base4 = this.errorProps) && base4.exception) ? `Exception stack:\n${Caf.toString(cleanStackTrace(exception.stack, false, true))}\n` : undefined, (from = this.requestTrace, into = [], (from != null) ? (i1 = from.length - 1, (() => {while (i1 >= 0) {let time, request, context, name, stack, filterLog, i, requestDetails; ({time, request, context, name, stack, filterLog} = from[i1]); i = i1; into.push((requestDetails = (filterLog != null) ? Caf.array(filterLog, ({name}) => {name}, ({name}) => name !== "created").join(" -> ") : `${Caf.toString(context)} ${Caf.toString(name)}`, `${Caf.toString(request)}: ${Caf.toString(requestDetails)} (request-depth: ${Caf.toString(i + 1)}, start-time: ${Caf.toString(time * 1000 | 0)}ms) ${Caf.toString(stack ? `\n${Caf.toString(cleanStackTrace(stack, null, true))}\n` : "")}`)); temp2 = i1--;}; return temp2;})()) : undefined, into).join("\n"), getDetailedRequestTracingExplanation(), getCleanStackTraceWarning()]).join("\n")}));};});});});
//# sourceMappingURL=Response.js.map
