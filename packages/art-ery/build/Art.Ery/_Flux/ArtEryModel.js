"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["KeyFieldsMixin", "ArtModel", "models", "upperCamelCase", "pipelines", "PipelineRegistry", "pluralize", "merge", "prefetchedRecordsCache", "missing", "fastBind", "isFunction"], [global, require('./StandardImport'), require('../PrefetchedRecordsCache')], (KeyFieldsMixin, ArtModel, models, upperCamelCase, pipelines, PipelineRegistry, pluralize, merge, prefetchedRecordsCache, missing, fastBind, isFunction) => {let ArtEryModel; return ArtEryModel = Caf.defClass(class ArtEryModel extends KeyFieldsMixin(ArtModel) {constructor() {super(...arguments); this._updateSerializers = {}; this._pipeline = this.class._pipeline; this._defineQueryModels(); this._bindPipelineMethods(); this._pipeline.subscribe((type, key, data) => (() => {switch (type) {case "update": return this.dataUpdated(key, data); case "delete": return this.dataDeleted(key, data);};})());};}, function(ArtEryModel, classSuper, instanceSuper) {this.abstractClass(); this.createModel = function(pipeline) {let aliases, name, hotReloadKey, AnonymousArtEryModel; ({aliases} = pipeline); name = pipeline.getName(); if (models[name]) {return;}; hotReloadKey = `ArtEryModel:${Caf.toString(name)}`; return AnonymousArtEryModel = Caf.defClass(class AnonymousArtEryModel extends ArtEryModel {}, function(AnonymousArtEryModel, classSuper, instanceSuper) {let ucName; this._name = ucName = upperCamelCase(name); if (pipeline.keyFields) {this.keyFields(pipeline.keyFields);}; this.pipeline(pipeline); if (aliases) {this.aliases(aliases);}; this.getHotReloadKey = function() {return hotReloadKey;};});}; this.defineModelsForAllPipelines = () => {Caf.each2(pipelines, (pipeline, name) => this.createModel(pipeline), (pipeline, name) => name === pipeline.getName()); return models;}; this.bindWithArtEry = () => {PipelineRegistry.on({register: ({name, pipeline}) => this.createModel(pipeline)}); return this.defineModelsForAllPipelines();}; this.pipeline = function(_pipeline) {this._pipeline = _pipeline; return this._pipeline;}; this.getter({pipelineName: function() {return this._pipeline.getName();}}, "pipeline", {propsToKey: function() {return this._pipeline.propsToKey;}}); this.prototype._defineQueryModels = function() {return this._queryModels = Caf.array(this._pipeline.queries, (pipelineQuery) => this._createQueryModel(pipelineQuery));}; this.prototype._createQueryModel = function({options, queryName}) {let localMerge, localSort, dataToKeyString, keyFields, recordsModel, pipeline, ArtEryQueryModelChild; localMerge = options.localMerge; localSort = options.localSort; dataToKeyString = options.dataToKeyString; keyFields = options.keyFields; recordsModel = this; pipeline = this._pipeline; return (ArtEryQueryModelChild = Caf.defClass(class ArtEryQueryModelChild extends require('./ArtEryQueryModel') {}, function(ArtEryQueryModelChild, classSuper, instanceSuper) {this._name = upperCamelCase(/^by/.test(queryName) ? `${Caf.toString(pluralize(pipeline.name))} ${Caf.toString(queryName)}` : queryName); this.prototype._pipeline = pipeline; this.prototype._recordsModel = recordsModel; this.prototype._queryName = queryName; if (keyFields) {this.keyFields(keyFields);}; Caf.each2(merge({localMerge, localSort, dataToKeyString}), (v, k) => this.prototype[k] = v);})).singleton;}; this.prototype.loadData = function(key) {let temp; return ((temp = prefetchedRecordsCache.get(this.pipelineName, key)) != null ? temp : this._pipeline.get({key, returnNullIfMissing: true, props: {include: "auto"}}));}; this.prototype.dataUpdated = function(key, data) {let oldData, mergedData, base; oldData = Caf.exists(base = this.getModelRecord(key)) && base.data; mergedData = merge(oldData, data); this.updateModelRecord(key, (oldRecord) => merge(oldRecord, {data: merge(oldRecord.data, data)})); return Caf.each2(this._queryModels, (queryModel) => {let oldQueryKey, queryKey; oldQueryKey = oldData && queryModel.dataToKeyString(oldData); queryKey = queryModel.dataToKeyString(mergedData); if (oldQueryKey && oldQueryKey !== queryKey) {queryModel.dataDeleted(oldQueryKey, oldData);}; return queryKey ? queryModel.dataUpdated(queryKey, mergedData) : undefined;});}; this.prototype.dataDeleted = function(key, dataOrKey) {this.updateModelRecord(key, {status: missing}); return dataOrKey && Caf.each2(this._queryModels, (queryModel) => {let queryKey; queryKey = queryModel.toKeyString(dataOrKey); return queryKey && queryModel.dataDeleted(queryKey, dataOrKey);});}; this.prototype._bindPipelineMethods = function() {let abstractPrototype; abstractPrototype = this._pipeline.class.getAbstractPrototype(); return Caf.each2(this._pipeline, (v, k) => this[k] = fastBind(v, this._pipeline), (v, k) => !this[k] && !abstractPrototype[k] && isFunction(v));};});});});
//# sourceMappingURL=ArtEryModel.js.map
