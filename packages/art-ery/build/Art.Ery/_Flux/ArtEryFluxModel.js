// Generated by CoffeeScript 1.12.7
(function() {
  var ArtEryFluxModel, ArtEryQueryFluxModel, FluxModel, KeyFieldsMixin, PipelineRegistry, Promise, array, arrayWith, arrayWithElementReplaced, compactFlatten, createWithPostCreate, decapitalize, defineModule, each, eq, fastBind, formattedInspect, inspect, isFunction, isPlainObject, isString, log, lowerCamelCase, merge, missing, models, object, pending, pipelines, pluralize, prefetchedRecordsCache, ref, ref1, ref2, ref3, select, success, upperCamelCase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('art-standard-lib'), lowerCamelCase = ref.lowerCamelCase, pluralize = ref.pluralize, each = ref.each, log = ref.log, array = ref.array, select = ref.select, isString = ref.isString, isFunction = ref.isFunction, fastBind = ref.fastBind, decapitalize = ref.decapitalize, merge = ref.merge, Promise = ref.Promise, eq = ref.eq, upperCamelCase = ref.upperCamelCase, arrayWith = ref.arrayWith, arrayWithElementReplaced = ref.arrayWithElementReplaced, formattedInspect = ref.formattedInspect, defineModule = ref.defineModule, inspect = ref.inspect, compactFlatten = ref.compactFlatten, object = ref.object, isPlainObject = ref.isPlainObject;

  createWithPostCreate = require('art-class-system').createWithPostCreate;

  ref1 = require("art-communication-status"), missing = ref1.missing, success = ref1.success, pending = ref1.pending;

  ref2 = require('art-ery'), KeyFieldsMixin = ref2.KeyFieldsMixin, PipelineRegistry = ref2.PipelineRegistry, pipelines = ref2.pipelines;

  ref3 = require('@art-suite/art-flux'), FluxModel = ref3.FluxModel, models = ref3.models;

  prefetchedRecordsCache = require('../PrefetchedRecordsCache').prefetchedRecordsCache;

  ArtEryQueryFluxModel = require('./ArtEryQueryFluxModel');

  defineModule(module, ArtEryFluxModel = (function(superClass) {
    extend(ArtEryFluxModel, superClass);

    ArtEryFluxModel.abstractClass();


    /*
    ALIASES
      both pipelines and models will have the same set of aliases
      This skips the aliases in pipelines and calls createModel only once
      which will in turn create all the model aliases.
      It's important that all the model aliases are the same model-instance object.
    
    OUT: singleton for new AnonymousArtErtFluxModel class
     */

    ArtEryFluxModel.createModel = function(pipeline) {
      var AnonymousArtErtFluxModel, aliases, hotReloadKey, name;
      aliases = pipeline.aliases;
      name = pipeline.getName();
      if (models[name]) {
        return;
      }
      hotReloadKey = "ArtEryFluxModel:" + name;
      return createWithPostCreate(AnonymousArtErtFluxModel = (function(superClass1) {
        var ucName;

        extend(AnonymousArtErtFluxModel, superClass1);

        function AnonymousArtErtFluxModel() {
          return AnonymousArtErtFluxModel.__super__.constructor.apply(this, arguments);
        }

        AnonymousArtErtFluxModel._name = ucName = upperCamelCase(name);

        if (pipeline.keyFields) {
          AnonymousArtErtFluxModel.keyFields(pipeline.keyFields);
        }

        AnonymousArtErtFluxModel.pipeline(pipeline);

        if (aliases) {
          AnonymousArtErtFluxModel.aliases(aliases);
        }

        AnonymousArtErtFluxModel.getHotReloadKey = function() {
          return hotReloadKey;
        };

        return AnonymousArtErtFluxModel;

      })(this.applyMixins(pipeline, ArtEryFluxModel)));
    };

    ArtEryFluxModel.applyMixins = function(pipeline, BaseClass) {
      var customMixin, i, len, ref4;
      ref4 = compactFlatten(pipeline.getFluxModelMixins());
      for (i = 0, len = ref4.length; i < len; i++) {
        customMixin = ref4[i];
        BaseClass = customMixin(BaseClass);
      }
      return BaseClass;
    };

    ArtEryFluxModel.defineModelsForAllPipelines = function() {
      var name, pipeline;
      for (name in pipelines) {
        pipeline = pipelines[name];
        if (name === pipeline.getName()) {
          ArtEryFluxModel.createModel(pipeline);
        }
      }
      return models;
    };

    ArtEryFluxModel.bindWithArtEry = function() {
      PipelineRegistry.on({
        register: function(arg) {
          var name, pipeline;
          name = arg.name, pipeline = arg.pipeline;
          return ArtEryFluxModel.createModel(pipeline);
        }
      });
      return ArtEryFluxModel.defineModelsForAllPipelines();
    };

    ArtEryFluxModel.pipeline = function(_pipeline) {
      this._pipeline = _pipeline;
      return this._pipeline;
    };

    ArtEryFluxModel.getter({
      pipelineName: function() {
        return this._pipeline.getName();
      }
    }, "pipeline", {
      propsToKey: function() {
        return this._pipeline.propsToKey;
      }
    });

    function ArtEryFluxModel() {
      ArtEryFluxModel.__super__.constructor.apply(this, arguments);
      this._updateSerializers = {};
      this._pipeline = this["class"]._pipeline;
      this._defineQueryModels();
      this._bindPipelineMethods();
      this._pipeline.subscribe((function(_this) {
        return function(type, key, data) {
          switch (type) {
            case "update":
              return _this.dataUpdated(key, data);
            case "delete":
              return _this.dataDeleted(key, data);
          }
        };
      })(this));
    }

    ArtEryFluxModel.prototype._defineQueryModels = function() {
      return this._queryModels = array(this._pipeline.queries, (function(_this) {
        return function(pipelineQuery) {
          return _this._createQueryModel(pipelineQuery);
        };
      })(this));
    };


    /* _createQueryModel
      IN: {options, queryName}
      queryName can either be
        pre2020-style:
          format: pluralized pipeline name - by - fields
          e.g. postsByUserId
    
        2020-style-naming:
          format: by - fields
          e.g. byUserId
    
        Either way, the flux-model will be named:
          format: pluralized pipeline name - by - fields
          e.g. postsByUserId
    
      Benefits of 2020-style query names:
        By dropping the pipeline-name as part of the queryName, we get several advantages:
    
          DRY:
            Pipeline definitions:
              2020 version:
                class Message extends Pipeline
                  @query byUserId: (request) -> ...
                  @publicRequestTypes :byUserId
    
              instead of pre2020:
                class Message extends Pipeline
                  @query messagesByUserId: (request) -> ...
                  @publicRequestTypes :messagesByUserId
    
            The REST api becomes:
              2020 version:       /post/byUserId/abc123
              instead of pre2020: /post/postsByUserId/abc123
    
          And all the DRY means an objective improvement:
    
            It is now possible to re-use pipeline query definitions across pipelines:
    
              class UserOwned extends Pipeline
                @query byUserId: (request) -> ...
                @publicRequestTypes :byUserId
    
              class Message extends UserOwned
              class Post extends UserOwned
    
            NOTE: I actually haven't tested that the inheritance part works yet...
     */

    ArtEryFluxModel.prototype._createQueryModel = function(arg) {
      var ArtEryQueryFluxModelChild, dataToKeyString, keyFields, localMerge, localSort, options, pipeline, queryName, recordsModel;
      options = arg.options, queryName = arg.queryName;
      localMerge = options.localMerge, localSort = options.localSort, dataToKeyString = options.dataToKeyString, keyFields = options.keyFields;
      recordsModel = this;
      pipeline = this._pipeline;
      return (createWithPostCreate(ArtEryQueryFluxModelChild = (function(superClass1) {
        var k, ref4, v;

        extend(ArtEryQueryFluxModelChild, superClass1);

        function ArtEryQueryFluxModelChild() {
          return ArtEryQueryFluxModelChild.__super__.constructor.apply(this, arguments);
        }

        ArtEryQueryFluxModelChild._name = upperCamelCase(/^by/.test(queryName) ? (pluralize(pipeline.name)) + " " + queryName : queryName);

        ArtEryQueryFluxModelChild.prototype._pipeline = pipeline;

        ArtEryQueryFluxModelChild.prototype._recordsModel = recordsModel;

        ArtEryQueryFluxModelChild.prototype._queryName = queryName;

        if (keyFields) {
          ArtEryQueryFluxModelChild.keyFields(keyFields);
        }

        ref4 = merge({
          localMerge: localMerge,
          localSort: localSort,
          dataToKeyString: dataToKeyString
        });
        for (k in ref4) {
          v = ref4[k];
          ArtEryQueryFluxModelChild.prototype[k] = v;
        }

        return ArtEryQueryFluxModelChild;

      })(this["class"].applyMixins(this._pipeline, ArtEryQueryFluxModel)))).singleton;
    };

    ArtEryFluxModel.prototype.loadData = function(key) {
      var ref4;
      return (ref4 = prefetchedRecordsCache.get(this.pipelineName, key)) != null ? ref4 : this._pipeline.get({
        key: key,
        returnNullIfMissing: true,
        props: {
          include: "auto"
        }
      });
    };


    /*
    TODO: What if the field that changes effects @dataToKeyString???
      Basically, then TWO query results for one query-model need updated - the old version gets a "delete"
      The new version gets the normal update.
    
      We -could- do a fluxStore.get and see if we have a local copy of the single record before we
      replace it. However, we often won't. However again, we may not NEED this often.
    
      Basically, the question becomes how do we get the old data - if we need it and it actually matters.
    
      The ArtEry Pipeline knows its queries - and in theory could know the fields which effect queries.
      DataUpdatesFilter could detect all this before: update. If it detects it, it could GET the old
      record, and then set responseProps.oldData: oldData. Then, DataUpdatesFilter could pass
      oldData into dataUpdated. DONE.
    
      OK - I added the oldData input, and I attempt to get it from the fluxStore if it isn't set.
      I think the code is right for handling the case where we need to update to queries.
    
      TODO: We need to do the Server-Side "fetch the old data if queries-keys will change" outline above.
      TODO: DataUpdatesFilter needs change the protocol to return oldData, too, if needed - there may be more than one oldData per request.
      TODO: DataUpdatesFilter needs to pass in: response.props.oldData[key]
     */

    ArtEryFluxModel.prototype.dataUpdated = function(key, data) {
      var mergedData, oldData, ref4;
      oldData = (ref4 = this.getModelRecord(key)) != null ? ref4.data : void 0;
      mergedData = merge(oldData, data);
      this.updateModelRecord(key, function(oldFluxRecord) {
        return merge(oldFluxRecord, {
          data: merge(oldFluxRecord.data, data)
        });
      });
      return each(this._queryModels, (function(_this) {
        return function(queryModel) {
          var oldQueryKey, queryKey;
          oldQueryKey = oldData && queryModel.dataToKeyString(oldData);
          queryKey = queryModel.dataToKeyString(mergedData);
          if (oldQueryKey && oldQueryKey !== queryKey) {
            queryModel.dataDeleted(oldQueryKey, oldData);
          }
          if (queryKey) {
            return queryModel.dataUpdated(queryKey, mergedData);
          }
        };
      })(this));
    };

    ArtEryFluxModel.prototype.dataDeleted = function(key, dataOrKey) {
      this.updateModelRecord(key, {
        status: missing
      });
      return dataOrKey && each(this._queryModels, (function(_this) {
        return function(queryModel) {
          var queryKey;
          queryKey = queryModel.toKeyString(dataOrKey);
          return queryKey && queryModel.dataDeleted(queryKey, dataOrKey);
        };
      })(this));
    };


    /*
    Bind all concrete methods defined on @_pipeline
    and set them on the model prototype
    as long as there isn't already a model-prototype method with that name.
    
    Specifically: create & update are already defined above
      since they need to do extra work to ensure the FluxStore is
      updated properly.
     */

    ArtEryFluxModel.prototype._bindPipelineMethods = function() {
      var abstractPrototype, k, ref4, results, v;
      abstractPrototype = this._pipeline["class"].getAbstractPrototype();
      ref4 = this._pipeline;
      results = [];
      for (k in ref4) {
        v = ref4[k];
        if (!this[k] && !abstractPrototype[k] && isFunction(v)) {
          results.push(this[k] = fastBind(v, this._pipeline));
        }
      }
      return results;
    };

    return ArtEryFluxModel;

  })(KeyFieldsMixin(FluxModel)));

}).call(this);

//# sourceMappingURL=ArtEryFluxModel.js.map
