// Generated by CoffeeScript 1.12.7
(function() {
  var ArtEryQueryFluxModel, ArtModel, KeyFieldsMixinCoffee, Promise, arrayWith, arrayWithElementReplaced, arrayWithout, decapitalize, defineModule, eq, formattedInspect, isArray, isFunction, isString, log, merge, missing, pending, propsEq, ref, ref1, select, success, upperCamelCase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('art-standard-lib'), log = ref.log, select = ref.select, isString = ref.isString, isArray = ref.isArray, isFunction = ref.isFunction, decapitalize = ref.decapitalize, merge = ref.merge, Promise = ref.Promise, eq = ref.eq, upperCamelCase = ref.upperCamelCase, arrayWith = ref.arrayWith, arrayWithElementReplaced = ref.arrayWithElementReplaced, formattedInspect = ref.formattedInspect, propsEq = ref.propsEq, arrayWithout = ref.arrayWithout, defineModule = ref.defineModule;

  ref1 = require("art-communication-status"), missing = ref1.missing, success = ref1.success, pending = ref1.pending;

  KeyFieldsMixinCoffee = require("art-ery").KeyFieldsMixinCoffee;

  ArtModel = require('@art-suite/art-models').ArtModel;

  defineModule(module, ArtEryQueryFluxModel = (function(superClass) {
    extend(ArtEryQueryFluxModel, superClass);

    function ArtEryQueryFluxModel() {
      return ArtEryQueryFluxModel.__super__.constructor.apply(this, arguments);
    }

    ArtEryQueryFluxModel.abstractClass();

    ArtEryQueryFluxModel.prototype.loadData = function(key) {
      return Promise.resolve(this.query(key, this.pipeline)).then((function(_this) {
        return function(data) {
          return _this.localSort(data);
        };
      })(this));
    };

    ArtEryQueryFluxModel.getter("recordsModel pipeline queryName");


    /*
      IN: will be the key (returned from fromArtModelKey)
      OUT: array of singleModel records
        OR promise.then (arrayOfRecords) ->
      TODO:
        In the future we may wish to return other things beyond the array of records.
        Example:
          DynamoDb returns data for "getting the next page of records" in addition to the records.
          DynamoDb also returns other interesting stats about the query.
    
        If an array is returned, it will always be records. However, if an object is
        returned, then one of the fields will be records - and will go through the return
        pipeline, but the rest will be left untouched and placed in the ModelRecord's data field.
        Or should they be put in an auxiliary field???
     */

    ArtEryQueryFluxModel.prototype.query = function(key) {
      return this._pipeline[this._queryName]({
        key: key,
        props: {
          include: "auto"
        }
      });
    };


    /*
      override for to sort records when updating local query data in response to local record changes
     */

    ArtEryQueryFluxModel.prototype.localSort = function(queryData) {
      return queryData;
    };


    /*
      override for custom merge
      This implementation is a streight-up merge using @recordsModel.dataHasEqualKeys
    
      IN:
        previousQueryData: array of records or null
        updatedRecordData: single record or null
      OUT: return null if nothing changed, else return a new array
     */

    ArtEryQueryFluxModel.prototype.localMerge = function(previousQueryData, updatedRecordData, wasDeleted) {
      var currentRecordData, i, j, len, updatedRecordDataKey;
      if (previousQueryData == null) {
        previousQueryData = [];
      }
      if (!(updatedRecordData || wasDeleted)) {
        return previousQueryData;
      }
      if (!((previousQueryData == null) || isArray(previousQueryData))) {
        return previousQueryData;
      }
      if (!((previousQueryData != null ? previousQueryData.length : void 0) > 0)) {
        if (wasDeleted) {
          return [];
        } else {
          return [updatedRecordData];
        }
      }
      updatedRecordDataKey = this.recordsModel.toKeyString(updatedRecordData);
      for (i = j = 0, len = previousQueryData.length; j < len; i = ++j) {
        currentRecordData = previousQueryData[i];
        if (updatedRecordDataKey === this.recordsModel.toKeyString(currentRecordData)) {
          if (wasDeleted) {
            return arrayWithout(previousQueryData, i);
          } else if (propsEq(currentRecordData, updatedRecordData)) {
            log("saved 1 ArtModelStore update due to no-change check! (model: " + this.name + ", record-key: " + updatedRecordDataKey + ")");
            return null;
          } else {
            return arrayWithElementReplaced(previousQueryData, updatedRecordData, i);
          }
        }
      }
      if (wasDeleted) {
        return previousQueryData;
      } else {
        return arrayWith(previousQueryData, updatedRecordData);
      }
    };


    /*
      ArtEryArtModel calls dataUpdated and dataDeleted from its
      dataUpdated and dataDeleted functions, respectively.
     */

    ArtEryQueryFluxModel.prototype.dataUpdated = function(queryKey, singleRecordData) {
      return this._updateArtModelStoreIfExists(queryKey, singleRecordData);
    };

    ArtEryQueryFluxModel.prototype.dataDeleted = function(queryKey, singleRecordData) {
      return this._updateArtModelStoreIfExists(queryKey, singleRecordData, true);
    };

    ArtEryQueryFluxModel.prototype._updateArtModelStoreIfExists = function(queryKey, singleRecordData, wasDeleted) {
      if (this.getModelRecord(queryKey)) {
        return this.updateModelRecord(queryKey, (function(_this) {
          return function(oldArtModelRecord) {
            var merged;
            if (merged = _this.localMerge(oldArtModelRecord.data, singleRecordData, wasDeleted)) {
              return merge(oldArtModelRecord, {
                data: _this.localSort(merged)
              });
            } else {
              return oldArtModelRecord;
            }
          };
        })(this));
      }
    };

    return ArtEryQueryFluxModel;

  })(KeyFieldsMixinCoffee(ArtModel)));

}).call(this);

//# sourceMappingURL=ArtEryQueryFluxModel.js.map
