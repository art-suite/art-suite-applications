// Generated by CoffeeScript 1.12.7
(function() {
  var BaseObject, CommunicationStatus, Filter, Promise, Request, Response, Validator, config, defineModule, getInspectedObjects, isFailure, isPlainObject, log, merge, mergeInto, normalizeFields, ref, shallowClone, success, toInspectedObjects, toPlainObjects,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./StandardImport'), toPlainObjects = ref.toPlainObjects, Validator = ref.Validator, toInspectedObjects = ref.toInspectedObjects, getInspectedObjects = ref.getInspectedObjects, defineModule = ref.defineModule, BaseObject = ref.BaseObject, Promise = ref.Promise, log = ref.log, isPlainObject = ref.isPlainObject, mergeInto = ref.mergeInto, merge = ref.merge, shallowClone = ref.shallowClone, CommunicationStatus = ref.CommunicationStatus, success = ref.success, isFailure = ref.isFailure;

  normalizeFields = Validator.normalizeFields;

  Request = require('./Request');

  Response = require('./Response');

  config = require('./Config').config;


  /*
  TODO
  
  Filters should be able to detect if they are being run server-side or client-side.
    This is a simple global value, since the entire code-base is either running in Node or in the Browser.
    It doesn't change at runtime - duh!
    So, I think we should have a value like: Art.Ery.location, which is set at init-time
    to the code-base's running location.
  
    WHY do we need this? Filters may want to run on both AND run a little differently on both.
  
      LinkFieldsFilter, for example, would translate a linked field {foo: id: 123} to {fooId: 123} and not need
      to transmit the whole foo-record over the wire. BUT, if the data was {foo: username: "hi"}, that indicates
      a new foo-record should be created, and that should be done server-side.
  
      IT's a little thing right now, so I'm not implementing it... yet
  
    WHY PART 2
  
      This may be the solution to Filters which are not symmetrical. It's possible the before-part should be
      client-side-only, but the after-part should be server-side-only (for example).
  
      We could add @beforeLocation and @afterLocation props, but maybe this one solution is "good enough" for everything.
      The only down-side is it isn't as clear in the ArtEry-Pipeline report, but that may be OK since it doesn't seem like
      it'll be used that much.
  
  Art.Ery.location values:
    "server"
    "client"
    "both" - this is the "serverless" mode, it's all run client-side, but it includes both client-side and server-side filters.
  
  SBD:
    location: 'client' filters WILL run server-side for server-initiated requests.
    Maybe 'client' should be 'requester' instead of 'client'? 'requester' and 'server'?
   */

  defineModule(module, Filter = (function(superClass) {
    var locationNames, locationPriorityBoost;

    extend(Filter, superClass);

    Filter.extendableProperty({

      /*
      @after: foo: (request) ->
        IN: Request instance
        OUT: return a Promise returning one of the list below OR just return one of the list below:
          Request instance
          Response instance
          anythingElse -> toResponse anythingElse
      
        To reject a request:
        - throw an error
        - return a rejected promise
        - or create a Response object with the appropriate fields
       */
      before: {},

      /*
      @before: foo: (response) ->
        IN: Request instance
        OUT: return a Promise returning one of the list below OR just return one of the list below:
          Request instance
          Response instance
          anythingElse -> toResponse anythingElse
      
        To reject a request:
        - throw an error
        - return a rejected promise
        - or create a Response object with the appropriate fields
       */
      after: {}
    });


    /*
    fields
     */

    Filter.extendableProperty({
      fields: {}
    }, {
      extend: function(oldFields, addFields) {
        return merge(oldFields, normalizeFields(addFields));
      }
    });

    Filter.extendableProperty({
      filterFailures: false

      /*
      location: determine if the filter will run on the 'server', 'client' or 'both'.
       */
    });

    Filter.locationNames = locationNames = {
      server: true,
      client: true,
      both: true
    };

    Filter.extendableProperty({
      location: "server"
    }, {
      extend: function(__, v) {
        if (!locationNames[v]) {
          throw new Error("invalid location: " + v);
        }
        return v;
      }

      /*
      Filter Groups: default: "middle"
      
      Filter sequence, based on groups:
        loggers beforeFilter
          outer beforeFilter
            middle beforeFilter
              inner beforeFilter
                handler
              inner afterFilter
            middle afterFilter
          outer afterFilter
        loggers afterFilter
       */
    });

    Filter.groupNames = {
      loggers: 3,
      authorization: 2,
      outer: 1,
      outter: 1,
      middle: 0,
      inner: -1
    };

    Filter.extendableProperty({
      group: Filter.groupNames.middle
    }, {
      extend: function(__, v) {
        var value;
        if (v != null) {
          if ((value = Filter.groupNames[v]) == null) {
            throw new Error("invalid Filter group: " + v);
          }
          return value;
        } else {
          return 0;
        }
      }

      /*
        2018-04-19 SBD: I still think 'both' should be 1000, but it breaks Zo.
      
        Why? Because the ValidationFilter sets default fields and the UserOwnedFilter
        throws errors if the user attempts to set fields they aren't allowed to manually
        set. Well, this means the UserOwnedFilter needs to fire BEFORE ValidationFilter.
      
        The real problem here is ValidationFilter actually acts differently client-side vs
        server-side. I'm beginning to think the "both" mode for a Filter actually doesn't
        make much sense. I think we DO want to have a client-side validator which is
        initialized with the exact same constraint as the server-side validator. However,
        I'm beginning to think it just makes more sense if they are actually different filters.
      
        Right now I'm overloading what "Validation" means - and overloading usually (always?)
        creates unecessary complexity.
      
        And guess what? Validation, and only as a pre-filter, is STILL the only example I've
        found where a "both" filter kind-of makes sense.
      
        If we split Validator into separate Client and Server, we can drop the whole "both"
        concept - which probably simplifies A LOT of code! ooo!
       */
    });

    locationPriorityBoost = {
      client: 2000,
      both: 0,
      server: 0
    };

    Filter.getter({
      priority: function() {
        return this.group + locationPriorityBoost[this.location];
      }
    });

    function Filter(options) {
      var ref1;
      if (options == null) {
        options = {};
      }
      Filter.__super__.constructor.apply(this, arguments);
      this.serverSideOnly = options.serverSideOnly, this.clientSideOnly = options.clientSideOnly, this.name = (ref1 = options.name) != null ? ref1 : this["class"].getName(), this.location = options.location, this.fields = options.fields, this.group = options.group, this.filterFailures = options.filterFailures, this.after = options.after, this.before = options.before;
    }

    Filter.property("name");

    return Filter;

  })(require('./RequestHandler')));

}).call(this);

//# sourceMappingURL=FilterCoffee.js.map
