// Generated by CoffeeScript 1.12.7
(function() {
  var BaseObject, EventedMixin, JsonStore, Promise, Session, Validator, config, eq, formattedInspect, inspect, interval, isBrowser, isObject, isPlainObject, isString, jsonStore, log, merge, plainObjectsDeepEq, ref, toMilliseconds,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventedMixin = require('art-events').EventedMixin;

  config = require('./Config').config;

  ref = require('art-standard-lib'), isPlainObject = ref.isPlainObject, Promise = ref.Promise, BaseObject = ref.BaseObject, merge = ref.merge, inspect = ref.inspect, isString = ref.isString, isObject = ref.isObject, log = ref.log, plainObjectsDeepEq = ref.plainObjectsDeepEq, isBrowser = ref.isBrowser, interval = ref.interval, eq = ref.eq, formattedInspect = ref.formattedInspect, toMilliseconds = ref.toMilliseconds;

  Validator = require('art-validation').Validator;

  JsonStore = require('@art-suite/local-storage').JsonStore;

  jsonStore = JsonStore.jsonStore;


  /*
  TODO:
    rename to SessionManager
    Art.Ery.session should be the raw session data
    Art.Ery.sessionManager should be this singleton
    NOTE: don't break the jsonStore name, though - keep it 'session'
    NOTE: this will break things which expect Art.Ery.session.data to be the session data
  
    rename: "data" should become "session"
  
    Pipeline.session
      should be split into: session (raw data) and sessionManager
      However, maybe we should ONLY have the 'session' getter,
      which returns raw-data.
      If you need custom sessions on a per-pipline basis, use
      inheritance... I like! it's simpler!
   */

  module.exports = Session = (function(superClass) {

    /*
    A global singleton Session is provided and used by default.
    Or multiple instances can be created and passed to the
    constructor of each Pipeline for per-pipeline custom sessions.
     */
    extend(Session, superClass);

    Session.singletonClass();

    function Session(_data, _jsonStoreKey) {
      this._data = _data != null ? _data : {};
      this._jsonStoreKey = _jsonStoreKey;
      if (isBrowser) {
        this._startPollingSession();
      }
    }

    Session.prototype._startPollingSession = function() {
      return interval(5000, (function(_this) {
        return function() {
          return _this.reloadSession();
        };
      })(this));
    };

    Session.prototype.reloadSession = function() {
      this._sessionLoadPromise = null;
      return this.loadSession();
    };

    Session.prototype.loadSession = function() {
      return this._sessionLoadPromise != null ? this._sessionLoadPromise : this._sessionLoadPromise = config.saveSessions ? Promise.then((function(_this) {
        return function() {
          return jsonStore.getItem(_this.jsonStoreKey);
        };
      })(this)).then((function(_this) {
        return function(data) {
          if (!eq(data, _this.data)) {
            return _this.data = data;
          }
        };
      })(this)) : Promise.then((function(_this) {
        return function() {
          return _this.data;
        };
      })(this));
    };

    Session.getter("sessionLoadPromise data updatedAt", {
      jsonStoreKey: function() {
        var ref1;
        return (ref1 = this._jsonStoreKey) != null ? ref1 : "Art.Ery.Session";
      },
      loadedDataPromise: function() {
        if (config.location === "server") {
          throw new Error("INTERNAL ERROR: Attempted to access the global session serverside. HINT: Use 'session: {}' for no-session requests.");
        }
        return this.loadSession().then((function(_this) {
          return function() {
            return _this.data;
          };
        })(this));
      },
      sessionSignature: function() {
        var ref1;
        return (ref1 = this._data) != null ? ref1.signature : void 0;
      },
      inspectedObjects: function() {
        return this._data;
      }
    });

    Session.setter({
      data: function(data) {
        this._updatedAt = toMilliseconds();
        if (isPlainObject(data) && !plainObjectsDeepEq(data, this._data)) {
          this.queueEvent("change", {
            data: data
          });
          if (config.saveSessions) {
            jsonStore.setItem(this.jsonStoreKey, data);
          }
          return this._data = data;
        }
      }
    });

    Session.prototype.reset = function() {
      return this.data = {};
    };

    if (isBrowser) {
      Session.singleton.loadSession();
    }

    return Session;

  })(EventedMixin(require('./ArtEryBaseObject')));

}).call(this);

//# sourceMappingURL=Session.js.map
