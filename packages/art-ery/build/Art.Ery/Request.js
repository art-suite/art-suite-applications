"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Validator", "Error", "log", "currentSecond"], [global, require('./StandardImport')], (Validator, Error, log, currentSecond) => {let ArtEry, _validator, requestConstructorValidator, Request; ArtEry = require("./namespace"); _validator = null; requestConstructorValidator = function() {return _validator != null ? _validator : _validator = new Validator({pipeline: {required: {instanceof: ArtEry.Pipeline}}, type: {required: {fieldType: "string"}}, session: {required: {fieldType: "object"}}, parentRequest: {instanceof: ArtEry.Request}, originatedOnServer: "boolean", props: "object", key: "string"});}; return Request = Caf.defClass(class Request extends require('./RequestResponseBase') {constructor(options = {}) {let key, temp, temp1, temp2, temp3, temp4; super(...arguments); ((temp = this._filterLog) != null ? temp : this._filterLog = [{name: "created", stack: this._creationStack, time: currentSecond()}]); this.type = options.type; this.pipeline = options.pipeline; this.session = options.session; this.originatedOnServer = options.originatedOnServer; ((temp1 = this._originalRequest) != null ? temp1 : this._originalRequest = ((temp2 = options.originalRequest) != null ? temp2 : this)); this.parentRequest = options.parentRequest; this.props = ((temp3 = options.props) != null ? temp3 : {}); this.remoteRequest = options.remoteRequest; this._verbose = options.verbose; this._context = options.context; this._startTime = null; key = ((temp4 = options.key) != null ? temp4 : this._props.key); if (key != null) {options.key = this._props.key = this.pipeline.toKeyString(key);}; if (options.data != null) {this._props.data = options.data;}; requestConstructorValidator().validate(options, {context: "create Art.Ery.Request options", logErrors: true}); if (options.requestOptions) {throw new Error("options.requestOptions is DEPRICATED - use options.props");};};}, function(Request, classSuper, instanceSuper) {this.property("originalRequest", "type", "pipeline", "session", "originatedOnServer", "parentRequest", "props", "data", "key", "context", "remoteRequest"); this.getter({context: function() {let temp; return ((temp = this._context) != null ? temp : this._context = {});}, key: function() {return this._props.key;}, data: function() {return this._props.data;}, requestData: function() {return this._props.data;}, requestProps: function() {return this._props;}, requestOptions: function() {return (() => {throw new Error("DEPRICATED: use props");})();}, description: function() {return `${Caf.toString(this.requestString)} request`;}, summary: function() {return {request: {props: this.props}};}}); this.getter({request: function() {return this;}, shortInspect: function() {return `${Caf.toString(this.parentRequest ? this.parentRequest.shortInspect + " > " : "")}${Caf.toString(this.pipeline.getName())}-${Caf.toString(this.type)}(${Caf.toString(this.key || "")})`;}, beforeFilterLog: function() {return this.filterLog || [];}, afterFilterLog: function() {return [];}, isRootRequest: function() {return !this.parentRequest;}, requestPipelineAndType: function() {return log.warn(`DEPRICATED - use pipelineAndType"; "${Caf.toString(this.pipeline.name)}-${Caf.toString(this.type)}`);}, propsForClone: function() {return {originalRequest: this.originalRequest, pipeline: this.pipeline, type: this.type, props: this.props, session: this.session, parentRequest: this.parentRequest, filterLog: this.filterLog, originatedOnServer: this.originatedOnServer, context: this._context, verbose: this.verbose, remoteRequest: this.remoteRequest};}}); this.prototype.handled = function(_handledBy) {return this.success().then((response) => response.handled(_handledBy));}; this.prototype.toPromise = function() {return (() => {throw new Error("ArtEry.Request: toPromise can only be called on Response objects.");})();};});});});
//# sourceMappingURL=Request.js.map
