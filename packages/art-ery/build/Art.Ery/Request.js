"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseObject", "Validator", "arrayWith", "isString", "currentSecond", "Error", "peek", "compactFlatten", "dashCase", "merge", "objectWithout", "objectKeyCount", "toInspectedObjects", "failure", "serverFailure", "clientFailure", "success", "missing", "formattedInspect", "isPlainObject", "isPlainArray", "config", "Promise", "log", "networkFailure", "timeout", "Math", "present", "getDetailedRequestTracingEnabled", "isFunction", "mergeWithoutNulls", "isArray", "isClientFailure", "isJsonType", "clientFailureNotAuthorized", "RequestError", "cleanStackTrace", "getDetailedRequestTracingExplanation", "getCleanStackTraceWarning", "neq"], [global, require('./StandardImport'), require('./Config')], (BaseObject, Validator, arrayWith, isString, currentSecond, Error, peek, compactFlatten, dashCase, merge, objectWithout, objectKeyCount, toInspectedObjects, failure, serverFailure, clientFailure, success, missing, formattedInspect, isPlainObject, isPlainArray, config, Promise, log, networkFailure, timeout, Math, present, getDetailedRequestTracingEnabled, isFunction, mergeWithoutNulls, isArray, isClientFailure, isJsonType, clientFailureNotAuthorized, RequestError, cleanStackTrace, getDetailedRequestTracingExplanation, getCleanStackTraceWarning, neq) => {let ArtEry, responseValidator, requestValidator, createValidators, Request; ArtEry = require("./namespace"); responseValidator = requestValidator = null; createValidators = function() {responseValidator != null ? responseValidator : responseValidator = new Validator({request: ["required", {instanceof: Request}], status: ["required", "communicationStatus"], session: "object", props: "object"}); return requestValidator != null ? requestValidator : requestValidator = new Validator({pipeline: {required: {instanceof: ArtEry.Pipeline}}, type: {required: {fieldType: "string"}}, session: {required: {fieldType: "object"}}, parentRequest: {instanceof: Request}, originatedOnServer: "boolean", props: "object", key: "string"});}; return Request = Caf.defClass(class Request extends BaseObject {constructor(options) {let key, temp, temp1, temp2, base, temp3, temp4, temp5, base1, temp6, base2, temp7, temp8, base3, temp9, temp10, temp11, temp12; super(...arguments); this._type = options.type; this._props = ((temp = options.props) != null ? temp : {}); if (options.data != null) {this._props.data = options.data;}; this._pipeline = ((temp1 = options.pipeline) != null ? temp1 : options.request.pipeline); this._session = options.session; this._originatedOnServer = options.originatedOnServer; this._creationTime = currentSecond(); this._filterLog = options.filterLog; this._errorProps = options.errorProps; this._creationStack = ((temp2 = options.creationStack) != null ? temp2 : Caf.exists(base = options.request) && base.creationStack); this._request = options.request; ((temp3 = this._originalRequest) != null ? temp3 : this._originalRequest = ((temp4 = ((temp5 = options.originalRequest) != null ? temp5 : Caf.exists(base1 = this._request) && base1.originalRequest)) != null ? temp4 : this)); this._parentRequest = ((temp6 = options.parentRequest) != null ? temp6 : Caf.exists(base2 = this._request) && base2.parentRequest); this._rootRequest = ((temp7 = ((temp8 = Caf.exists(base3 = this._parentRequest) && base3.rootRequest) != null ? temp8 : this._request)) != null ? temp7 : this); this._status = options.status; this._verbose = options.verbose; this._context = options.context; this._remoteRequest = options.remoteRequest; this._remoteResponse = options.remoteResponse; createValidators(); if (this.isRequest) {key = ((temp9 = options.key) != null ? temp9 : this._props.key); if (key != null) {options.key = this._props.key = this.pipeline.toKeyString(key);}; requestValidator.validate(options, {context: `Art.Ery.${Caf.toString(this.class.name)} options`, logErrors: true}); ((temp10 = this._filterLog) != null ? temp10 : this._filterLog = [{name: "created", stack: this._creationStack, time: currentSecond()}]);} else {responseValidator.validate(options, {context: `Art.Ery.${Caf.toString(this.class.name)} options`, logErrors: true}); ((temp11 = this._session) != null ? temp11 : this._session = neq(this.request.session, this.request.originalRequest.session) ? this.request.session : undefined); if (this.type === "create" || this.type === "get") {this.setGetCache();};}; if (getDetailedRequestTracingEnabled()) {((temp12 = this._creationStack) != null ? temp12 : this._creationStack = (new Error).stack);};};}, function(Request, classSuper, instanceSuper) {let cachedGet, createRequirementNotMetRequestProps, resolveRequireTestValue, defaultWhenTest; this.getter({pipelines: function() {return this.pipeline.pipelines;}}); this.getter("filterLog", "errorProps", "creationTime", "creationStack"); this.getter("type", "pipeline", "session", "props"); this.getter("originatedOnServer"); this.getter("request", "originalRequest", "parentRequest", "rootRequest"); this.getter("remoteResponse", "remoteRequest"); this.prototype.addFilterLog = function(filter, context) {let base, base1; this._filterLog = arrayWith(this._filterLog, {name: isString(filter) ? filter : filter.getLogName(this.type), context, time: currentSecond(), stack: Caf.exists(base = this.originalRequest) && base.creationStack, exception: Caf.exists(base1 = this.errorProps) && base1.exception}); return this;}; this.prototype.isUpdateRequest = function() {return this.pipeline.isUpdateRequestType(this.type);}; this.prototype.isDeleteRequest = function() {return this.pipeline.isDeleteRequestType(this.type);}; this.getter({request: function() {if (!this._request) {throw new Error(".request accessor is only valid on isResponse instances");}; return this._request;}, isRequest: function() {return !(this._request != null);}, isResponse: function() {return this._request != null;}, isRootRequest: function() {return !this.parentRequest;}, isSubrequest: function() {return !this.isRootRequest;}, propsForClone: function() {return this.isRequest ? {originalRequest: this.originalRequest, pipeline: this.pipeline, type: this.type, props: this.props, session: this.session, parentRequest: this.parentRequest, filterLog: this.filterLog, originatedOnServer: this.originatedOnServer, context: this._context, verbose: this.verbose, remoteRequest: this.remoteRequest} : {request: this.request, status: this.status, props: this.props, session: this._session, filterLog: this._filterLog, remoteRequest: this.remoteRequest, remoteResponse: this.remoteResponse, errorProps: this.errorProps};}, propsForResponse: function() {return this.isResponse ? this.propsForClone : undefined;}, lastFilterLogEntry: function() {let temp, base; return ((temp = peek(this.filterLog)) != null ? temp : Caf.exists(base = this.request) && base.lastFilterLogEntry);}, requestTrace: function() {let name, context, time, stack, exception, temp, base; if (Caf.exists(temp = this.lastFilterLogEntry)) {name = temp.name; context = temp.context; time = temp.time; stack = temp.stack; exception = temp.exception;}; return compactFlatten([Caf.exists(base = this.parentRequest) && base.requestTrace, {time: time - this.startTime, request: this.requestString, context: dashCase(context), filterLog: compactFlatten([this.beforeFilterLog, this.afterFilterLog]), name, stack, exception}]);}, verbose: function() {let base, base1; return this._verbose || Caf.exists(base = this.originalRequest) && base._verbose || Caf.exists(base1 = this.rootRequest) && base1._verbose;}, location: function() {return this.pipeline.location;}, requestType: function() {return this.type;}, pipelineName: function() {return this.pipeline.getName();}, requestDataWithKey: function() {return merge(this.requestData, this.keyObject);}, keyObject: function() {return this.pipeline.toKeyObject(this.key);}, originalRequest: function() {let temp; return ((temp = this._originalRequest) != null ? temp : this.request.originalRequest);}, startTime: function() {return this.rootRequest.creationTime;}, endTime: function() {return this.creationTime;}, wallTime: function() {return this.startTime - this.endTime;}, beforeFilterLog: function() {let temp, temp1; return this.isRequest ? ((temp = this._filterLog) != null ? temp : []) : ((temp1 = this.request.filterLog) != null ? temp1 : []);}, afterFilterLog: function() {let temp; return this.isRequest ? [] : ((temp = this._filterLog) != null ? temp : []);}, requestChain: function() {let base; return compactFlatten([this.isResponse ? this.request.requestChain : Caf.exists(base = this.parentRequest) && base.requestChain, this]);}, simpleInspectedObjects: function() {let props, raw; props = objectWithout(this.props, "key", "data"); if (!(0 < objectKeyCount(props))) {props = null;}; raw = {[`${Caf.toString(this.class.name)}`]: this.requestString, originatedOnServer: this.originatedOnServer, data: this.data, status: this.status, props, errorProps: this.errorProps}; return toInspectedObjects(Caf.object(raw, null, (v) => v != null));}, inspectedObjects: function() {return {[`Art.Ery.${Caf.toString(this.class.name)}`]: Caf.array(this.requestChain, (request) => request.simpleInspectedObjects)};}, status: function() {let temp; return ((temp = (this._status === failure) ? (() => {switch (this.location) {case "server": return serverFailure; case "client": return clientFailure;};})() : undefined) != null ? temp : this._status);}, session: function() {let temp; return ((temp = this._session) != null ? temp : this.request.session);}, handledBy: function() {return this.isResponse && !this.failed && peek(this.request.filterLog);}, failed: function() {return this._status === failure || this._status === serverFailure;}, isSuccessful: function() {return this._status === success;}, isMissing: function() {return this._status === missing;}, isFailure: function() {return this.notSuccessful;}, notSuccessful: function() {return this._status != null && this._status !== success;}, type: function() {let temp; return ((temp = this._type) != null ? temp : this.request.type);}, key: function() {let temp, base; return this.isRequest ? this._props.key : ((temp = this.request.key) != null ? temp : Caf.exists(base = this.responseData) && base.id);}, data: function() {return this._props.data;}, requestSession: function() {let temp; return (((temp = this._request) != null ? temp : this)).session;}, requestProps: function() {let temp; return (((temp = this._request) != null ? temp : this)).props;}, requestData: function() {let temp; return (((temp = this._request) != null ? temp : this)).props.data;}, responseSession: function() {return this.isResponse ? this._session : undefined;}, responseProps: function() {return this.isResponse ? this._props : undefined;}, responseData: function() {return this.isResponse ? this._props.data : undefined;}, originatedOnServer: function() {return this.isRequest ? this._originatedOnServer : this.request.originatedOnServer;}, context: function() {let temp; return this.isRequest ? ((temp = this._context) != null ? temp : this._context = {}) : this.request.context;}, pipelineAndType: function() {return `${Caf.toString(this.pipelineName)}.${Caf.toString(this.type)}`;}, requestString: function() {return this.key ? this.pipelineAndType + ` ${Caf.toString(formattedInspect(this.key))}` : this.pipelineAndType;}, description: function() {return this.requestString;}, requestPathArray: function(_into) {let localInto, base; localInto = _into != null ? _into : []; Caf.exists(base = this.parentRequest) && base.getRequestPathArray(localInto); localInto.push(this); return localInto;}, requestPath: function() {return Caf.array(this.requestPathArray, (r) => r.requestString).join(" >> ");}, description: function() {return this.isRequest ? `${Caf.toString(this.requestString)} request` : `${Caf.toString(this.requestString)}: ${Caf.toString(this.status)}`;}, summary: function() {return this.isRequest ? {request: {props: this.props}} : {response: merge({status: this.status, props: this.props, errorProps: this.errorProps})};}, plainObjectsResponse: function(fields) {return Caf.object(fields || {status: this.status, props: this.props, beforeFilterLog: this.beforeFilterLog, afterFilterLog: this.afterFilterLog, session: this._session}, null, (v) => (() => {switch (false) {case !isPlainObject(v): return objectKeyCount(v) > 0; case !isPlainArray(v): return v.length > 0; default: return v !== undefined;};})());}, responseForRemoteRequest: function() {return this.getPlainObjectsResponse(!config.returnProcessingInfoToClient ? {status: this.status, props: this.props, session: this._session} : undefined);}}); this.prototype.toStringCore = function() {return `ArtEry.${Caf.toString(this.isResponse ? "Response" : "Request")} ${Caf.toString(this.pipelineName)}.${Caf.toString(this.type)}${Caf.toString(this.key ? ` key: ${Caf.toString(this.key)}` : "")}`;}; this.prototype.toString = function() {return `<${Caf.toString(this.toStringCore())}>`;}; this.getter({requestCache: function() {let temp, base; return ((temp = (base = this.context).requestCache) != null ? temp : base.requestCache = {});}, subrequestCount: function() {let temp, base; return ((temp = (base = this.context).subrequestCount) != null ? temp : base.subrequestCount = 0);}}); this.setter({responseProps: function() {return (() => {throw new Error("cannot set responseProps");})();}}); this.prototype.incrementSubrequestCount = function() {return this.context.subrequestCount = (this.context.subrequestCount | 0) + 1;}; this.prototype.createSubRequest = function(pipelineName, type, requestOptions) {let pipeline, temp, temp1; if (requestOptions && !isPlainObject(requestOptions)) {throw new Error("requestOptions must be an object");}; pipeline = this.pipelines[pipelineName]; if (!pipeline) {throw new Error(`Pipeline not registered: ${Caf.toString(formattedInspect(pipelineName))}`);}; return new Request(merge({originatedOnServer: ((temp = Caf.exists(requestOptions) && requestOptions.originatedOnServer) != null ? temp : true)}, requestOptions, {type, pipeline, verbose: this.verbose, session: Caf.exists(requestOptions) && requestOptions.session || this.session, parentRequest: ((temp1 = this._request) != null ? temp1 : this), context: this.context}));}; this.prototype.subrequest = function(pipelineOrPipelineName, type, requestOptionsOrKey, requestOptionsAfterKey) {let requestOptions, subrequest, pipelineName, temp; requestOptions = isString(requestOptionsOrKey) ? merge(requestOptionsAfterKey, {key: requestOptionsOrKey}) : requestOptionsOrKey; subrequest = this.createSubRequest(pipelineName = ((temp = pipelineOrPipelineName.pipelineName) != null ? temp : pipelineOrPipelineName), type, requestOptions); this.incrementSubrequestCount(); return subrequest.pipeline._processRequest(subrequest).then((response) => response.toPromise(requestOptions));}; this.prototype.nonblockingSubrequest = function(pipelineName, type, requestOptions) {this.subrequest(pipelineName, type, requestOptions).then((result) => config.verbose ? log({ArtEry: {Request: {nonblockingSubrequest: {status: "success", pipelineName, type, requestOptions, parentRequest: {pipelineName: this.pipelineName, type: this.type, key: this.key}, result}}}}) : undefined).catch((error) => log({ArtEry: {Request: {nonblockingSubrequest: {status: "failure", pipelineName, type, requestOptions, parentRequest: {pipelineName: this.pipelineName, type: this.type, key: this.key}, error}}}})); return Promise.resolve();}; this.prototype._getPipelineTypeCache = function(pipelineName, type) {let temp, base, temp1, base1; return ((temp = (base = ((temp1 = (base1 = this.requestCache)[pipelineName]) != null ? temp1 : base1[pipelineName] = {}))[type]) != null ? temp : base[type] = {});}; this.prototype.cachedSubrequest = function(pipelineName, requestType, keyOrRequestProps, d) {if (d !== undefined) {throw new Error("DEPRICATED: 4-param cachedSubrequest");}; return this._cachedSubrequest(pipelineName, requestType, requestType, keyOrRequestProps);}; this.prototype._cachedSubrequest = function(pipelineName, cacheType, requestType, keyOrRequestProps) {let key, temp, base; key = isString(keyOrRequestProps) ? keyOrRequestProps : keyOrRequestProps.key; if (!isString(key)) {throw new Error(`_cachedSubrequest: key must be a string (${Caf.toString(formattedInspect({key}))})`);}; return ((temp = (base = this._getPipelineTypeCache(pipelineName, cacheType))[key]) != null ? temp : base[key] = this.subrequest(pipelineName, requestType, keyOrRequestProps).catch((error) => (error.status === networkFailure && requestType === "get") ? timeout(20 + 10 * Math.random()).then(() => this.subrequest(pipelineName, requestType, keyOrRequestProps)) : (() => {throw error;})()));}; this.prototype.setGetCache = function() {return (this.status === success && present(this.key) && this.responseData != null) ? this._getPipelineTypeCache(this.pipelineName, "get")[this.key] = Promise.then(() => this.responseData) : undefined;}; this.prototype.cachedGet = cachedGet = function(pipelineName, key) {if (isPlainObject(key)) {key = this.pipelines[pipelineName].dataToKeyString(key);}; if (!isString(key)) {throw new Error(`cachedGet: key must be a string OR object when pipeline supports dataToKeyString (${Caf.toString(formattedInspect({key}))})`);}; return this.cachedSubrequest(pipelineName, "get", key);}; this.prototype.cachedGetWithoutInclude = function(pipelineName, key) {let temp; if (!isString(key)) {throw new Error(`cachedGetWithoutInclude: key must be a string (${Caf.toString(formattedInspect({key}))})`);}; return ((temp = this._getPipelineTypeCache(pipelineName, "get")[key]) != null ? temp : this._cachedSubrequest(pipelineName, "get-no-include", "get", {key, props: {include: false}}));}; this.prototype.cachedPipelineGet = cachedGet; this.prototype.cachedGetIfExists = function(pipelineName, key) {if (!(key != null)) {return Promise.resolve(null);}; return this.cachedGet(pipelineName, key).catch((error) => (error.status === missing) ? Promise.resolve(null) : (() => {throw error;})());}; createRequirementNotMetRequestProps = function(pipelineAndType, errors, stackException) {let data; return {data: data = {details: compactFlatten([pipelineAndType, "requirement not met", errors]).join(" - "), message: "Request requirement not met: " + compactFlatten([errors]).join(" - ")}, errorProps: getDetailedRequestTracingEnabled() ? {exception: stackException != null ? stackException : new Error(data.message)} : undefined};}; this.prototype.rejectIfErrors = function(errors, stackException) {return errors ? this.clientFailure(createRequirementNotMetRequestProps(this.pipelineAndType, errors, stackException)).then((response) => response.toPromise()) : Promise.resolve(this);}; this.prototype.rejectNotAuthorizedIfErrors = function(errors) {return errors ? this.clientFailureNotAuthorized(createRequirementNotMetRequestProps(this.pipelineAndType, errors)).then((response) => response.toPromise()) : Promise.resolve(this);}; this._resolveRequireTestValue = resolveRequireTestValue = function(testValue) {if (isFunction(testValue)) {testValue = testValue();}; return Promise.resolve(testValue);}; this.prototype.require = function(test, context) {let stackException; if (getDetailedRequestTracingEnabled()) {stackException = new Error(context);}; return resolveRequireTestValue(test).then((test) => this.rejectIfErrors(!test ? context != null ? context : [] : undefined, stackException));}; this.prototype.requiredFields = function(fields, context) {let missingFields; missingFields = null; Caf.each2(fields, (v, k) => (missingFields != null ? missingFields : missingFields = []).push(k), (v, k) => !(v != null)); return this.rejectIfErrors(missingFields ? ["missing fields: " + missingFields.join(", "), context] : undefined).then(() => fields);}; this.prototype.rejectIf = function(testValue, context) {return resolveRequireTestValue(testValue).then((testValue) => this.require(!testValue, context));}; this.prototype.requireServerOrigin = function(context) {return this.requireServerOriginOr(false, context);}; this.prototype.requireServerOriginOr = function(testValue, context) {if (this.originatedOnServer) {return Promise.resolve(this);}; return resolveRequireTestValue(testValue).then((testValue) => this.rejectNotAuthorizedIfErrors(!testValue ? "originatedOnServer required " + ((Caf.exists(context) && context.match(/\s*to\s/)) ? context : context ? `to ${Caf.toString(context)}` : "") : undefined));}; this.prototype.requireServerOriginIf = function(testValue, context) {if (this.originatedOnServer) {return Promise.resolve(this);}; return resolveRequireTestValue(testValue).then((testValue) => this.requireServerOriginOr(!testValue, context));}; this.prototype.with = function(constructorOptions) {return Promise.resolve(constructorOptions).then((constructorOptions) => this._with(constructorOptions));}; this.prototype._with = function(o) {return new this.class(merge(this.propsForClone, o));}; this.prototype.withData = function(data) {return Promise.resolve(data).then((data) => this._with({data}));}; this.prototype.withMergedData = function(data) {return Promise.resolve(data).then((data) => this._with({data: merge(this.data, data)}));}; this.prototype.withKey = function(data) {return Promise.resolve(data).then((key) => this._with({key}));}; this.prototype.withProps = function(props) {return Promise.resolve(props).then((props) => this._with({props, key: props.key, data: props.data}));}; this.prototype.withMergedProps = function(props) {return Promise.resolve(props).then((props) => this._with({key: props.key, data: props.data, props: merge(this.props, props)}));}; this.prototype.withMergedPropsWithoutNulls = function(props) {return Promise.resolve(props).then((props) => this._with({key: props.key, data: props.data, props: mergeWithoutNulls(this.props, props)}));}; this.prototype.withMergedErrorProps = function(errorProps) {return Promise.resolve(errorProps).then((errorProps) => this._with({errorProps: merge(this.errorProps, errorProps)}));}; this.prototype.withSession = function(session) {return Promise.resolve(session).then((session) => this._with({session}));}; this.prototype.withMergedSession = function(session) {return Promise.resolve(session).then((session) => this._with({session: merge(this.session, session)}));}; this.prototype.respondWithSession = function(session) {return this.success({session});}; this.prototype.respondWithMergedSession = function(session) {return this.success({session: merge(this.session, session)});}; defaultWhenTest = function(data, request) {return request.pipeline.isRecord(data);}; this.prototype.withTransformedRecords = function(withFunction, whenFunction = defaultWhenTest) {let options, firstFailure, transformedRecords, temp; if (isPlainObject(options = withFunction)) {withFunction = options.with; whenFunction = ((temp = options.when) != null ? temp : defaultWhenTest);}; return isPlainObject(this.data) ? Promise.resolve(whenFunction(this.data, this) ? this.next(withFunction(this.data, this)) : this) : isArray(this.data) ? (firstFailure = null, transformedRecords = Caf.array(this.data, (record) => Promise.then(() => whenFunction(record, this) ? withFunction(record, this) : record).catch((error) => {let response, base; return (() => {switch (false) {case !(error.status === "missing"): return null; case !(response = Caf.exists(error) && (Caf.exists(base = error.props) && base.response)): return response; default: return (() => {throw error;})();};})();}).then((out) => (Caf.exists(out) && out.status && out instanceof Request) ? isClientFailure(out.status) ? (Caf.isF(out._clearErrorStack) && out._clearErrorStack(), null) : firstFailure != null ? firstFailure : firstFailure = out : out)), Promise.all(transformedRecords).then((records) => firstFailure != null ? firstFailure : this.withData(compactFlatten(records)))) : Promise.resolve(this);}; this.prototype.next = function(data) {return Promise.resolve(data).then((data) => {if (data instanceof Request) {return data;}; return (() => {switch (false) {case !(!(data != null)): return this.missing(); case !isJsonType(data): return this.success({data}); default: log.error({invalidXYZ: data}); return (() => {throw new Error("invalid response data passed to RequestResponseBaseNext");})();};})();}, (error) => {let base, base1; return (Caf.exists(base = error.props) && (Caf.exists(base1 = base.response) && base1.isResponse)) ? error.props.response : this.failure({error});});}; this.prototype.success = function(responseProps) {return this.toResponse(success, responseProps);}; this.prototype.missing = function(responseProps) {return this.toResponse(missing, responseProps);}; this.prototype.clientFailure = function(responseProps) {return this.toResponse(clientFailure, responseProps);}; this.prototype.clientFailureNotAuthorized = function(responseProps) {return this.toResponse(clientFailureNotAuthorized, responseProps);}; this.prototype.failure = function(responseProps) {return this.toResponse(failure, responseProps);}; this.prototype.rejectWithMissing = function(responseProps) {return this.toResponse(missing, responseProps, true);}; this.prototype.rejectWithClientFailure = function(responseProps) {return this.toResponse(clientFailure, responseProps, true);}; this.prototype.rejectWithClientFailureNotAuthorized = function(responseProps) {return this.toResponse(clientFailureNotAuthorized, responseProps, true);}; this.prototype.rejectWithFailure = function(responseProps) {return this.toResponse(failure, responseProps, true);}; this.prototype.toResponse = function(status, responseProps, returnRejectedPromiseOnFailure = false) {if (!isString(status)) {throw new Error("missing status");}; return Promise.resolve(responseProps).then((responseProps = {}) => {let temp; return (() => {switch (false) {case !(responseProps instanceof Request): log.warn("DEPRICATED: toResponse is instanceof Request"); return responseProps; case !isPlainObject(responseProps): return new Request(merge(this.propsForResponse, responseProps, {status, request: ((temp = this._request) != null ? temp : this)})); case !isString(responseProps): return this.toResponse(status, {data: {message: responseProps}}); default: return this.toResponse(failure, this._toErrorResponseProps(responseProps));};})();}).then((response) => returnRejectedPromiseOnFailure ? response.toPromise() : response);}; this.prototype._toErrorResponseProps = function(responseProps) {return log(this, {responseProps}, {data: {message: (responseProps instanceof Error) ? `Internal Error: ArtEry.Request#toResponse received Error instance: ${Caf.toString(formattedInspect(responseProps))}` : "Internal Error: ArtEry.Request#toResponse received unsupported type"}});}; this.prototype.toPromise = function(options) {let returnNullIfMissing, returnResponse, returnResponseObject, data, isSuccessful, isMissing, temp; if (!this.isResponse) {throw new Error("ArtEry.Request: toPromise can only be called on Response objects.");}; if (Caf.exists(options)) {returnNullIfMissing = options.returnNullIfMissing; returnResponse = options.returnResponse; returnResponseObject = options.returnResponseObject;}; temp = this; data = temp.data; isSuccessful = temp.isSuccessful; isMissing = temp.isMissing; returnResponse != null ? returnResponse : returnResponse = returnResponseObject; if (isMissing && returnNullIfMissing) {data = null; isSuccessful = true;}; return isSuccessful ? Promise.resolve(returnResponse ? this : data) : Promise.reject(this._getRejectionError());}; this.prototype._getRejectionError = function() {let exception, temp, temp1, temp2, base, base1, base2, base3, base4, from, into, i1, temp3; return ((temp = this._preparedRejectionError) != null ? temp : this._preparedRejectionError = new RequestError({message: compactFlatten([((temp1 = ((temp2 = Caf.exists(base = this.responseData) && base.message) != null ? temp2 : Caf.exists(base1 = this.responseProps) && base1.message)) != null ? temp1 : Caf.exists(base2 = this.errorProps) && (Caf.exists(base3 = base2.exception) && base3.message)), "", `request: ${Caf.toString(this.pipeline)}.${Caf.toString(this.type)}`, formattedInspect({status: this.status, session: this.session, props: this.requestProps})]).join("\n"), type: this.type, status: this.status, requestData: this.requestData, responseData: this.responseData, sourceLib: "ArtEry", response: this, stack: compactFlatten([(exception = Caf.exists(base4 = this.errorProps) && base4.exception) ? `Exception stack:\n${Caf.toString(cleanStackTrace(exception.stack, false, true))}\n` : undefined, (from = this.requestTrace, into = [], (from != null) ? (i1 = from.length - 1, (() => {while (i1 >= 0) {let time, request, context, name, stack, filterLog, i; ({time, request, context, name, stack, filterLog} = from[i1]); i = i1; into.push(`${Caf.toString(request)}: ${Caf.toString((filterLog != null) ? Caf.array(filterLog, ({name}) => name, ({name}) => name !== "created").join(" -> ") : `${Caf.toString(context)} ${Caf.toString(name)}`)} (request-depth: ${Caf.toString(i + 1)}, start-time: ${Caf.toString(time * 1000 | 0)}ms) ${Caf.toString(stack ? `\n${Caf.toString(cleanStackTrace(stack, null, true))}\n` : "")}`); temp3 = i1--;}; return temp3;})()) : undefined, into).join("\n"), getDetailedRequestTracingExplanation(), getCleanStackTraceWarning()]).join("\n")}));};});});});
//# sourceMappingURL=Request.js.map
