"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Validator", "Error", "log", "present", "objectHasKeys", "restJsonRequest", "failure", "merge", "currentSecond"], [global, require('./StandardImport'), require('art-rest-client')], (Validator, Error, log, present, objectHasKeys, restJsonRequest, failure, merge, currentSecond) => {let ArtEry, _validator, requestConstructorValidator, Request; ArtEry = require("./namespace"); _validator = null; requestConstructorValidator = function() {return _validator || (_validator = new Validator({pipeline: {required: {instanceof: ArtEry.Pipeline}}, type: {required: {fieldType: "string"}}, session: {required: {fieldType: "object"}}, parentRequest: {instanceof: ArtEry.Request}, originatedOnServer: "boolean", props: "object", key: "string"}));}; return Request = Caf.defClass(class Request extends require('./RequestResponseBase') {constructor(options) {let key, temp, temp1, temp2; super(...arguments); if (!this._filterLog) {this._filterLog = [{name: "created", stack: this._creationStack, time: currentSecond()}];}; this.type = options.type; this.pipeline = options.pipeline; this.session = options.session; this.originalRequest = options.originalRequest; this.parentRequest = options.parentRequest; this.originatedOnServer = options.originatedOnServer; this.remoteRequest = options.remoteRequest; this.props = ((temp = options.props) != null ? temp : {}); this._verbose = options.verbose; this._context = options.context; this._startTime = null; key = ((temp1 = options.key) != null ? temp1 : this._props.key); if (key != null) {options.key = this._props.key = this.pipeline.toKeyString(key);}; if (options.data != null) {this._props.data = options.data;}; ((temp2 = this._originalRequest) != null ? temp2 : this._originalRequest = this); requestConstructorValidator().validate(options, {context: "create Art.Ery.Request options", logErrors: true}); if (options.requestOptions) {throw new Error("options.requestOptions is DEPRICATED - use options.props");};};}, function(Request, classSuper, instanceSuper) {let restMap, getRestClientParamsForArtEryRequest; this.property("originalRequest type pipeline session originatedOnServer parentRequest props data key context remoteRequest"); this.getter({context: function() {let temp; return ((temp = this._context) != null ? temp : this._context = {});}, key: function() {return this._props.key;}, data: function() {return this._props.data;}, requestData: function() {return this._props.data;}, requestProps: function() {return this._props;}, requestOptions: function() {return (() => {throw new Error("DEPRICATED: use props");})();}, description: function() {return `${Caf.toString(this.requestString)} request`;}, summary: function() {return {request: {props: this.props}};}}); this.getter({request: function() {return this;}, shortInspect: function() {return `${Caf.toString(this.parentRequest ? this.parentRequest.shortInspect + " > " : "")}${Caf.toString(this.pipeline.getName())}-${Caf.toString(this.type)}(${Caf.toString(this.key || "")})`;}, beforeFilterLog: function() {return this.filterLog || [];}, afterFilterLog: function() {return [];}, isRequest: function() {return true;}, isRootRequest: function() {return !this.parentRequest;}, requestPipelineAndType: function() {return log.warn(`DEPRICATED - use pipelineAndType"; "${Caf.toString(this.pipeline.name)}-${Caf.toString(this.type)}`);}, propsForClone: function() {return {originalRequest: this.originalRequest, pipeline: this.pipeline, type: this.type, props: this.props, session: this.session, parentRequest: this.parentRequest, filterLog: this.filterLog, originatedOnServer: this.originatedOnServer, verbose: this.verbose, remoteRequest: this.remoteRequest, context: this._context};}, urlKeyClause: function() {return present(this.key) ? `/${Caf.toString(this.key)}` : "";}}); this.prototype.handled = function(_handledBy) {return this.success().then((response) => response.handled(_handledBy));}; this.prototype.getRestRequestUrl = function(server) {return `${Caf.toString(server)}/${Caf.toString(this.pipeline.name)}${Caf.toString(this.urlKeyClause)}`;}; this.prototype.getNonRestRequestUrl = function(server) {return `${Caf.toString(server)}/${Caf.toString(this.pipeline.name)}-${Caf.toString(this.type)}${Caf.toString(this.urlKeyClause)}`;}; this.prototype.toPromise = function() {return (() => {throw new Error("ArtEry.Request: toPromise can only be called on Response objects.");})();}; restMap = {get: "get", create: "post", update: "put", delete: "delete"}; this.getRestClientParamsForArtEryRequest = getRestClientParamsForArtEryRequest = function({session, server, restPath, type, key, data}) {let urlKeyClause, hasSessionData, url, method; urlKeyClause = present(key) ? `/${Caf.toString(key)}` : ""; server || (server = ""); hasSessionData = objectHasKeys(session); url = ((method = restMap[type]) && (method !== "get" || !hasSessionData)) ? `${Caf.toString(server)}${Caf.toString(restPath)}${Caf.toString(urlKeyClause)}` : (method = "post", `${Caf.toString(server)}${Caf.toString(restPath)}-${Caf.toString(type)}${Caf.toString(urlKeyClause)}`); return {method, url, data};}; this.getter({remoteRequestProps: function() {let session, data, props, pipeline, type, key, propsCount, remoteRequestData, temp; temp = this; session = temp.session; data = temp.data; props = temp.props; pipeline = temp.pipeline; type = temp.type; key = temp.key; propsCount = 0; props = Caf.object(props, null, (v, k) => v != null && k !== "key" && k !== "data"); data = Caf.object(data, null, (v) => v != null); remoteRequestData = null; if (session.signature) {(remoteRequestData != null ? remoteRequestData : remoteRequestData = {}).session = session.signature;}; if (0 < objectHasKeys(props)) {(remoteRequestData != null ? remoteRequestData : remoteRequestData = {}).props = props;}; if (0 < objectHasKeys(data)) {(remoteRequestData != null ? remoteRequestData : remoteRequestData = {}).data = data;}; return getRestClientParamsForArtEryRequest({restPath: pipeline.restPath, type, key, session, data: remoteRequestData, server: (() => {switch (pipeline.remoteServer) {case true: case ".": case "/": return ""; default: return pipeline.remoteServer;};})()});}}); this.createFromRemoteRequestProps = function({session, pipeline, type, key, requestData: {data, props}, remoteRequest}) {return new Request({remoteRequest, pipeline, type, session, key, data, props, originatedOnClient: true});}; this.prototype.sendRemoteRequest = function() {let remoteRequest; return restJsonRequest(remoteRequest = this.remoteRequestProps).catch((error) => {let status, response, message, temp; ({status = failure, response, message} = ((temp = error.info) != null ? temp : error)); return merge(response, {status, message});}).then((remoteResponse) => this.addFilterLog(`${Caf.toString(remoteRequest.method.toLocaleUpperCase())} ${Caf.toString(remoteRequest.url)}`, "remoteRequest").toResponse(remoteResponse.status, merge(remoteResponse, {remoteRequest, remoteResponse})));};});});});
//# sourceMappingURL=Request.js.map
