"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["AfterEventsFilter", "Promise", "missing", "compactFlatten", "log", "Error", "deepMerge"], [global, require('./StandardImport'), {AfterEventsFilter: require('./Filters').AfterEventsFilter}], (AfterEventsFilter, Promise, missing, compactFlatten, log, Error, deepMerge) => {let ArtEry; ArtEry = require("./namespace"); return function(superClass) {let UpdateAfterMixin; return UpdateAfterMixin = Caf.defClass(class UpdateAfterMixin extends superClass {}, function(UpdateAfterMixin, classSuper, instanceSuper) {this.updateAfter = function(eventMap) {return Caf.array(eventMap, (requestTypeMap, requestType) => Caf.array(requestTypeMap, (updateRequestPropsFunction, pipelineName) => {AfterEventsFilter.registerPipelineListener(this, pipelineName, requestType); return this._addUpdateAfterFunction(pipelineName, requestType, updateRequestPropsFunction);}));}; this.afterEvent = function(eventMap) {return Caf.array(eventMap, (requestTypeMap, requestType) => Caf.array(requestTypeMap, (afterEventFunction, pipelineName) => {AfterEventsFilter.registerPipelineListener(this, pipelineName, requestType); return this._addAfterEventFunction(pipelineName, requestType, afterEventFunction);}));}; this.deleteAfter = function(eventMap) {let pipelineName; pipelineName = this.getPipelineName(); return this.afterEvent(Caf.object(eventMap, (requestTypeMap) => Caf.object(requestTypeMap, (getPropsFunction, otherPipelineName) => (response) => Promise.resolve(getPropsFunction(response)).then((props) => props ? response.subrequest(pipelineName, "delete", props).catch((error) => (error.status === missing) ? response.success() : (() => {throw error;})()) : undefined))));}; this.extendableProperty({updatePropsFunctions: {}, afterEventFunctions: {}}); this._addUpdateAfterFunction = function(pipelineName, requestType, updatePropsFunction) {let temp, base, temp1, base1; return (((temp = (base = ((temp1 = (base1 = this.extendUpdatePropsFunctions())[pipelineName]) != null ? temp1 : base1[pipelineName] = {}))[requestType]) != null ? temp : base[requestType] = [])).push(updatePropsFunction);}; this._addAfterEventFunction = function(pipelineName, requestType, afterEventFunction) {let temp, base, temp1, base1; return (((temp = (base = ((temp1 = (base1 = this.extendAfterEventFunctions())[pipelineName]) != null ? temp1 : base1[pipelineName] = {}))[requestType]) != null ? temp : base[requestType] = [])).push(afterEventFunction);}; this._mergeUpdateProps = function(manyUpdateItemProps, toUpdatePipelineName) {let pipeline, out; pipeline = ArtEry.pipelines[toUpdatePipelineName]; return Caf.each2(compactFlatten(manyUpdateItemProps), (props) => {let key; if (!props.key) {log.error({"key not found for one or more updateItem entries": {manyUpdateItemProps}}); throw new Error(`${Caf.toString(this.getName())}.updateAfter: key required for each updateItem param set (see log for details)`);}; key = pipeline.toKeyString(props.key); return out[key] = out[key] ? deepMerge(out[key], props) : props;}, (props) => props, out = {});}; this._applyAllUpdates = function(response) {let updateRequestsByToUpdatePipeline; updateRequestsByToUpdatePipeline = response.context.updateRequestsByToUpdatePipeline; response.context.updateRequestsByToUpdatePipeline = null; return updateRequestsByToUpdatePipeline ? Promise.deepAll(updateRequestsByToUpdatePipeline).then((resolvedUpdateRequestsByToUpdatePipeline) => Promise.all(Caf.array(resolvedUpdateRequestsByToUpdatePipeline, (updatePropsList, toUpdatePipelineName) => Promise.all(Caf.array(this._mergeUpdateProps(updatePropsList, toUpdatePipelineName), (props) => {let type; type = (Caf.exists(props) && props.createOrUpdate) ? "createOrUpdate" : "update"; return response.subrequest(toUpdatePipelineName, type, {props});}))))).then(() => this._applyAllUpdates(response)) : Promise.resolve();}; this.filter({name: "UpdateAfterMixinFilter", group: "outer", filterFailures: true, before: {all: function(request) {request.context.updateAfterMixinDepth = (request.context.updateAfterMixinDepth || 0) + 1; return request;}}, after: {all: function(request) {return ((request.context.updateAfterMixinDepth === 1) ? UpdateAfterMixin._applyAllUpdates(request) : Promise.resolve()).then(() => {request.context.updateAfterMixinDepth--; return request;});}}}); this.handleRequestAfterEvent = function(request) {let requestType, triggeringPipelineName, toUpdatePipeline, toUpdatePipelineName, temp, base, temp1, base1, base2, base3; requestType = request.requestType; triggeringPipelineName = request.pipelineName; toUpdatePipeline = this.singleton; toUpdatePipelineName = toUpdatePipeline.pipelineName; (((temp = (base = ((temp1 = (base1 = request.context).updateRequestsByToUpdatePipeline) != null ? temp1 : base1.updateRequestsByToUpdatePipeline = {}))[toUpdatePipelineName]) != null ? temp : base[toUpdatePipelineName] = [])).push(Caf.array(Caf.exists(base2 = this.getUpdatePropsFunctions()[triggeringPipelineName]) && base2[requestType], (updateRequestPropsFunction) => updateRequestPropsFunction.call(toUpdatePipeline, request))); return Promise.deepAll(Caf.array(Caf.exists(base3 = this.getAfterEventFunctions()[triggeringPipelineName]) && base3[requestType], (afterEventFunction) => afterEventFunction.call(toUpdatePipeline, request)));};});};});});
//# sourceMappingURL=UpdateAfterMixin.js.map
