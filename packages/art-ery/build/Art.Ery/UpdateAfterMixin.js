"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["AfterEventsFilter", "Promise", "missing", "pipelines", "compactFlatten", "log", "Error", "deepMerge"], [global, require('./StandardImport'), require('./PipelineRegistry'), {AfterEventsFilter: require('./Filters/AfterEventsFilter')}], (AfterEventsFilter, Promise, missing, pipelines, compactFlatten, log, Error, deepMerge) => {return function(superClass) {let UpdateAfterMixin; return UpdateAfterMixin = Caf.defClass(class UpdateAfterMixin extends superClass {}, function(UpdateAfterMixin, classSuper, instanceSuper) {this.updateAfter = function(eventMap) {return Caf.array(eventMap, (requestTypeMap, requestType) => Caf.array(requestTypeMap, (updateRequestPropsFunction, pipelineName) => {AfterEventsFilter.registerPipelineListener(this, pipelineName, requestType); return this._addUpdateAfterFunction(pipelineName, requestType, updateRequestPropsFunction);}));}; this.afterEvent = function(eventMap) {return Caf.array(eventMap, (requestTypeMap, requestType) => Caf.array(requestTypeMap, (afterEventFunction, pipelineName) => {AfterEventsFilter.registerPipelineListener(this, pipelineName, requestType); return this._addAfterEventFunction(pipelineName, requestType, afterEventFunction);}));}; this.deleteAfter = function(eventMap) {let pipelineName; pipelineName = this.getPipelineName(); return this.afterEvent(Caf.object(eventMap, (requestTypeMap) => Caf.object(requestTypeMap, (getPropsFunction, otherPipelineName) => (response) => Promise.resolve(getPropsFunction(response)).then((props) => props ? response.subrequest(pipelineName, "delete", props).catch((error) => (error.status === missing) ? response.success() : (() => {throw error;})()) : undefined))));}; this.extendableProperty({updatePropsFunctions: {}, afterEventFunctions: {}}); this._addUpdateAfterFunction = function(pipelineName, requestType, updatePropsFunction) {let temp, base, temp1, base1; return (((temp = (base = ((temp1 = (base1 = this.extendUpdatePropsFunctions())[pipelineName]) != null ? temp1 : base1[pipelineName] = {}))[requestType]) != null ? temp : base[requestType] = [])).push(updatePropsFunction);}; this._addAfterEventFunction = function(pipelineName, requestType, afterEventFunction) {let temp, base, temp1, base1; return (((temp = (base = ((temp1 = (base1 = this.extendAfterEventFunctions())[pipelineName]) != null ? temp1 : base1[pipelineName] = {}))[requestType]) != null ? temp : base[requestType] = [])).push(afterEventFunction);}; this._mergeUpdateProps = function(manyUpdateItemProps, toUpdatePipelineName) {let pipeline, result; pipeline = pipelines[toUpdatePipelineName]; return Caf.object(compactFlatten(manyUpdateItemProps), (props) => {let key; if (!props.key) {log.error({"key not found for one or more updateItem entries": {manyUpdateItemProps}}); throw new Error(`${Caf.toString(this.getName())}.updateAfter: key required for each updateItem param set (see log for details)`);}; key = pipeline.toKeyString(props.key); return result[key] ? deepMerge(result[key], props) : props;}, (props) => props, result = {}, (props) => pipeline.toKeyString(props.key));}; this._applyAllUpdates = function(response) {let updateRequestsByToUpdatePipeline; ({updateRequestsByToUpdatePipeline} = response.context); response.context.updateRequestsByToUpdatePipeline = null; return updateRequestsByToUpdatePipeline ? Promise.deepAll(updateRequestsByToUpdatePipeline).then((resolvedUpdateRequestsByToUpdatePipeline) => Promise.deepAll(Caf.array(resolvedUpdateRequestsByToUpdatePipeline, (updatePropsList, toUpdatePipelineName) => Caf.array(this._mergeUpdateProps(updatePropsList, toUpdatePipelineName), (props) => response.subrequest(toUpdatePipelineName, (Caf.exists(props) && props.createOrUpdate) ? "createOrUpdate" : "update", {props}))))).then(() => this._applyAllUpdates(response)) : Promise.resolve();}; this.filter({name: "UpdateAfterMixinFilter", group: "outer", filterFailures: true, before: {all: function(request) {request.context.updateAfterMixinDepth = (request.context.updateAfterMixinDepth || 0) + 1; return request;}}, after: {all: function(request) {let p; p = (request.context.updateAfterMixinDepth === 1) ? UpdateAfterMixin._applyAllUpdates(request) : Promise.resolve(); return p.then(() => {request.context.updateAfterMixinDepth--; return request;});}}}); this.handleRequestAfterEvent = function(request) {let triggeringPipelineName, requestType, toUpdatePipeline, toUpdatePipelineName, base, base1, base2, base3; triggeringPipelineName = request.pipelineName; requestType = request.requestType; toUpdatePipeline = this.singleton; toUpdatePipelineName = toUpdatePipeline.pipelineName; ((base = (base1 = request.context).updateRequestsByToUpdatePipeline || (base1.updateRequestsByToUpdatePipeline = {}))[toUpdatePipelineName] || (base[toUpdatePipelineName] = [])).push(Caf.array(Caf.exists(base2 = this.getUpdatePropsFunctions()[triggeringPipelineName]) && base2[requestType], (updateRequestPropsFunction) => updateRequestPropsFunction.call(toUpdatePipeline, request))); return Promise.deepAll(Caf.array(Caf.exists(base3 = this.getAfterEventFunctions()[triggeringPipelineName]) && base3[requestType], (afterEventFunction) => afterEventFunction.call(toUpdatePipeline, request)));};});};});});
//# sourceMappingURL=UpdateAfterMixin.js.map
