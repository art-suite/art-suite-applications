// Generated by CoffeeScript 1.12.7
(function() {
  var AfterEventsFilter, ArtEry, KeyFieldsMixin, Pipeline, Promise, array, compactFlatten, deepMerge, defineModule, formattedInspect, log, merge, missing, object, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('art-standard-lib'), defineModule = ref.defineModule, log = ref.log, merge = ref.merge, Promise = ref.Promise, object = ref.object, deepMerge = ref.deepMerge, compactFlatten = ref.compactFlatten, formattedInspect = ref.formattedInspect, array = ref.array;

  ArtEry = require('./namespace');

  Pipeline = require('./Pipeline');

  KeyFieldsMixin = require('./KeyFieldsMixin');

  AfterEventsFilter = require('./Filters').AfterEventsFilter;

  missing = require('art-communication-status').missing;

  defineModule(module, function() {
    return function(superClass) {
      var UpdateAfterMixin;
      return UpdateAfterMixin = (function(superClass1) {
        extend(UpdateAfterMixin, superClass1);

        function UpdateAfterMixin() {
          return UpdateAfterMixin.__super__.constructor.apply(this, arguments);
        }


        /*
        updateAfter vs afterEvent
        
        afterEvent is more basic, gives you more control, but lacks the special features
        updateAfter can deliver.
        
        afterEvent:
          Invokes the specified function when the AfterEvent fires for the specified
          type and pipeline. The return results is resolved if it is a promise, but unless
          the promise is rejected or an error is thrown, the result is ignored.
        
          That's it. That's all afterEvent does.
        
          SEE: AfterEventsFilter
        
        updateAfter:
          The specified function should return a propsObject or array-of-propsObjects
          (optionally via a promise).
          After the rootRequest(*) completes, all updateAfter props are aggregated and
          deep-merged (for the same pipeline+key) and then update is called for each
          unique pipeline+key pair.
        
          If any of the updates fail, the rootRequest fails.
          If any of the updatePropsFunctions fail, the triggering-request fails.
        
        updateAfter's key benefit:
          If you update the same record more than once for the same rootRequest via
          updateAfter functions, there will only be one 'update' request invoked.
        
          Exception/Feature: afterUpdates can trigger other afterUpdates, but they
          are always processed in a depth-first manner: all current afterUpdates
          are aggregated until no more are requested, then they are all processed,
          possibly triggering the next tier of afterUpdates.
        
        (*) Technically the update requests due to updateAfters are triggered
          after the root-most request on a pipeline that mixed in UpdateAfterMixin,
          not strictly the rootRequest. If you use the UpdateAfterMixin on all your
          pipelines, it will always be the rootRequest.
         */


        /*
        updateAfter:
          declare records in THIS pipeline that should be updated AFTER
          requests complete against another pipeline (or this one).
        
        IN: eventMap looks like:
          requestType: triggeringPipelineName: updateItemPropsFunction
        
          updateItemPropsFunction: (response) -> updateItemProps
          IN: response is the ArtEry request-response for the request-in-progress on
            the specified triggeringPipelineName.
            (response.pipelineName == the specified triggeringPipelineName)
        
          OUT: props object OR an array (compactFlattened) of props objects
            props-objects:
              Must have 'key' set to a string
              All same-key props-objects are deepMerged in the order they are listed.
                (i.e. last has priority)
        
        EXAMPLE:
          class User extends UpdateAfterMixin Pipeline
            @updateAfter
               * Increment postCount for all visible posts created by a user.
              create: post: ({data:{userId, createdAt, invisible}}) ->
                if !invisible
                  key:  userId
                  data: lastPostCreatedAt: createdAt
                  add:  visiblePostCount: 1
         */

        UpdateAfterMixin.updateAfter = function(eventMap) {
          var pipelineName, requestType, requestTypeMap, results, updateRequestPropsFunction;
          results = [];
          for (requestType in eventMap) {
            requestTypeMap = eventMap[requestType];
            results.push((function() {
              var results1;
              results1 = [];
              for (pipelineName in requestTypeMap) {
                updateRequestPropsFunction = requestTypeMap[pipelineName];
                AfterEventsFilter.registerPipelineListener(this, pipelineName, requestType);
                results1.push(this._addUpdateAfterFunction(pipelineName, requestType, updateRequestPropsFunction));
              }
              return results1;
            }).call(this));
          }
          return results;
        };


        /*
        afterEvent: Add your own event handler after other pipeline's successful requests.
        If you return a promise:
          The original request won't complete (or succeed) until your returned promise resolves.
          If your promise is rejected, the original request is rejected.
        
        IN: eventMap looks like:
          requestType: pipelineName: (response) -> (ignored except for errors)
         */

        UpdateAfterMixin.afterEvent = function(eventMap) {
          var afterEventFunction, pipelineName, requestType, requestTypeMap, results;
          results = [];
          for (requestType in eventMap) {
            requestTypeMap = eventMap[requestType];
            results.push((function() {
              var results1;
              results1 = [];
              for (pipelineName in requestTypeMap) {
                afterEventFunction = requestTypeMap[pipelineName];
                AfterEventsFilter.registerPipelineListener(this, pipelineName, requestType);
                results1.push(this._addAfterEventFunction(pipelineName, requestType, afterEventFunction));
              }
              return results1;
            }).call(this));
          }
          return results;
        };

        UpdateAfterMixin.deleteAfter = function(eventMap) {
          var pipelineName;
          pipelineName = this.getPipelineName();
          return this.afterEvent(object(eventMap, function(requestTypeMap) {
            return object(requestTypeMap, function(getPropsFunction, otherPipelineName) {
              return function(response) {
                return Promise.resolve(getPropsFunction(response)).then(function(props) {
                  if (props) {
                    return response.subrequest(pipelineName, "delete", props)["catch"](function(error) {
                      if (error.status === missing) {
                        return response.success();
                      } else {
                        throw error;
                      }
                    });
                  }
                });
              };
            });
          }));
        };

        UpdateAfterMixin.extendableProperty({
          updatePropsFunctions: {},
          afterEventFunctions: {}
        });

        UpdateAfterMixin._addUpdateAfterFunction = function(pipelineName, requestType, updatePropsFunction) {
          var base, base1;
          return ((base = ((base1 = this.extendUpdatePropsFunctions())[pipelineName] || (base1[pipelineName] = {})))[requestType] || (base[requestType] = [])).push(updatePropsFunction);
        };

        UpdateAfterMixin._addAfterEventFunction = function(pipelineName, requestType, afterEventFunction) {
          var base, base1;
          return ((base = ((base1 = this.extendAfterEventFunctions())[pipelineName] || (base1[pipelineName] = {})))[requestType] || (base[requestType] = [])).push(afterEventFunction);
        };

        UpdateAfterMixin._mergeUpdateProps = function(manyUpdateItemProps, toUpdatePipelineName) {
          var pipeline;
          pipeline = ArtEry.pipelines[toUpdatePipelineName];
          return object(compactFlatten(manyUpdateItemProps), {
            key: (function(_this) {
              return function(arg) {
                var key;
                key = arg.key;
                return pipeline.toKeyString(key);
              };
            })(this),
            when: function(props) {
              return props;
            },
            "with": (function(_this) {
              return function(props, inputKey, into) {
                var key;
                if (!props.key) {
                  log.error({
                    "key not found for one or more updateItem entries": {
                      manyUpdateItemProps: manyUpdateItemProps
                    }
                  });
                  throw new Error((_this.getName()) + ".updateAfter: key required for each updateItem param set (see log for details)");
                }
                key = pipeline.toKeyString(props.key);
                if (into[key]) {
                  return deepMerge(into[key], props);
                } else {
                  return props;
                }
              };
            })(this)
          });
        };

        UpdateAfterMixin._applyAllUpdates = function(response) {
          var updateRequestsByToUpdatePipeline;
          updateRequestsByToUpdatePipeline = response.context.updateRequestsByToUpdatePipeline;
          response.context.updateRequestsByToUpdatePipeline = null;
          if (updateRequestsByToUpdatePipeline) {
            return Promise.deepAll(updateRequestsByToUpdatePipeline).then((function(_this) {
              return function(resolvedUpdateRequestsByToUpdatePipeline) {
                return Promise.all(array(resolvedUpdateRequestsByToUpdatePipeline, function(updatePropsList, toUpdatePipelineName) {
                  return Promise.all(array(_this._mergeUpdateProps(updatePropsList, toUpdatePipelineName), function(props) {
                    var type;
                    type = (props != null ? props.createOrUpdate : void 0) ? "createOrUpdate" : "update";
                    return response.subrequest(toUpdatePipelineName, type, {
                      props: props
                    });
                  }));
                }));
              };
            })(this)).then((function(_this) {
              return function() {
                return _this._applyAllUpdates(response);
              };
            })(this));
          } else {
            return Promise.resolve();
          }
        };


        /*
        UpdateAfterMixinFilter provides the functionality of only triggering
        updates when the rootRequest(*) completes.
         */

        UpdateAfterMixin.filter({
          name: "UpdateAfterMixinFilter",
          group: "outer",
          filterFailures: true,
          before: {
            all: function(request) {
              request.context.updateAfterMixinDepth = (request.context.updateAfterMixinDepth || 0) + 1;
              return request;
            }
          },
          after: {
            all: function(request) {
              var p;
              p = request.context.updateAfterMixinDepth === 1 ? UpdateAfterMixin._applyAllUpdates(request) : Promise.resolve();
              return p.then(function() {
                request.context.updateAfterMixinDepth--;
                return request;
              });
            }
          }
        });

        UpdateAfterMixin.handleRequestAfterEvent = function(request) {
          var base, base1, ref1, ref2, requestType, toUpdatePipeline, toUpdatePipelineName, triggeringPipelineName;
          triggeringPipelineName = request.pipelineName, requestType = request.requestType;
          toUpdatePipeline = this.singleton;
          toUpdatePipelineName = toUpdatePipeline.pipelineName;
          ((base = ((base1 = request.context).updateRequestsByToUpdatePipeline || (base1.updateRequestsByToUpdatePipeline = {})))[toUpdatePipelineName] || (base[toUpdatePipelineName] = [])).push(array((ref1 = this.getUpdatePropsFunctions()[triggeringPipelineName]) != null ? ref1[requestType] : void 0, (function(_this) {
            return function(updateRequestPropsFunction) {
              return updateRequestPropsFunction.call(toUpdatePipeline, request);
            };
          })(this)));
          return Promise.deepAll(array((ref2 = this.getAfterEventFunctions()[triggeringPipelineName]) != null ? ref2[requestType] : void 0, (function(_this) {
            return function(afterEventFunction) {
              return afterEventFunction.call(toUpdatePipeline, request);
            };
          })(this)));
        };

        return UpdateAfterMixin;

      })(superClass);
    };
  });

}).call(this);

//# sourceMappingURL=UpdateAfterMixin.js.map
