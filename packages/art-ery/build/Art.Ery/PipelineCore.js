"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["decapitalize", "getCodeWords", "pluralize", "lowerCamelCase", "isClass", "isFunction", "Filter", "isPlainObject", "inspect", "compactFlatten", "pushIfNotPresent", "Session", "mergeInto", "Object", "inspectedObjectLiteral", "RequestResponseBase", "isString", "merge", "currentSecond", "log", "getDetailedRequestTracingEnabled", "Error", "Promise", "Request", "cleanStackTrace", "formattedInspect"], [global, require('./StandardImport'), {RequestResponseBase: require('./RequestResponseBase'), Request: require('./Request'), Filter: require('./Filter'), Session: require('./Session')}], (decapitalize, getCodeWords, pluralize, lowerCamelCase, isClass, isFunction, Filter, isPlainObject, inspect, compactFlatten, pushIfNotPresent, Session, mergeInto, Object, inspectedObjectLiteral, RequestResponseBase, isString, merge, currentSecond, log, getDetailedRequestTracingEnabled, Error, Promise, Request, cleanStackTrace, formattedInspect) => {let PipelineCore; return PipelineCore = Caf.defClass(class PipelineCore extends require('./RequestHandler') {constructor(_options = {}) {super(...arguments); this._options = _options;};}, function(PipelineCore, classSuper, instanceSuper) {let instantiateFilter, filters, groupFilters, noOptions, mostRecentSessionUpdatedAt; this.abstractClass(); this.register = function() {this.singletonClass(); return require('./PipelineRegistry').register(this);}; this.postCreateConcreteClass = function({hotReloaded}) {this._defineRequestMethods(); if (!hotReloaded) {this.register();}; return classSuper.postCreateConcreteClass.apply(this, arguments);}; this.extendableProperty({filters: [], handlers: {}}); this.classGetter({pipelineName: function() {return this._pipelineName || decapitalize(this.getName());}, pluralPipelineName: function() {let parts; if (this._pluralPipelineName) {return this._pluralPipelineName;}; parts = getCodeWords(this.getPipelineName()); parts.push(pluralize(parts.pop())); return this._pluralPipelineName = lowerCamelCase(parts);}}); this.handler = this.extendHandlers; this.handlers = this.extendHandlers; this.instantiateFilter = instantiateFilter = function(filter) {return isClass(filter) ? new filter : isFunction(filter) ? filter(this) : (filter instanceof Filter) ? filter : isPlainObject(filter) ? new Filter(filter) : (() => {throw `invalid filter: ${Caf.toString(inspect(filter))} ${Caf.toString(filter instanceof Filter)}`;})();}; this.filter = filters = function(...filter) {return this.extendFilters(Caf.array(compactFlatten(filter), (f) => instantiateFilter(f)));}; this.filters = filters; this.getter({groupedFilters: function() {let temp; return ((temp = this._groupedFilters) != null ? temp : this._groupedFilters = groupFilters(this.filters));}, beforeFilters: function(request) {let temp; return request ? Caf.array(this.beforeFilters, null, (filter) => filter.getBeforeFilter(request)) : ((temp = this._beforeFilters) != null ? temp : this._beforeFilters = this.groupedFilters.slice().reverse());}, afterFilters: function(request) {return request ? Caf.array(this.afterFilters, null, (filter) => filter.getAfterFilter(request)) : this.groupedFilters;}, filterChain: function() {let temp; return ((temp = this._filterChain) != null ? temp : this._filterChain = compactFlatten([this, this.groupedFilters]).reverse());}}); this.groupFilters = groupFilters = function(filters) {let priorityLevels, sortedFilters; priorityLevels = []; Caf.each2(filters, ({priority}) => pushIfNotPresent(priorityLevels, priority)); sortedFilters = []; Caf.each2(priorityLevels.sort((a, b) => a - b), (priorityLevels) => Caf.each2(filters, (filter) => sortedFilters.push(filter), (filter) => priorityLevels === filter.priority)); return sortedFilters;}; this.getter("options", {pipelineName: function() {return this.class.getPipelineName();}, name: function() {return this._name || (this._name = this._options.name || decapitalize(this.class.getName()));}, session: function() {return this._session || (this._session = this._options.session || Session.singleton);}, handlerRequestTypesMap: function(_into = {}) {return mergeInto(_into, this.handlers);}, filterRequestTypesMap: function(_into = {}) {Caf.each2(this.filters, (filter) => mergeInto(_into, filter.beforeFilters)); return _into;}, requestTypesMap: function(_into = {}) {return this.getHandlerRequestTypesMap(this.getFilterRequestTypesMap(_into));}, requestTypes: function() {return Object.keys(this.requestTypesMap);}, inspectedObjects: function() {return inspectedObjectLiteral(this.name);}, pipelineReport: function() {return this.getPipelineReport();}}); this.prototype.toString = function() {return this.pipelineName;}; this.prototype.getLogName = function(requestType) {return `${Caf.toString(requestType)}-handler`;}; this.prototype.getPipelineReport = function(processingLocation) {return {tableName: this.tableName, requestProcessing: Caf.object(this.requestTypes, (requestType) => compactFlatten([Caf.array(this.getBeforeFilters({requestType}), (filter) => inspectedObjectLiteral(filter.getName())), "[handler]", Caf.array(this.getAfterFilters({requestType}), (filter) => inspectedObjectLiteral(filter.getName()))]))};}; noOptions = {}; this.prototype.request = function(type, a, b, c) {let parentRequest, options, requestStartTime; if (!(a != null)) {a = b; b = c;}; if (a != null && a instanceof RequestResponseBase) {parentRequest = a; a = b; b = c;}; options = isString(a) ? merge({key: a}, b) : a != null ? a : noOptions; return parentRequest ? parentRequest.subrequest(this, type, (options !== noOptions) ? options : {props: parentRequest.props}) : (requestStartTime = currentSecond(), this.createRequest(type, options).then((request) => this._processRequest(request)).then((response) => this._processResponseSession(response, requestStartTime)).then((response) => response.toPromise(options)));}; this.prototype.cachedGet = function(request, key) {return request.cachedGet(this.pipelineName, key != null ? key : request.key);}; this.prototype.createRequest = function(type, options) {let stack; if (!isPlainObject(options)) {log.warn("DEPRICATED - options must be an object now");}; if (isString(options)) {options = {key: options};}; if (getDetailedRequestTracingEnabled()) {({stack} = new Error);}; return Promise.then(() => options.session || this.session.loadedDataPromise).tapCatch((error) => log.error({Pipeline_createRequest: {message: "Error getting session", info: {pipelineName: this.pipelineName, type, options}, error}})).then((sessionData) => new Request(merge(options, {type, pipeline: this, session: sessionData, creationStack: stack}))).catch((error) => {if (stack != null) {error.stack = cleanStackTrace(stack);}; error.message += `\n\ninside ${Caf.toString(this.name)}.` + formattedInspect({createRequest: {type, options}}); return (() => {throw error;})();});}; this.prototype.canHandleRequestType = function(request) {return !!this.handlers[request.type];}; this.prototype.handleRequest = function(request) {let handler; return (handler = this.handlers[request.type]) ? this.applyHandler(request, handler, "handler").then((response) => !response.isResponse ? request.failure(`${Caf.toString(this.pipelineName)}.${Caf.toString(request.type)} request was not handled`) : response) : request.failure(`${Caf.toString(this.pipelineName)}: No handler for request type: ${Caf.toString(formattedInspect(request.type))}`);}; this.prototype._normalizeRequest = function(request) {return isPlainObject(request) ? new Request(merge(request, {pipeline: this})) : request;}; this.prototype._processRequest = function(request) {return !this.canHandleRequestType(request) ? Promise.then(() => request.clientFailure({data: {message: `'${Caf.toString(request.type)}' is an invalid request type`, validRequestTypes: Object.keys(this.handlers)}})) : Promise.then(() => this.filterChain[0].handleRequest(request, this.filterChain, 0)).then((response) => {if (!response.isResponse) {log.error({"not response!": response});}; return response;});}; mostRecentSessionUpdatedAt = 0; this.prototype._processResponseSession = function(response, requestStartTime) {let responseSession, currentSession; ({responseSession} = response); if (responseSession) {currentSession = this.session.data; if (requestStartTime > mostRecentSessionUpdatedAt) {mostRecentSessionUpdatedAt = requestStartTime; this.session.data = responseSession;};}; return response;}; this._defineRequestMethod = function(requestType) {let temp, base; return ((temp = (base = this.prototype)[requestType]) != null ? temp : base[requestType] = function(a, b, c) {return this.request(requestType, a, b, c);});}; this._defineRequestMethods = function() {return Caf.each2(this.getHandlers(), (__, name) => this._defineRequestMethod(name));};});});});
//# sourceMappingURL=PipelineCore.js.map
