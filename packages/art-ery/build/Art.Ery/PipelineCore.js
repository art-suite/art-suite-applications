"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["isClass", "isFunction", "Filter", "isPlainObject", "inspect", "compactFlatten", "RequestResponseBase", "isString", "merge", "currentSecond", "log", "getDetailedRequestTracingEnabled", "Error", "Promise", "Request", "cleanStackTrace", "formattedInspect", "Object"], [global, require('./StandardImport'), {RequestResponseBase: require('./RequestResponseBase'), Request: require('./Request'), Filter: require('./Filter')}], (isClass, isFunction, Filter, isPlainObject, inspect, compactFlatten, RequestResponseBase, isString, merge, currentSecond, log, getDetailedRequestTracingEnabled, Error, Promise, Request, cleanStackTrace, formattedInspect, Object) => {let PipelineCore; return PipelineCore = Caf.defClass(class PipelineCore extends require('./RequestHandler') {}, function(PipelineCore, classSuper, instanceSuper) {let instantiateFilter, noOptions, mostRecentSessionUpdatedAt; this.abstractClass(); this.register = function() {this.singletonClass(); return require('./PipelineRegistry').register(this);}; this.postCreateConcreteClass = function({hotReloaded}) {this._defineRequestMethods(); if (!hotReloaded) {this.register();}; return classSuper.postCreateConcreteClass.apply(this, arguments);}; this.extendableProperty({filters: [], handlers: {}}); this.handler = this.extendHandlers; this.handlers = this.extendHandlers; this.instantiateFilter = instantiateFilter = function(filter) {return isClass(filter) ? new filter : isFunction(filter) ? filter(this) : (filter instanceof Filter) ? filter : isPlainObject(filter) ? new Filter(filter) : (() => {throw `invalid filter: ${Caf.toString(inspect(filter))} ${Caf.toString(filter instanceof Filter)}`;})();}; this.filter = function(...filter) {return this.extendFilters(Caf.array(compactFlatten(filter), (f) => instantiateFilter(f)));}; noOptions = {}; this.prototype.request = function(type, a, b, c) {let parentRequest, options, requestStartTime; if (!(a != null)) {a = b; b = c;}; if (a != null && a instanceof RequestResponseBase) {parentRequest = a; a = b; b = c;}; options = isString(a) ? merge({key: a}, b) : a != null ? a : noOptions; return parentRequest ? parentRequest.subrequest(this, type, (options !== noOptions) ? options : {props: parentRequest.props}) : (requestStartTime = currentSecond(), this.createRequest(type, options).then((request) => this._processRequest(request)).then((response) => this._processResponseSession(response, requestStartTime)).then((response) => response.toPromise(options)));}; this.prototype.createRequest = function(type, options) {let stack; if (!isPlainObject(options)) {log.warn("DEPRICATED - options must be an object now");}; if (isString(options)) {options = {key: options};}; if (getDetailedRequestTracingEnabled()) {({stack} = new Error);}; return Promise.then(() => options.session || this.session.loadedDataPromise).tapCatch((error) => log.error({Pipeline_createRequest: {message: "Error getting session", info: {pipelineName: this.pipelineName, type, options}, error}})).then((sessionData) => new Request(merge(options, {type, pipeline: this, session: sessionData, creationStack: stack}))).catch((error) => {if (stack != null) {error.stack = cleanStackTrace(stack);}; error.message += `\n\ninside ${Caf.toString(this.name)}.` + formattedInspect({createRequest: {type, options}}); return (() => {throw error;})();});}; this.prototype._normalizeRequest = function(request) {return isPlainObject(request) ? new Request(merge(request, {pipeline: this})) : request;}; this.prototype._processRequest = function(request) {let haveHandler, isPublicRequestType; haveHandler = !!this.handlers[request.type]; isPublicRequestType = !!this.getPublicRequestTypes()[request.type]; return !(haveHandler || isPublicRequestType) ? Promise.then(() => request.clientFailure({data: {message: `'${Caf.toString(request.type)}' is an invalid request type`, validRequestTypes: Object.keys(this.handlers)}})) : request.requireServerOriginOr(isPublicRequestType, "to issue non-public requests").then(() => this.filterChain[0].handleRequest(request, this.filterChain, 0)).then((response) => {if (!response.isResponse) {log.error({"not response!": response});}; return response;});}; mostRecentSessionUpdatedAt = 0; this.prototype._processResponseSession = function(response, requestStartTime) {let responseSession, currentSession; ({responseSession} = response); if (responseSession) {currentSession = this.session.data; if (requestStartTime > mostRecentSessionUpdatedAt) {mostRecentSessionUpdatedAt = requestStartTime; this.session.data = responseSession;};}; return response;}; this._defineRequestMethod = function(requestType) {let temp, base; return ((temp = (base = this.prototype)[requestType]) != null ? temp : base[requestType] = function(a, b, c) {return this.request(requestType, a, b, c);});}; this._defineRequestMethods = function() {Caf.each2(this.getHandlers(), (__, name) => this._defineRequestMethod(name)); Caf.each2(this.getPublicRequestTypes(), (__, name) => this._defineRequestMethod(name)); return null;};});});});
//# sourceMappingURL=PipelineCore.js.map
