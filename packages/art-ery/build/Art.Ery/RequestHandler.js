"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Promise", "dashCase", "neq", "log", "RequestResponseBase", "isJsonType", "ErrorWithInfo", "isFailure"], [global, require('./StandardImport'), {RequestResponseBase: require('./RequestResponseBase')}], (Promise, dashCase, neq, log, RequestResponseBase, isJsonType, ErrorWithInfo, isFailure) => {let RequestHandler; return RequestHandler = Caf.defClass(class RequestHandler extends require('./ArtEryBaseObject') {}, function(RequestHandler, classSuper, instanceSuper) {this.abstractClass(); this.prototype.applyHandler = function(request, handlerFunction, context) {return !handlerFunction ? Promise.resolve(request) : this._applyHandler(request, handlerFunction, context).then((response) => {let base; return (Caf.exists(response) && response.isFailure && !(Caf.exists(base = response.errorProps) && base.failedIn)) ? response.withMergedErrorProps({failedIn: {context, handler: this, response}}) : response;}).tap((result) => {let prefix, logger; return request.verbose ? (prefix = `ArtEryApplyHandlerVerbose ${Caf.toString(request.requestString)} - ${Caf.toString(dashCase(context))} ${Caf.toString(this.getLogName(this.type))}`, (result !== request && neq(request.summary, result.summary)) ? (logger = (result.failed && !request.failed) ? log.error : log, logger({[prefix]: {before: request.summary, after: result.summary}})) : log({[prefix]: "no-change"})) : undefined;});}; this.prototype._applyHandler = function(request, handlerFunction, context) {return Promise.then(() => {request.addFilterLog(this, context); return handlerFunction.call(this, request);}).then((data) => (() => {switch (false) {case !(!(data != null)): return request.missing(); case !(data instanceof RequestResponseBase): return data; case !isJsonType(data): return request.success({data}); default: return (() => {throw new ErrorWithInfo("invalid response data passed to RequestResponseBaseNext", {data});})();};})(), (error) => {let status, base, base1, base2; return (Caf.exists(base = error.props) && (Caf.exists(base1 = base.response) && base1.isResponse)) ? error.props.response : isFailure(status = Caf.exists(base2 = error.info) && base2.status) ? request.toResponse(status, {error: error.info}) : request.failure({errorProps: {exception: error, source: {this: this, function: handlerFunction}}});});};});});});
//# sourceMappingURL=RequestHandler.js.map
