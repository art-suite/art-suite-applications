// Generated by CoffeeScript 1.12.7
(function() {
  var ErrorWithInfo, Promise, RequestHandler, RequestResponseBase, dashCase, defineModule, isFailure, isJsonType, log, missing, neq, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./StandardImport'), isFailure = ref.isFailure, missing = ref.missing, ErrorWithInfo = ref.ErrorWithInfo, defineModule = ref.defineModule, dashCase = ref.dashCase, Promise = ref.Promise, isJsonType = ref.isJsonType, log = ref.log, neq = ref.neq;

  RequestResponseBase = require('./RequestResponseBase');

  defineModule(module, RequestHandler = (function(superClass) {
    extend(RequestHandler, superClass);

    function RequestHandler() {
      return RequestHandler.__super__.constructor.apply(this, arguments);
    }

    RequestHandler.abstractClass();


    /*
    OUT:
      promise.then (request or response) ->
        NOTE: response may be failing
      .catch -> internal errors only
     */

    RequestHandler.prototype.applyHandler = function(request, handlerFunction, context) {
      var resultPromise;
      if (!handlerFunction) {
        return Promise.resolve(request);
      }
      resultPromise = this._applyHandler(request, handlerFunction, context).then((function(_this) {
        return function(response) {
          var ref1;
          if ((response != null ? response.isFailure : void 0) && !((ref1 = response.errorProps) != null ? ref1.failedIn : void 0)) {
            return response.withMergedErrorProps({
              failedIn: {
                context: context,
                handler: _this,
                response: response
              }
            });
          } else {
            return response;
          }
        };
      })(this));
      if (request.verbose) {
        resultPromise = resultPromise.tap((function(_this) {
          return function(result) {
            var obj, obj1;
            if (result !== request && neq(request.summary, result.summary)) {
              return (result.failed && !request.failed ? log.error : log)((
                obj = {},
                obj["ArtEryApplyHandlerVerbose " + request.requestString + " - " + (dashCase(context)) + " " + (_this.getLogName(_this.type))] = {
                  before: request.summary,
                  after: result.summary
                },
                obj
              ));
            } else {
              return log((
                obj1 = {},
                obj1["ArtEryApplyHandlerVerbose " + request.requestString + " - " + (dashCase(context)) + " " + (_this.getLogName(_this.type))] = "no-change",
                obj1
              ));
            }
          };
        })(this));
      }
      return resultPromise;
    };

    RequestHandler.prototype._applyHandler = function(request, handlerFunction, context) {
      return Promise.then((function(_this) {
        return function() {
          request.addFilterLog(_this, context);
          return handlerFunction.call(_this, request);
        };
      })(this)).then((function(_this) {
        return function(data) {
          if (data == null) {
            return request.missing();
          } else if (data instanceof RequestResponseBase) {
            return data;
          } else if (isJsonType(data)) {
            return request.success({
              data: data
            });
          } else {
            throw new ErrorWithInfo("invalid response data passed to RequestResponseBaseNext", {
              data: data
            });
          }
        };
      })(this), (function(_this) {
        return function(error) {
          var ref1, ref2, ref3, status;
          if ((ref1 = error.props) != null ? (ref2 = ref1.response) != null ? ref2.isResponse : void 0 : void 0) {
            return error.props.response;
          } else if (isFailure(status = (ref3 = error.info) != null ? ref3.status : void 0)) {
            return request.toResponse(status, {
              error: error.info
            });
          } else {
            return request.failure({
              errorProps: {
                exception: error,
                source: {
                  "this": _this,
                  "function": handlerFunction
                }
              }
            });
          }
        };
      })(this));

      /*
      IN:
        request OR response
      
        if response, it is immediately returned
      OUT:
        promise.then -> response
          response may or maynot be successful, but it is always returned via the promise-success path
      
        promise.catch -> always means an internal failure
      
      OVERRIDE THIS
       */
    };

    return RequestHandler;

  })(require('./ArtEryBaseObject')));

}).call(this);

//# sourceMappingURL=RequestHandler.js.map
