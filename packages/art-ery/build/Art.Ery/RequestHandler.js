"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Promise", "dashCase", "neq", "log", "RequestResponseBase", "isJsonType", "ErrorWithInfo", "isFailure"], [global, require('./StandardImport'), {RequestResponseBase: require('./RequestResponseBase')}], (Promise, dashCase, neq, log, RequestResponseBase, isJsonType, ErrorWithInfo, isFailure) => {let RequestHandler; return RequestHandler = Caf.defClass(class RequestHandler extends require('./ArtEryBaseObject') {}, function(RequestHandler, classSuper, instanceSuper) {this.abstractClass(); this.prototype.applyHandler = function(request, handlerFunction, context) {let resultPromise; if (!handlerFunction) {return Promise.resolve(request);}; resultPromise = this._applyHandler(request, handlerFunction, context).then((response) => {let base; return (Caf.exists(response) && response.isFailure && !(Caf.exists(base = response.errorProps) && base.failedIn)) ? response.withMergedErrorProps({failedIn: {context, handler: this, response}}) : response;}); if (request.verbose) {resultPromise = resultPromise.tap((result) => {let prefix; prefix = `ArtEryApplyHandlerVerbose ${Caf.toString(request.requestString)} - ${Caf.toString(dashCase(context))} ${Caf.toString(this.getLogName(this.type))}`; return (result !== request && neq(request.summary, result.summary)) ? if (result.failed && !request.failed) {log.error;} else {log;}({[prefix]: {before: request.summary, after: result.summary}}) : log({[prefix]: "no-change"});});}; return resultPromise;}; this.prototype._applyHandler = function(request, handlerFunction, context) {return Promise.then(() => {request.addFilterLog(this, context); return handlerFunction.call(this, request);}).then((data) => !(data != null) ? request.missing() : (data instanceof RequestResponseBase) ? data : isJsonType(data) ? request.success({data}) : (() => {throw new ErrorWithInfo("invalid response data passed to RequestResponseBaseNext", {data});})(), (error) => {let status, base, base1, base2; return (Caf.exists(base = error.props) && (Caf.exists(base1 = base.response) && base1.isResponse)) ? error.props.response : isFailure(status = Caf.exists(base2 = error.info) && base2.status) ? request.toResponse(status, {error: error.info}) : request.failure({errorProps: {exception: error, source: {this: this, function: handlerFunction}}});});};});});});
//# sourceMappingURL=RequestHandler.js.map
