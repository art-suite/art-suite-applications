"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseObject", "PipelineRegistry", "Promise", "neq", "dashCase", "log", "RequestResponseBase", "isJsonType", "ErrorWithInfo", "isFailure"], [global, require('./StandardImport'), {RequestResponseBase: require('./RequestResponseBase'), PipelineRegistry: require('./PipelineRegistry')}], (BaseObject, PipelineRegistry, Promise, neq, dashCase, log, RequestResponseBase, isJsonType, ErrorWithInfo, isFailure) => {let RequestHandler; return RequestHandler = Caf.defClass(class RequestHandler extends BaseObject {}, function(RequestHandler, classSuper, instanceSuper) {this.abstractClass(); this.getter({pipelines: function() {return PipelineRegistry.pipelines;}}); this.prototype.applyHandler = function(request, handlerFunction, context) {let resultPromise; if (!handlerFunction) {return Promise.resolve(request);}; resultPromise = this._applyHandler(request, handlerFunction, context).then((response) => {let base; return (Caf.exists(response) && response.isFailure && !(Caf.exists(base = response.errorProps) && base.failedIn)) ? response.withMergedErrorProps({failedIn: {context, handler: this, response}}) : response;}); return request.verbose ? resultPromise.tap((result) => {let content; return (result !== request && neq(request.summary, result.summary)) ? (content = {[`ArtEryApplyHandlerVerbose ${Caf.toString(request.requestString)} - ${Caf.toString(dashCase(context))} ${Caf.toString(this.getLogName(this.type))}`]: {before: request.summary, after: result.summary}}, (result.failed && !request.failed) ? log.error(content) : log(content)) : log({[`ArtEryApplyHandlerVerbose ${Caf.toString(request.requestString)} - ${Caf.toString(dashCase(context))} ${Caf.toString(this.getLogName(this.type))}`]: "no-change"});}) : resultPromise;}; this.prototype._applyHandler = function(request, handlerFunction, context) {return Promise.then(() => {request.addFilterLog(this, context); return handlerFunction.call(this, request);}).then((data) => !(data != null) ? request.missing() : (data instanceof RequestResponseBase) ? data : isJsonType(data) ? request.success({data}) : (() => {throw new ErrorWithInfo("invalid response data passed to RequestResponseBaseNext", {data});})(), (error) => {let status, base, base1, base2; return (Caf.exists(base = error.props) && (Caf.exists(base1 = base.response) && base1.isResponse)) ? error.props.response : isFailure(status = Caf.exists(base2 = error.info) && base2.status) ? request.toResponse(status, {error: error.info}) : request.failure({errorProps: {exception: error, source: {this: this, function: handlerFunction}}});});};});});});
//# sourceMappingURL=RequestHandler.js.map
