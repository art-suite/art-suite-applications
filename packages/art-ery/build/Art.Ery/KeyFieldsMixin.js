// Generated by CoffeeScript 1.12.7
(function() {
  var Validator, array, defineModule, each, formattedInspect, isPlainArray, isPlainObject, isString, log, object, present, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ref = require('art-standard-lib'), defineModule = ref.defineModule, log = ref.log, present = ref.present, isPlainArray = ref.isPlainArray, isString = ref.isString, isPlainObject = ref.isPlainObject, formattedInspect = ref.formattedInspect, array = ref.array, object = ref.object, each = ref.each;

  Validator = require('art-validation').Validator;


  /*
  @primaryKey and @keyFields are synonymous
  Usage:
  
    class MyModel extends KeyFieldsMixin Pipeline # or FluxModel or whatever
       * 1 key
      @primaryKey "foo"
      @keyFields "foo"
      @keyFields ["foo"]
  
       * 2 keys
      @keyFields "foo/bar"
      @keyFields ["foo", "bar"]
  
       * 3 keys
      @keyFields "foo/bar/baz"   # compound key with 3 fields
      @keyFields ["foo", "bar', "baz"]
  
       * Default:
       * @keyFields "id"
  
  Note that order matters. @keyFields is a lists of strings. Forward slash (/) is
  used as a delimiter, so it shouldn't be in the names of your key-fields. Ideally
  each key field name should match: /[-._a-zA-Z0-9]+/
   */

  defineModule(module, function() {
    return function(superClass) {
      var KeyFieldsMixin;
      return KeyFieldsMixin = (function(superClass1) {
        var defaultKeyFieldsString, keyFields;

        extend(KeyFieldsMixin, superClass1);

        function KeyFieldsMixin() {
          return KeyFieldsMixin.__super__.constructor.apply(this, arguments);
        }

        KeyFieldsMixin.getKeyFields = function() {
          return this._keyFields;
        };

        KeyFieldsMixin.getKeyFieldsString = function() {
          return this._keyFieldsString;
        };

        KeyFieldsMixin.primaryKey = keyFields = function(a) {
          if (isString(a)) {
            return this._keyFields = (this._keyFieldsString = a).split("/");
          } else if (isPlainArray(a)) {
            return this._keyFieldsString = (this._keyFields = a).join("/");
          } else {
            throw new Error("invalid value: " + (formattedInspect(a)));
          }
        };

        KeyFieldsMixin.keyFields = keyFields;

        KeyFieldsMixin.getter({
          keyFieldsString: function() {
            return this._keyFieldsString != null ? this._keyFieldsString : this._keyFieldsString = this["class"]._keyFieldsString;
          },
          keyFields: function() {
            return this._keyFields != null ? this._keyFields : this._keyFields = this["class"]._keyFields;
          },
          keyValidator: function() {
            return this._keyValidator != null ? this._keyValidator : this._keyValidator = this["class"]._keyValidator;
          }
        });

        KeyFieldsMixin.prototype.allKeyFieldsPresent = function(data) {
          var j, keyField, len, ref1;
          ref1 = this.keyFields;
          for (j = 0, len = ref1.length; j < len; j++) {
            keyField = ref1[j];
            if (!present(data[keyField])) {
              return false;
            }
          }
          return true;
        };

        KeyFieldsMixin.prototype.isRecord = function(data) {
          return isPlainObject(data) && this.allKeyFieldsPresent(data);
        };

        KeyFieldsMixin.prototype.dataToKeyString = function(a) {
          this.validateKey(a);
          return array(this.keyFields, function(field) {
            return a[field];
          }).join("/");
        };

        KeyFieldsMixin.prototype.createPropsToKeyFunction = function(keyField) {
          var matches, propsField, propsIdField, recordType;
          if (keyField == null) {
            keyField = "id";
          }
          if (keyField === "id") {
            recordType = this.pipelineName;
            return function(props, stateField) {
              var propsField, ref1, ref2;
              propsField = stateField != null ? stateField : recordType;
              return (ref1 = (ref2 = props[propsField]) != null ? ref2.id : void 0) != null ? ref1 : props[propsField + "Id"];
            };
          } else if (matches = keyField.match(/^(.+)Id$/)) {
            propsIdField = matches[0], propsField = matches[1];
            return function(props) {
              var ref1, ref2;
              return (ref1 = (ref2 = props[propsField]) != null ? ref2.id : void 0) != null ? ref1 : props[propsIdField];
            };
          } else {
            return function(props) {
              return props[keyField];
            };
          }
        };

        KeyFieldsMixin.getter({
          propsToKey: function() {
            return this._propsToKey != null ? this._propsToKey : this._propsToKey = (function(_this) {
              return function() {
                var fMap;
                if (_this.keyFields.length === 1) {
                  return _this.createPropsToKeyFunction(_this.keyFields[0]);
                } else {
                  fMap = object(_this.keyFields, {
                    withKey: function(v) {
                      return v;
                    },
                    "with": function(v) {
                      return _this.createPropsToKeyFunction(v);
                    }
                  });
                  return function(props) {
                    return object(fMap, function(f) {
                      return f(props);
                    });
                  };
                }
              };
            })(this)();
          }
        });

        KeyFieldsMixin.prototype.toKeyObject = function(a) {
          var keyObject, keyValidator, obj, ref1, splitInput;
          ref1 = this, keyValidator = ref1.keyValidator, keyFields = ref1.keyFields;
          keyObject = this.validateKey(isPlainObject(a) ? object(this.keyFields, function(v) {
            return a[v];
          }) : isString(a) ? keyFields.length > 1 ? (splitInput = a.split("/"), keyObject = object(keyFields, function(v, i) {
            return splitInput[i];
          }), splitInput.length !== keyFields.length ? log.warn({
            KeyFieldsMixin_toKeyObject: {
              message: "wrong number of /-delimited fields in key-string",
              pipelineName: this.pipelineName,
              input: a,
              splitInput: splitInput,
              keyFields: keyFields,
              usingKeyObject: keyObject
            }
          }) : void 0, keyObject) : (
            obj = {},
            obj["" + keyFields[0]] = a,
            obj
          ) : {});
          if (keyValidator) {
            keyObject = keyValidator.preprocess(keyObject);
          }
          return keyObject;
        };

        KeyFieldsMixin.prototype.dataWithoutKeyFields = function(data) {
          return data && object(data, {
            when: (function(_this) {
              return function(v, k) {
                return !(indexOf.call(_this.keyFields, k) >= 0);
              };
            })(this)
          });
        };

        KeyFieldsMixin.prototype.validateKey = function(key) {
          keyFields = this.keyFields;
          each(keyFields, (function(_this) {
            return function(field) {
              if (!present(key[field])) {
                throw new Error((_this["class"].getName()) + " missing key field(s): " + (formattedInspect({
                  missing: field,
                  keyFields: keyFields,
                  key: key
                })));
              }
            };
          })(this));
          return key;
        };

        KeyFieldsMixin._keyFieldsString = defaultKeyFieldsString = "id";

        KeyFieldsMixin._keyFields = [defaultKeyFieldsString];

        KeyFieldsMixin._initFields = function() {
          var fields;
          KeyFieldsMixin.__super__.constructor._initFields.apply(this, arguments);
          fields = this.getFields();
          return this._keyValidator = new Validator(keyFields = object(this.getKeyFields(), {
            when: (function(_this) {
              return function(v) {
                return fields[v];
              };
            })(this),
            "with": (function(_this) {
              return function(v) {
                return fields[v];
              };
            })(this)
          }));
        };

        return KeyFieldsMixin;

      })(superClass);
    };
  });

}).call(this);

//# sourceMappingURL=KeyFieldsMixin.js.map
