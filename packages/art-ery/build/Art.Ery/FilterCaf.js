"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Validator", "merge", "Error"], [global, require('./StandardImport'), {Request: require('./Request'), Response: require('./Response')}], (Validator, merge, Error) => {let normalizeFields, Filter, FilterCaf; normalizeFields = Validator.normalizeFields; return Filter = FilterCaf = Caf.defClass(class FilterCaf extends require('./Filter') {constructor(options = {}) {let temp; super(...arguments); this.serverSideOnly = options.serverSideOnly; this.clientSideOnly = options.clientSideOnly; this.name = ((temp = options.name) != null ? temp : this.class.getName()); this.location = options.location; this.fields = options.fields; this.group = options.group; this.filterFailures = options.filterFailures; this.after = options.after; this.before = options.before;};}, function(FilterCaf, classSuper, instanceSuper) {let locationNames, locationPriorityBoost; this.extendableProperty({before: {}, after: {}}); this.extendableProperty({fields: {}}, {extend: function(oldFields, addFields) {return merge(oldFields, normalizeFields(addFields));}}); this.extendableProperty({filterFailures: false}); this.locationNames = locationNames = {server: true, client: true, both: true}; this.extendableProperty({location: "server"}, {extend: function(__, v) {if (!locationNames[v]) {throw new Error(`invalid location: ${Caf.toString(v)}`);}; return v;}}); this.groupNames = {loggers: 3, authorization: 2, outer: 1, middle: 0, inner: -1}; this.extendableProperty({group: this.groupNames.middle}, {extend: function(__, v) {let value; return (v != null) ? (!((value = Filter.groupNames[v]) != null) ? (() => {throw new Error(`invalid Filter group: ${Caf.toString(v)}`);})() : undefined, value) : 0;}}); locationPriorityBoost = {client: 2000, both: 0, server: 0}; this.getter({priority: function() {return this.group + locationPriorityBoost[this.location];}, logName: function() {return this.getName();}, props: function() {return {location: this.location};}, inspectedObjects: function() {return this.path.match(this.name) ? this.path : this.name;}}); this.property("name"); this.prototype.shouldFilter = function(processingLocation) {return (() => {switch (this.location) {case "server": return processingLocation !== "client"; case "client": return processingLocation !== "server"; case "both": return true; default: return (() => {throw new Error(`Filter ${Caf.toString(this.getName())}: invalid filter location: ${Caf.toString(this.location)}`);})();};})();}; this.prototype.toString = function() {return this.getName();}; this.prototype.getBeforeFilter = function({requestType, location}) {return this.shouldFilter(location) && (this.before[requestType] || this.before.all);}; this.prototype.getAfterFilter = function({requestType, location}) {return this.shouldFilter(location) && (this.after[requestType] || this.after.all);}; this.prototype.processBefore = function(request) {return this.applyHandler(request, this.getBeforeFilter(request), "beforeFilter");}; this.prototype.processAfter = function(request) {return this.applyHandler(request, this.getAfterFilter(request), "afterFilter");}; this.prototype.handleRequest = function(request, filterChain, currentFilterChainIndex) {return this.processBefore(request).then((request) => {let nextHandler, nextIndex; return request.isResponse ? request : ((nextHandler = filterChain[nextIndex = currentFilterChainIndex + 1]) ? nextHandler.handleRequest(request, filterChain, nextIndex) : request.failure(`INTERNAL-ERROR: no nextHandler in for request type: ${Caf.toString(request.type)}`)).then((response) => (response.isSuccessful || this.filterFailures) ? this.processAfter(response) : response);});};});});});
//# sourceMappingURL=FilterCaf.js.map
