"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["arrayWith", "isString", "currentSecond", "peek", "compactFlatten", "dashCase", "merge", "objectWithout", "objectKeyCount", "toInspectedObjects", "formattedInspect", "Error", "isPlainObject", "Promise", "config", "log", "networkFailure", "timeout", "Math", "success", "present", "missing", "getDetailedRequestTracingEnabled", "isFunction", "mergeWithoutNulls", "isArray", "isClientFailure", "isJsonType", "clientFailure", "clientFailureNotAuthorized", "failure"], [global, require('./StandardImport'), require('./Config')], (arrayWith, isString, currentSecond, peek, compactFlatten, dashCase, merge, objectWithout, objectKeyCount, toInspectedObjects, formattedInspect, Error, isPlainObject, Promise, config, log, networkFailure, timeout, Math, success, present, missing, getDetailedRequestTracingEnabled, isFunction, mergeWithoutNulls, isArray, isClientFailure, isJsonType, clientFailure, clientFailureNotAuthorized, failure) => {let ArtEry, RequestResponseBase; ArtEry = require("./namespace"); return RequestResponseBase = Caf.defClass(class RequestResponseBase extends require('./ArtEryBaseObject') {constructor(options) {let temp; super(...arguments); this._creationTime = currentSecond(); this.filterLog = options.filterLog; this.errorProps = options.errorProps; this.creationStack = options.creationStack; if (getDetailedRequestTracingEnabled()) {((temp = this._creationStack) != null ? temp : this._creationStack = (new Error).stack);};};}, function(RequestResponseBase, classSuper, instanceSuper) {let cachedGet, createRequirementNotMetRequestProps, resolveRequireTestValue, defaultWhenTest; this.property("filterLog", "errorProps", "creationTime", "creationStack"); this.prototype.addFilterLog = function(filter, context) {let base, base1; this._filterLog = arrayWith(this._filterLog, {name: isString(filter) ? filter : filter.getLogName(this.type), context, time: currentSecond(), stack: Caf.exists(base = this.originalRequest) && base.creationStack, exception: Caf.exists(base1 = this.errorProps) && base1.exception}); return this;}; this.prototype.isUpdateRequest = function() {return this.pipeline.isUpdateRequestType(this.type);}; this.prototype.isDeleteRequest = function() {return this.pipeline.isDeleteRequestType(this.type);}; this.getter({lastFilterLogEntry: function() {let temp, base; return ((temp = peek(this.filterLog)) != null ? temp : Caf.exists(base = this.request) && base.lastFilterLogEntry);}, requestTrace: function() {let name, context, time, stack, exception, temp, base; if (Caf.exists(temp = this.lastFilterLogEntry)) {name = temp.name; context = temp.context; time = temp.time; stack = temp.stack; exception = temp.exception;}; return compactFlatten([Caf.exists(base = this.parentRequest) && base.requestTrace, {time: time - this.startTime, request: this.requestString, context: dashCase(context), filterLog: compactFlatten([this.beforeFilterLog, this.afterFilterLog]), name, stack, exception}]);}, verbose: function() {let base, base1; return this._verbose || Caf.exists(base = this.originalRequest) && base._verbose || Caf.exists(base1 = this.rootRequest) && base1._verbose;}, location: function() {return this.pipeline.location;}, requestType: function() {return this.type;}, pipelineName: function() {return this.pipeline.getName();}, requestDataWithKey: function() {return merge(this.requestData, this.keyObject);}, keyObject: function() {return this.request.pipeline.toKeyObject(this.key);}, rootRequest: function() {let temp, base; return ((temp = Caf.exists(base = this.parentRequest) && base.rootRequest) != null ? temp : this.request);}, originalRequest: function() {let temp; return ((temp = this._originalRequest) != null ? temp : this.request.originalRequest);}, startTime: function() {return this.rootRequest.creationTime;}, endTime: function() {return this.creationTime;}, wallTime: function() {return this.startTime - this.endTime;}, requestChain: function() {let base; return compactFlatten([this.isResponse ? this.request.requestChain : Caf.exists(base = this.parentRequest) && base.requestChain, this]);}, simpleInspectedObjects: function() {let props, raw; props = objectWithout(this.props, "key", "data"); if (!(0 < objectKeyCount(props))) {props = null;}; raw = {[`${Caf.toString(this.class.name)}`]: this.requestString, originatedOnServer: this.originatedOnServer, data: this.data, status: this.status, props, errorProps: this.errorProps}; return toInspectedObjects(Caf.object(raw, null, (v) => v != null));}, inspectedObjects: function() {return {[`Art.Ery.${Caf.toString(this.class.name)}`]: Caf.array(this.requestChain, (request) => request.simpleInspectedObjects)};}}); this.getter({isSuccessful: function() {return true;}, isFailure: function() {return this.notSuccessful;}, notSuccessful: function() {return false;}, requestSession: function() {return this.request.session;}, requestProps: function() {return this.request.requestProps;}, requestData: function() {return this.request.requestData;}, isRootRequest: function() {return this.request.isRootRequest;}, key: function() {let temp, base; return ((temp = this.request.key) != null ? temp : Caf.exists(base = this.responseData) && base.id);}, pipeline: function() {return this.request.pipeline;}, parentRequest: function() {return this.request.parentRequest;}, isSubrequest: function() {return !!this.request.parentRequest;}, type: function() {return this.request.type;}, originatedOnServer: function() {return this.request.originatedOnServer;}, context: function() {return this.request.context;}, pipelineAndType: function() {return `${Caf.toString(this.pipelineName)}.${Caf.toString(this.type)}`;}, requestString: function() {return this.key ? this.pipelineAndType + ` ${Caf.toString(formattedInspect(this.key))}` : this.pipelineAndType;}, description: function() {return this.requestString;}, requestPathArray: function(_into) {let localInto, base; localInto = _into != null ? _into : []; Caf.exists(base = this.parentRequest) && base.getRequestPathArray(localInto); localInto.push(this); return localInto;}, requestPath: function() {return Caf.array(this.requestPathArray, (r) => r.requestString).join(" >> ");}}); this.prototype.toStringCore = function() {return `ArtEry.${Caf.toString(this.isResponse ? "Response" : "Request")} ${Caf.toString(this.pipelineName)}.${Caf.toString(this.type)}${Caf.toString(this.key ? ` key: ${Caf.toString(this.key)}` : "")}`;}; this.prototype.toString = function() {return `<${Caf.toString(this.toStringCore())}>`;}; this.getter({requestCache: function() {let temp, base; return ((temp = (base = this.context).requestCache) != null ? temp : base.requestCache = {});}, subrequestCount: function() {let temp, base; return ((temp = (base = this.context).subrequestCount) != null ? temp : base.subrequestCount = 0);}}); this.setter({responseProps: function() {return (() => {throw new Error("cannot set responseProps");})();}}); this.prototype.incrementSubrequestCount = function() {return this.context.subrequestCount = (this.context.subrequestCount | 0) + 1;}; this.prototype.createSubRequest = function(pipelineName, type, requestOptions) {let pipeline, temp; if (requestOptions && !isPlainObject(requestOptions)) {throw new Error("requestOptions must be an object");}; pipeline = ArtEry.pipelines[pipelineName]; if (!pipeline) {throw new Error(`Pipeline not registered: ${Caf.toString(formattedInspect(pipelineName))}`);}; return new (ArtEry.Request)(merge({originatedOnServer: ((temp = Caf.exists(requestOptions) && requestOptions.originatedOnServer) != null ? temp : true)}, requestOptions, {type, pipeline, verbose: this.verbose, session: Caf.exists(requestOptions) && requestOptions.session || this.session, parentRequest: this.request, context: this.context}));}; this.prototype.subrequest = function(pipelineOrPipelineName, type, requestOptionsOrKey, requestOptionsAfterKey) {let requestOptions, subrequest, pipelineName, temp; requestOptions = isString(requestOptionsOrKey) ? merge(requestOptionsAfterKey, {key: requestOptionsOrKey}) : requestOptionsOrKey; subrequest = this.createSubRequest(pipelineName = ((temp = pipelineOrPipelineName.pipelineName) != null ? temp : pipelineOrPipelineName), type, requestOptions); this.incrementSubrequestCount(); return subrequest.pipeline._processRequest(subrequest).then((response) => response.toPromise(requestOptions));}; this.prototype.nonblockingSubrequest = function(pipelineName, type, requestOptions) {this.subrequest(pipelineName, type, requestOptions).then((result) => config.verbose ? log({ArtEry: {RequestResponseBase: {nonblockingSubrequest: {status: "success", pipelineName, type, requestOptions, parentRequest: {pipelineName: this.pipelineName, type: this.type, key: this.key}, result}}}}) : undefined).catch((error) => log({ArtEry: {RequestResponseBase: {nonblockingSubrequest: {status: "failure", pipelineName, type, requestOptions, parentRequest: {pipelineName: this.pipelineName, type: this.type, key: this.key}, error}}}})); return Promise.resolve();}; this.prototype._getPipelineTypeCache = function(pipelineName, type) {let temp, base, temp1, base1; return ((temp = (base = ((temp1 = (base1 = this.requestCache)[pipelineName]) != null ? temp1 : base1[pipelineName] = {}))[type]) != null ? temp : base[type] = {});}; this.prototype.cachedSubrequest = function(pipelineName, requestType, keyOrRequestProps, d) {if (d !== undefined) {throw new Error("DEPRICATED: 4-param cachedSubrequest");}; return this._cachedSubrequest(pipelineName, requestType, requestType, keyOrRequestProps);}; this.prototype._cachedSubrequest = function(pipelineName, cacheType, requestType, keyOrRequestProps) {let key, temp, base; key = isString(keyOrRequestProps) ? keyOrRequestProps : keyOrRequestProps.key; if (!isString(key)) {throw new Error(`_cachedSubrequest: key must be a string (${Caf.toString(formattedInspect({key}))})`);}; return ((temp = (base = this._getPipelineTypeCache(pipelineName, cacheType))[key]) != null ? temp : base[key] = this.subrequest(pipelineName, requestType, keyOrRequestProps).catch((error) => (error.status === networkFailure && requestType === "get") ? timeout(20 + 10 * Math.random()).then(() => this.subrequest(pipelineName, requestType, keyOrRequestProps)) : (() => {throw error;})()));}; this.prototype.setGetCache = function() {return (this.status === success && present(this.key) && this.responseData != null) ? this._getPipelineTypeCache(this.pipelineName, "get")[this.key] = Promise.then(() => this.responseData) : undefined;}; this.prototype.cachedGet = cachedGet = function(pipelineName, key) {if (isPlainObject(key)) {key = ArtEry.pipelines[pipelineName].dataToKeyString(key);}; if (!isString(key)) {throw new Error(`cachedGet: key must be a string OR object when pipeline supports dataToKeyString (${Caf.toString(formattedInspect({key}))})`);}; return this.cachedSubrequest(pipelineName, "get", key);}; this.prototype.cachedGetWithoutInclude = function(pipelineName, key) {let temp; if (!isString(key)) {throw new Error(`cachedGetWithoutInclude: key must be a string (${Caf.toString(formattedInspect({key}))})`);}; return ((temp = this._getPipelineTypeCache(pipelineName, "get")[key]) != null ? temp : this._cachedSubrequest(pipelineName, "get-no-include", "get", {key, props: {include: false}}));}; this.prototype.cachedPipelineGet = cachedGet; this.prototype.cachedGetIfExists = function(pipelineName, key) {if (!(key != null)) {return Promise.resolve(null);}; return this.cachedGet(pipelineName, key).catch((error) => (error.status === missing) ? Promise.resolve(null) : (() => {throw error;})());}; createRequirementNotMetRequestProps = function(pipelineAndType, errors, stackException) {let data; return {data: data = {details: compactFlatten([pipelineAndType, "requirement not met", errors]).join(" - "), message: "Request requirement not met: " + compactFlatten([errors]).join(" - ")}, errorProps: getDetailedRequestTracingEnabled() ? {exception: stackException != null ? stackException : new Error(data.message)} : undefined};}; this.prototype.rejectIfErrors = function(errors, stackException) {return errors ? this.clientFailure(createRequirementNotMetRequestProps(this.pipelineAndType, errors, stackException)).then((response) => response.toPromise()) : Promise.resolve(this);}; this.prototype.rejectNotAuthorizedIfErrors = function(errors) {return errors ? this.clientFailureNotAuthorized(createRequirementNotMetRequestProps(this.pipelineAndType, errors)).then((response) => response.toPromise()) : Promise.resolve(this);}; this._resolveRequireTestValue = resolveRequireTestValue = function(testValue) {if (isFunction(testValue)) {testValue = testValue();}; return Promise.resolve(testValue);}; this.prototype.require = function(test, context) {let stackException; if (getDetailedRequestTracingEnabled()) {stackException = new Error(context);}; return resolveRequireTestValue(test).then((test) => this.rejectIfErrors(!test ? context != null ? context : [] : undefined, stackException));}; this.prototype.requiredFields = function(fields, context) {let missingFields; missingFields = null; Caf.each2(fields, (v, k) => (missingFields != null ? missingFields : missingFields = []).push(k), (v, k) => !(v != null)); return this.rejectIfErrors(missingFields ? ["missing fields: " + missingFields.join(", "), context] : undefined).then(() => fields);}; this.prototype.rejectIf = function(testValue, context) {return resolveRequireTestValue(testValue).then((testValue) => this.require(!testValue, context));}; this.prototype.requireServerOrigin = function(context) {return this.requireServerOriginOr(false, context);}; this.prototype.requireServerOriginOr = function(testValue, context) {if (this.originatedOnServer) {return Promise.resolve(this);}; return resolveRequireTestValue(testValue).then((testValue) => this.rejectNotAuthorizedIfErrors(!testValue ? "originatedOnServer required " + ((Caf.exists(context) && context.match(/\s*to\s/)) ? context : context ? `to ${Caf.toString(context)}` : "") : undefined));}; this.prototype.requireServerOriginIf = function(testValue, context) {if (this.originatedOnServer) {return Promise.resolve(this);}; return resolveRequireTestValue(testValue).then((testValue) => this.requireServerOriginOr(!testValue, context));}; this.prototype.with = function(constructorOptions) {return Promise.resolve(constructorOptions).then((constructorOptions) => this._with(constructorOptions));}; this.prototype._with = function(o) {return new this.class(merge(this.propsForClone, o));}; this.prototype.withData = function(data) {return Promise.resolve(data).then((data) => this._with({data}));}; this.prototype.withMergedData = function(data) {return Promise.resolve(data).then((data) => this._with({data: merge(this.data, data)}));}; this.prototype.withKey = function(data) {return Promise.resolve(data).then((key) => this._with({key}));}; this.prototype.withProps = function(props) {return Promise.resolve(props).then((props) => this._with({props, key: props.key, data: props.data}));}; this.prototype.withMergedProps = function(props) {return Promise.resolve(props).then((props) => this._with({key: props.key, data: props.data, props: merge(this.props, props)}));}; this.prototype.withMergedPropsWithoutNulls = function(props) {return Promise.resolve(props).then((props) => this._with({key: props.key, data: props.data, props: mergeWithoutNulls(this.props, props)}));}; this.prototype.withMergedErrorProps = function(errorProps) {return Promise.resolve(errorProps).then((errorProps) => this._with({errorProps: merge(this.errorProps, errorProps)}));}; this.prototype.withSession = function(session) {return Promise.resolve(session).then((session) => this._with({session}));}; this.prototype.withMergedSession = function(session) {return Promise.resolve(session).then((session) => this._with({session: merge(this.session, session)}));}; this.prototype.respondWithSession = function(session) {return this.success({session});}; this.prototype.respondWithMergedSession = function(session) {return this.success({session: merge(this.session, session)});}; defaultWhenTest = function(data, request) {return request.pipeline.isRecord(data);}; this.prototype.withTransformedRecords = function(withFunction, whenFunction = defaultWhenTest) {let options, firstFailure, transformedRecords, temp; if (isPlainObject(options = withFunction)) {withFunction = options.with; whenFunction = ((temp = options.when) != null ? temp : defaultWhenTest);}; return isPlainObject(this.data) ? Promise.resolve(whenFunction(this.data, this) ? this.next(withFunction(this.data, this)) : this) : isArray(this.data) ? (firstFailure = null, transformedRecords = Caf.array(this.data, (record) => Promise.then(() => whenFunction(record, this) ? withFunction(record, this) : record).catch((error) => {let response, base; return (() => {switch (false) {case !(error.status === "missing"): return null; case !(response = Caf.exists(error) && (Caf.exists(base = error.props) && base.response)): return response; default: return (() => {throw error;})();};})();}).then((out) => (Caf.exists(out) && out.status && out instanceof RequestResponseBase) ? isClientFailure(out.status) ? (Caf.isF(out._clearErrorStack) && out._clearErrorStack(), null) : firstFailure != null ? firstFailure : firstFailure = out : out)), Promise.all(transformedRecords).then((records) => firstFailure != null ? firstFailure : this.withData(compactFlatten(records)))) : Promise.resolve(this);}; this.prototype.next = function(data) {return Promise.resolve(data).then((data) => {if (data instanceof RequestResponseBase) {return data;}; return (() => {switch (false) {case !(!(data != null)): return this.missing(); case !isJsonType(data): return this.success({data}); default: log.error({invalidXYZ: data}); return (() => {throw new Error("invalid response data passed to RequestResponseBaseNext");})();};})();}, (error) => {let base, base1; return (Caf.exists(base = error.props) && (Caf.exists(base1 = base.response) && base1.isResponse)) ? error.props.response : this.failure({error});});}; this.prototype.success = function(responseProps) {return this.toResponse(success, responseProps);}; this.prototype.missing = function(responseProps) {return this.toResponse(missing, responseProps);}; this.prototype.clientFailure = function(responseProps) {return this.toResponse(clientFailure, responseProps);}; this.prototype.clientFailureNotAuthorized = function(responseProps) {return this.toResponse(clientFailureNotAuthorized, responseProps);}; this.prototype.failure = function(responseProps) {return this.toResponse(failure, responseProps);}; this.prototype.rejectWithMissing = function(responseProps) {return this.toResponse(missing, responseProps, true);}; this.prototype.rejectWithClientFailure = function(responseProps) {return this.toResponse(clientFailure, responseProps, true);}; this.prototype.rejectWithClientFailureNotAuthorized = function(responseProps) {return this.toResponse(clientFailureNotAuthorized, responseProps, true);}; this.prototype.rejectWithFailure = function(responseProps) {return this.toResponse(failure, responseProps, true);}; this.prototype.toResponse = function(status, responseProps, returnRejectedPromiseOnFailure = false) {if (!isString(status)) {throw new Error("missing status");}; return Promise.resolve(responseProps).then((responseProps = {}) => (() => {switch (false) {case !(responseProps instanceof RequestResponseBase): log.warn("DEPRICATED: toResponse is instanceof RequestResponseBase"); return responseProps; case !isPlainObject(responseProps): return new (ArtEry.Response)(merge(this.propsForResponse, responseProps, {status, request: this.request})); case !isString(responseProps): return this.toResponse(status, {data: {message: responseProps}}); default: return this.toResponse(failure, this._toErrorResponseProps(responseProps));};})()).then((response) => returnRejectedPromiseOnFailure ? response.toPromise() : response);}; this.prototype._toErrorResponseProps = function(responseProps) {return log(this, {responseProps}, {data: {message: (responseProps instanceof Error) ? `Internal Error: ArtEry.RequestResponseBase#toResponse received Error instance: ${Caf.toString(formattedInspect(responseProps))}` : "Internal Error: ArtEry.RequestResponseBase#toResponse received unsupported type"}});};});});});
//# sourceMappingURL=RequestResponseBase.js.map
