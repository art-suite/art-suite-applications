"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Pipeline", "Error", "timeout"], [global, require('./StandardImport')], (Pipeline, Error, timeout) => {let signSession, MyRemote, temp; if (Caf.exists(temp = require('../../Art.Ery').Server)) {signSession = temp.signSession;}; return MyRemote = Caf.defClass(class MyRemote extends Pipeline {}, function(MyRemote, classSuper, instanceSuper) {this.remoteServer("http://localhost:8085"); this.publicRequestTypes("get", "getSessionData", "handledByFilterRequest", "handlerClientFailure", "hello", "manuallySignSession", "preAlterSession", "privateRequestOkAsSubRequest", "requestHost", "returnFalse", "setSessionA", "setSessionB", "setSessionData", "simulateClientFailure", "simulateMissing", "simulatePropsInput", "simulatePropsOutput", "simulateServerFailure", "slowSetSessionA"); this.filter({name: "handleByFilter", before: {handledByFilterRequest: function(request) {return request.success();}}}); this.filter({name: "FakeTimestampFilter", after: {all: function(response) {let type; type = response.type; return (type === "create" || type === "update") ? response.withMergedData({updatedAt: 123456789, createdAt: (type === "create") ? 123456789 : undefined}) : response;}}}); this.filter({before: {filterClientFailure: function(request) {return request.require(false, "filter allways fails");}}}); this.filter({before: {preAlterSession: function(request) {return request.withMergedSession({sessionWasPreAltered: true});}}}); this.handlers({get: function({key, data}) {return `${Caf.toString(Caf.exists(data) && data.greeting || "Hello")} ${Caf.toString(key || "World")}!`;}, getSessionData: function({session}) {return session;}, handledByFilterRequest: function() {}, handlerClientFailure: function(request) {return request.require(false, "handler allways fails");}, hello: function({session}) {return `Hello, ${Caf.toString(session.username)}!`;}, manuallySignSession: function(request) {return signSession(request.session).then((signature) => {return {signature};});}, myPrivateRequestType: function(request) {return request.requireServerOrigin().then(() => "myPrivateRequestType success");}, preAlterSession: function() {return true;}, privateRequestOkAsSubRequest: function(request) {return request.subrequest(request.pipeline, "myPrivateRequestType");}, requestHost: function(request) {return request.remoteRequest.hostname;}, returnFalse: function() {return false;}, setSessionA: function(request) {return request.respondWithMergedSession({sessionA: true});}, setSessionB: function(request) {return request.respondWithMergedSession({sessionB: true});}, setSessionData: function(request) {return request.respondWithSession(request.data);}, simulateClientFailure: function(request) {return request.clientFailure();}, simulateMissing: function(request) {return request.missing();}, simulatePropsInput: function(request) {return request.props;}, simulatePropsOutput: function(request) {return request.success({props: {myExtras: true}});}, simulateServerFailure: function() {return (() => {throw new Error("Boom!");})();}, slowSetSessionA: function(request) {return timeout(250).then(() => request.respondWithMergedSession({sessionA: true}));}});});});});
//# sourceMappingURL=MyRemote.js.map
