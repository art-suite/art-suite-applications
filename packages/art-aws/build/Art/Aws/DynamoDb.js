// Generated by CoffeeScript 1.12.7

/*
Local Web Console / Shell: http://localhost:8081/shell/

The AWS DynamoDb API is redundent and uses UpperCamelCase names all over.

Goals:
  create a wrapper API which:

  - elliminates redundencies
  - uses lowerCamelCase key names for JavaScript naming convention compatibility.

Strategy:
  Incremental. Not all commands will be updated to the "new" api.
  Instead, the API will always accept the unfiltered DynamoDb API with UpperCamelCase names.
  As I can, I'll create a lowerCamelCase API for each commant.

lowerCamelCase API:

METHODS
  createTable
    attributes:     # see translateAttributes
    key:            # see translateKey
    provisioning:   # see translateProvisioning
    globalIndexes:  # see
    localIndexes:

HELPERS
  translateAttributes
    attributes:
      myHashKeyName:    'string'
      myRangeKeyName:   'string'
      myNumberAttrName: 'number'
      myBinaryAttrName: 'binary'

  translateKey
    key:
      myHashKeyName:  'hash'
      myRangeKeyName: 'range'

      OR: "hashKeyField"
      OR: "hashKeyField/rangeKeyField"
        NOTE: you can use any string format that matches /[_a-zA-Z0-9]+/g

  translateProvisioning
    provisioning:
      read: 5
      write: 5

  translateGlobalIndexes
    globalIndexes:
      myIndexName:
        "hashKey"           # see translateKey
        "hashKey/rangeKey"  # see translateKey

        OR

        key:          # see translateKey
        projection:   # see translateProjection
        provisioning: # see translateProvisioning

  translateLocalIndexes
    localIndexes:
      myIndexName:
        "hashKey"           # see translateKey
        "hashKey/rangeKey"  # see translateKey

        OR

        key:          # see translateKey
        projection:   # see translateProjection
 */

(function() {
  var BaseClass, BatchGetItem, Config, CreateTable, DeleteItem, DynamoDb, GetItem, Promise, PutItem, Query, Scan, StreamlinedDynamoDbApi, TableApiBaseClass, UpdateItem, array, capitalize, config, decapitalize, decodeDynamoItem, diff, each, eq, formattedInspect, inspect, isBoolean, isNumber, isPlainArray, isPlainObject, isString, log, lowerCamelCase, merge, object, objectDiff, objectDiffReport, objectHasKeys, objectKeyCount, ref, wordsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('art-standard-lib'), merge = ref.merge, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray, isBoolean = ref.isBoolean, isString = ref.isString, isNumber = ref.isNumber, inspect = ref.inspect, capitalize = ref.capitalize, decapitalize = ref.decapitalize, lowerCamelCase = ref.lowerCamelCase, wordsArray = ref.wordsArray, array = ref.array, log = ref.log, eq = ref.eq, formattedInspect = ref.formattedInspect, objectHasKeys = ref.objectHasKeys, Promise = ref.Promise, objectDiff = ref.objectDiff, objectDiffReport = ref.objectDiffReport, object = ref.object, diff = ref.diff, objectKeyCount = ref.objectKeyCount, each = ref.each;

  BaseClass = require('art-class-system').BaseClass;

  config = (Config = require("./Config")).config;

  StreamlinedDynamoDbApi = require('./StreamlinedDynamoDbApi');

  Scan = StreamlinedDynamoDbApi.Scan, Query = StreamlinedDynamoDbApi.Query, CreateTable = StreamlinedDynamoDbApi.CreateTable, PutItem = StreamlinedDynamoDbApi.PutItem, UpdateItem = StreamlinedDynamoDbApi.UpdateItem, DeleteItem = StreamlinedDynamoDbApi.DeleteItem, GetItem = StreamlinedDynamoDbApi.GetItem, TableApiBaseClass = StreamlinedDynamoDbApi.TableApiBaseClass, BatchGetItem = StreamlinedDynamoDbApi.BatchGetItem;

  decodeDynamoItem = TableApiBaseClass.decodeDynamoItem;

  module.exports = DynamoDb = (function(superClass) {
    var nonInternalErrorsRegex;

    extend(DynamoDb, superClass);

    DynamoDb.singletonClass();

    function DynamoDb(options) {
      if (options == null) {
        options = {};
      }
      this._awsDynamoDb = new AWS.DynamoDB(merge(Config.getNormalizedConfig("dynamoDb", options)));
    }

    nonInternalErrorsRegex = /ConditionalCheckFailedException|ResourceNotFoundException/;

    DynamoDb.prototype.invokeAws = function(name, params) {
      return Promise.withCallback((function(_this) {
        return function(callback) {
          return _this._awsDynamoDb[name](params, callback);
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          if (config.verbose || !nonInternalErrorsRegex.test(error.message)) {
            log.error({
              "Art.Aws.DynamoDb": {
                method: name,
                status: "request was rejected",
                message: error.message,
                verbose: config.verbose,
                params: params,
                error: error
              }
            });
          }
          throw error;
        };
      })(this));
    };

    DynamoDb.bindAll = function(map) {
      var customMethod, name, results;
      results = [];
      for (name in map) {
        customMethod = map[name];
        results.push((function(_this) {
          return function(name, customMethod) {
            return _this.prototype[name] = customMethod || function(params) {
              return this.invokeAws(name, params);
            };
          };
        })(this)(name, customMethod));
      }
      return results;
    };

    DynamoDb.bindAll({
      createTable: function(params) {
        var e;
        try {
          return this.invokeAws("createTable", CreateTable.translateParams(merge({
            attributes: {
              id: 'string'
            },
            key: {
              id: 'hash'
            }
          }, params)));
        } catch (error1) {
          e = error1;
          log({
            createTableInputParams: params
          });
          throw e;
        }
      },
      createNewGlobalSecondaryIndexes: function(createTableParams) {
        var TableName;
        TableName = TableApiBaseClass.translateParams(createTableParams).TableName;
        return Promise.all([this.getTableChanges(createTableParams), this.getTableStatus(createTableParams)]).then((function(_this) {
          return function(arg) {
            var AttributeDefinitions, AttributeDefinitionsByName, GlobalSecondaryIndexUpdates, GlobalSecondaryIndexes, TableStatus, added, normalizedGsisByName, ref1, ref2, ref3, requiredAttributes;
            (ref1 = arg[0], GlobalSecondaryIndexes = ref1.GlobalSecondaryIndexes), (ref2 = arg[1], TableStatus = ref2.TableStatus);
            if (GlobalSecondaryIndexes) {
              added = GlobalSecondaryIndexes.added;
            }
            if (!(0 < objectKeyCount(added))) {
              return {
                info: "no new GlobalSecondaryIndexes"
              };
            }
            if (TableStatus !== "ACTIVE") {
              return {
                info: "Can't modify indexes until TableStatus is ACTIVE"
              };
            }
            ref3 = CreateTable.translateParams(createTableParams), GlobalSecondaryIndexes = ref3.GlobalSecondaryIndexes, TableName = ref3.TableName, AttributeDefinitions = ref3.AttributeDefinitions;
            normalizedGsisByName = object(GlobalSecondaryIndexes, {
              key: function(index) {
                return index.IndexName;
              }
            });
            requiredAttributes = {};
            AttributeDefinitionsByName = object(AttributeDefinitions, {
              key: function(arg1) {
                var AttributeName;
                AttributeName = arg1.AttributeName;
                return AttributeName;
              }
            });
            GlobalSecondaryIndexUpdates = array(added, function(arg1) {
              var IndexName, KeySchema;
              KeySchema = arg1.KeySchema, IndexName = arg1.IndexName;
              each(KeySchema, function(arg2) {
                var AttributeName;
                AttributeName = arg2.AttributeName;
                return requiredAttributes[AttributeName] = true;
              });
              return {
                Create: normalizedGsisByName[IndexName]
              };
            });
            AttributeDefinitions = array(requiredAttributes, function(truth, key) {
              return AttributeDefinitionsByName[key];
            });
            return _this.invokeAws("updateTable", {
              TableName: TableName,
              GlobalSecondaryIndexUpdates: GlobalSecondaryIndexUpdates,
              AttributeDefinitions: AttributeDefinitions
            }).then(function(info) {
              return {
                creating: added,
                info: info
              };
            });
          };
        })(this)).then((function(_this) {
          return function(out) {
            return _this.getTableStatus(createTableParams).then(function(status) {
              return merge(out, {
                status: status
              });
            });
          };
        })(this));
      },
      deleteOldGlobalSecondaryIndexes: function(createTableParams) {
        var TableName;
        TableName = TableApiBaseClass.translateParams(createTableParams).TableName;
        return Promise.all([this.getTableChanges(createTableParams), this.getTableStatus(createTableParams)]).then((function(_this) {
          return function(arg) {
            var GlobalSecondaryIndexUpdates, GlobalSecondaryIndexes, TableStatus, ref1, ref2, removed;
            (ref1 = arg[0], GlobalSecondaryIndexes = ref1.GlobalSecondaryIndexes), (ref2 = arg[1], TableStatus = ref2.TableStatus);
            if (GlobalSecondaryIndexes) {
              removed = GlobalSecondaryIndexes.removed;
            }
            if (!(0 < objectKeyCount(removed))) {
              return {
                info: "no old GlobalSecondaryIndexes"
              };
            }
            if (TableStatus !== "ACTIVE") {
              return {
                info: "Can't modify indexes until TableStatus is ACTIVE"
              };
            }
            GlobalSecondaryIndexUpdates = array(removed, function(arg1) {
              var IndexName;
              IndexName = arg1.IndexName;
              return {
                Delete: {
                  IndexName: IndexName
                }
              };
            });
            return _this.invokeAws("updateTable", {
              TableName: TableName,
              GlobalSecondaryIndexUpdates: GlobalSecondaryIndexUpdates
            }).then(function(info) {
              return {
                deleting: removed,
                info: info
              };
            });
          };
        })(this)).then((function(_this) {
          return function(out) {
            return _this.getTableStatus(createTableParams).then(function(status) {
              return merge(out, {
                status: status
              });
            });
          };
        })(this));
      },

      /*
      IN: see Query.translateQueryParams
      OUT:
        DynamoDb standard output AND
        Same output with lowerCamelCase names:
          items: Items
          count: Count
          scannedCount: ScannedCount
          lastEvaluatedKey: LastEvaluatedKey
          consumedCapacity: ConsumedCapacity
       */
      query: function(params) {
        return this.invokeAws("query", Query.translateParams(params)).then(function(res) {
          var ConsumedCapacity, Count, Items, LastEvaluatedKey, ScannedCount, item;
          Items = res.Items, Count = res.Count, ScannedCount = res.ScannedCount, LastEvaluatedKey = res.LastEvaluatedKey, ConsumedCapacity = res.ConsumedCapacity;
          return merge(res, {
            items: (function() {
              var i, len, results;
              results = [];
              for (i = 0, len = Items.length; i < len; i++) {
                item = Items[i];
                results.push(decodeDynamoItem(item));
              }
              return results;
            })(),
            count: Count,
            scannedCount: ScannedCount,
            lastEvaluatedKey: LastEvaluatedKey,
            consumedCapacity: ConsumedCapacity
          });
        });
      },
      putItem: function(params) {
        return this.invokeAws("putItem", PutItem.translateParams(params)).then(function(res) {
          return merge(res, {
            item: decodeDynamoItem(res.Attributes)
          });
        });
      },
      deleteItem: function(params) {
        return this.invokeAws("deleteItem", params = DeleteItem.translateParams(params)).then(function(res) {
          return merge(res, {
            item: decodeDynamoItem(res.Attributes)
          });
        });
      },
      getItem: function(params) {
        return this.invokeAws("getItem", GetItem.translateParams(params)).then(function(res) {
          return {
            item: res.Item && decodeDynamoItem(res.Item)
          };
        });
      },
      batchGetItem: function(params) {
        return this.invokeAws("batchGetItem", BatchGetItem.translateParams(params)).then(function(result) {
          var table, tableName, v;
          table = params.table, tableName = params.tableName;
          return {
            items: (function() {
              var i, len, ref1, results;
              ref1 = result.Responses[table != null ? table : tableName];
              results = [];
              for (i = 0, len = ref1.length; i < len; i++) {
                v = ref1[i];
                results.push(decodeDynamoItem(v));
              }
              return results;
            })()
          };
        });
      },
      updateItem: function(params) {
        return this.invokeAws("updateItem", UpdateItem.translateParams(params)).then(function(res) {
          return merge(res, {
            item: decodeDynamoItem(res.Attributes)
          });
        });
      },
      describeTable: function(params) {
        return this.invokeAws("describeTable", TableApiBaseClass.translateParams(params));
      },
      deleteTable: function(params) {
        return this.invokeAws("deleteTable", TableApiBaseClass.translateParams(params));
      },
      waitFor: function(params) {
        return this.invokeAws("waitFor", TableApiBaseClass.translateParams(params));
      },
      getTableChanges: function(newCreateTableParams) {
        var TableName, compareAttribues, compareIndexes;
        TableName = TableApiBaseClass.translateParams(newCreateTableParams).TableName;
        compareIndexes = function(newIndexes, currentIndexes) {
          var toByName;
          toByName = function(indexes) {
            return object(indexes, {
              key: function(index) {
                return index.IndexName;
              },
              "with": function(index) {
                var IndexName, KeySchema, Projection;
                IndexName = index.IndexName, KeySchema = index.KeySchema, Projection = index.Projection;
                return {
                  IndexName: IndexName,
                  KeySchema: KeySchema,
                  Projection: Projection
                };
              }
            });
          };
          return objectDiffReport(toByName(newIndexes), toByName(currentIndexes), eq);
        };
        compareAttribues = function(newAttrs, currentAttrs) {
          var toByName;
          toByName = function(indexes) {
            return object(indexes, {
              key: function(index) {
                return index.AttributeName;
              }
            });
          };
          return objectDiffReport(toByName(newAttrs), toByName(currentAttrs), eq);
        };
        return this.describeTable({
          TableName: TableName
        }).then(function(currentTableDescription) {
          var GlobalSecondaryIndexes, KeySchema, LocalSecondaryIndexes, TableStatus, count, out, ref1;
          ref1 = currentTableDescription.Table, KeySchema = ref1.KeySchema, GlobalSecondaryIndexes = ref1.GlobalSecondaryIndexes, LocalSecondaryIndexes = ref1.LocalSecondaryIndexes, TableStatus = ref1.TableStatus;
          out = {
            KeySchema: compareAttribues(newCreateTableParams.KeySchema, KeySchema),
            GlobalSecondaryIndexes: compareIndexes(newCreateTableParams.GlobalSecondaryIndexes, GlobalSecondaryIndexes),
            LocalSecondaryIndexes: compareIndexes(newCreateTableParams.LocalSecondaryIndexes, LocalSecondaryIndexes)
          };
          count = 0;
          out = object(out, {
            when: function(value) {
              return (value != null) && ++count;
            }
          });
          if (count > 0) {
            out.TableStatus = TableStatus;
            return out;
          } else if (TableStatus !== "ACTIVE") {
            return {
              TableStatus: TableStatus
            };
          } else {
            return "up to date";
          }
        });
      },
      getTableStatus: function(params) {
        var TableName;
        TableName = TableApiBaseClass.translateParams(params).TableName;
        return this.describeTable({
          TableName: TableName
        }).then(function(arg) {
          var currentTableDescription;
          currentTableDescription = arg.Table;
          return {
            TableStatus: currentTableDescription.TableStatus,
            GlobalSecondaryIndexStatus: object(currentTableDescription.GlobalSecondaryIndexes, {
              key: function(index) {
                return index.IndexName;
              },
              "with": function(index) {
                return index.IndexStatus;
              }
            })
          };
        });
      },

      /*
      IN:
        params:
          limit: number (optional)
      
          exclusiveStartKey: (optional)
          lastEvaluatedKey: (alias)
            use the lastEvaluatedKey that was returned from the previous call, if it was set
       */
      scan: function(params) {
        return this.invokeAws("scan", Scan.translateParams(params)).then(function(res) {
          var Count, Items, LastEvaluatedKey, ScannedCount, item;
          Items = res.Items, Count = res.Count, ScannedCount = res.ScannedCount, LastEvaluatedKey = res.LastEvaluatedKey;
          return merge({
            items: (function() {
              var i, len, results;
              results = [];
              for (i = 0, len = Items.length; i < len; i++) {
                item = Items[i];
                results.push(decodeDynamoItem(item));
              }
              return results;
            })(),
            count: Count,
            lastEvaluatedKey: LastEvaluatedKey && decodeDynamoItem(LastEvaluatedKey),
            scannedCount: ScannedCount
          });
        });
      },

      /*
      Non-table-operations
       */
      listTables: null,
      describeLimits: null,

      /*
      TODO: currently these only support the default DynamoDb API (with promises)
       */
      batchWriteItem: null,
      updateTable: null
    });

    return DynamoDb;

  })(BaseClass);

}).call(this);

//# sourceMappingURL=DynamoDb.js.map
