"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["isPlainObject", "Object", "Error", "isString", "compactFlatten"], [global, require('../StandardImport')], (isPlainObject, Object, Error, isString, compactFlatten) => {let CreateTable; return CreateTable = Caf.defClass(class CreateTable extends require('./TableApiBaseClass') {constructor() {super(...arguments); this._requiredAttributes = {};};}, function(CreateTable, classSuper, instanceSuper) {this.prototype._translateParams = function(params) {this._requiredAttributes = {}; this._translateGlobalIndexes(params); this._translateLocalIndexes(params); this._translateKey(params, this._target); this._translateAttributes(params); this._target.BillingMode = this._isPayPerRequest(params) ? "PAY_PER_REQUEST" : (this._translateProvisioning(params, this._target), "PROVISIONED"); return this._target;}; this.prototype._isPayPerRequest = function(params) {return (params.billingMode || params.BillingMode) === "PAY_PER_REQUEST" || !params.provisioning && !params.provisionedThroughput;}; this.prototype._translateAttributes = function(params, requiredAttributes = this._requiredAttributes) {let defs; defs = params.attributes || {id: "string"}; this._target.AttributeDefinitions = isPlainObject(defs) ? Caf.array(Object.keys(requiredAttributes).sort(), (attributeName) => {let type; type = defs[attributeName]; if (!type) {throw new Error(`Required attribute definition for '${Caf.toString(attributeName)}'' not present. Please add it to 'attributes'.`);}; return {AttributeName: attributeName, AttributeType: this._normalizeConstant(type)};}) : defs; return this._target;}; this.prototype._translateKey = function(params, target = {}) {let keySchema, hashKeyField, rangeKeyField; keySchema = params.key || params.keySchema || {id: "hash"}; target.KeySchema = isPlainObject(keySchema) ? Caf.array(keySchema, (v, k) => {return {AttributeName: k, KeyType: this._normalizeConstant(v)};}) : isString(keySchema) ? (([hashKeyField, rangeKeyField] = keySchema.split("/")), compactFlatten([{AttributeName: hashKeyField, KeyType: "HASH"}, rangeKeyField ? {AttributeName: rangeKeyField, KeyType: "RANGE"} : undefined])) : undefined; Caf.array(target.KeySchema, ({AttributeName}) => this._requiredAttributes[AttributeName] = true); return target;}; this.prototype._translateProvisioning = function(params, target = {}) {let provisioning; provisioning = Caf.exists(params) && params.provisioning || Caf.exists(params) && params.provisionedThroughput || {}; target.ProvisionedThroughput = {ReadCapacityUnits: provisioning.read || provisioning.readCapacityUnits || 1, WriteCapacityUnits: provisioning.write || provisioning.writeCapacityUnits || 1}; return target;}; this.prototype._translateGlobalIndexes = function(params) {let globalIndexes; if (globalIndexes = Caf.exists(params) && params.globalIndexes) {this._target.GlobalSecondaryIndexes = isPlainObject(globalIndexes) ? Caf.array(globalIndexes, (indexProps, indexName) => {let _target; _target = {IndexName: indexName}; if (isString(indexProps)) {this._translateKey({key: indexProps}, _target);} else {this._translateKey(indexProps, _target);}; this._translateProjection(indexProps, _target); if (!this._isPayPerRequest(params)) {this._translateProvisioning(indexProps, _target);}; return _target;}) : globalIndexes;}; return this._target;}; this.prototype._translateLocalIndexes = function(params) {let localIndexes; if (localIndexes = Caf.exists(params) && params.localIndexes || Caf.exists(params) && params.localSecondaryIndexes) {this._target.LocalSecondaryIndexes = isPlainObject(localIndexes) ? Caf.array(localIndexes, (indexProps, indexName) => {let _target; _target = {IndexName: indexName}; if (isString(indexProps)) {this._translateKey({key: indexProps}, _target);} else {this._translateKey(indexProps, _target);}; this._translateProjection(indexProps, _target); return _target;}) : localIndexes;}; return this._target;}; this.prototype._translateProjection = function(params, target = {}) {let projection, type, out; projection = Caf.exists(params) && params.projection || {type: "all"}; type = isString(projection) ? projection : projection.type; target.Projection = out = {ProjectionType: this._normalizeConstant(type, projection.attributes ? "INCLUDE" : "ALL")}; if (projection.attributes) {out.NonKeyAttributes = projection.attributes;}; return out;};});});});
//# sourceMappingURL=CreateTable.js.map
