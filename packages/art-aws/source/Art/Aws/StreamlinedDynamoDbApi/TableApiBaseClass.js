// Generated by CoffeeScript 1.12.7
(function() {
  var TableApiBaseClass, apiConstantsMap, compact, formattedInspect, inspect, isBoolean, isNumber, isPlainArray, isPlainObject, isString, log, lowerCamelCase, ref, upperCamelCase, wordsArray;

  ref = require('art-standard-lib'), log = ref.log, lowerCamelCase = ref.lowerCamelCase, wordsArray = ref.wordsArray, isString = ref.isString, isPlainArray = ref.isPlainArray, isPlainObject = ref.isPlainObject, isNumber = ref.isNumber, isBoolean = ref.isBoolean, inspect = ref.inspect, upperCamelCase = ref.upperCamelCase, compact = ref.compact, formattedInspect = ref.formattedInspect;

  apiConstantsMap = require('./Common').apiConstantsMap;

  module.exports = TableApiBaseClass = (function() {
    var decodeDynamoData;

    function TableApiBaseClass() {
      this._uniqueExpressionAttributeId = 0;
      this._target = {};
    }


    /*
    IN: params: plain object
      if params.TableName is set, assume it is the standard DynamoDb API - pass directly through.
     */

    TableApiBaseClass.prototype.translateParams = function(params) {
      if (params.TableName) {
        return params;
      }
      this._translateTableName(params);
      this._translateParams(params);
      return this._target;
    };

    TableApiBaseClass.translateParams = function(params) {
      return new this().translateParams(params);
    };

    TableApiBaseClass.decodeDynamoData = decodeDynamoData = function(data) {
      var array, bool, i, k, len, map, number, out, results, string, v;
      if (map = data.M) {
        out = {};
        for (k in map) {
          v = map[k];
          out[k] = decodeDynamoData(v);
        }
        return out;
      } else if (array = data.L) {
        results = [];
        for (i = 0, len = array.length; i < len; i++) {
          v = array[i];
          results.push(decodeDynamoData(v));
        }
        return results;
      } else if (string = data.S) {
        return string;
      } else if ((number = data.N) != null) {
        return parseFloat(number);
      } else if ((bool = data.BOOL) != null) {
        return !!bool;
      } else if (data.NULL) {
        return null;
      } else {
        throw new Error("unknown dynamo data type: " + (inspect(data)));
      }
    };

    TableApiBaseClass.decodeDynamoItem = function(item) {
      var k, out, v;
      out = {};
      for (k in item) {
        v = item[k];
        out[k] = decodeDynamoData(v);
      }
      return out;
    };

    TableApiBaseClass.prototype._translateParams = function() {};

    TableApiBaseClass.prototype._encodeDynamoData = function(data) {
      var k, ret, v, values;
      return ret = (function() {
        if (isPlainObject(data)) {
          values = {};
          for (k in data) {
            v = data[k];
            if (v !== void 0) {
              values[k] = this._encodeDynamoData(v);
            }
          }
          return {
            M: values
          };
        } else if (isPlainArray(data)) {
          return {
            L: (function() {
              var i, len, results;
              results = [];
              for (i = 0, len = data.length; i < len; i++) {
                v = data[i];
                if (v !== void 0) {
                  results.push(this._encodeDynamoData(v));
                }
              }
              return results;
            }).call(this)
          };
        } else if (isBoolean(data)) {
          return {
            BOOL: data
          };
        } else if (isString(data)) {
          return {
            S: data
          };
        } else if (isNumber(data)) {
          return {
            N: data.toString()
          };
        } else if (data === null) {
          return {
            NULL: true
          };
        } else {
          throw new Error("invalid data type: " + (inspect(data)));
        }
      }).call(this);
    };

    TableApiBaseClass.prototype._decodeDynamoData = decodeDynamoData;

    TableApiBaseClass.prototype._encodeItem = function(item) {
      return this._encodeDynamoData(item).M;
    };

    TableApiBaseClass.prototype._addExpressionAttributeValue = function(key, value) {
      var base;
      return ((base = this._target).ExpressionAttributeValues || (base.ExpressionAttributeValues = {}))[key] = this._encodeDynamoData(value);
    };

    TableApiBaseClass.prototype._addExpressionAttributeName = function(attributeAlias, attributeName) {
      var base;
      return ((base = this._target).ExpressionAttributeNames || (base.ExpressionAttributeNames = {}))[attributeAlias] = attributeName;
    };

    TableApiBaseClass.prototype._getNextUniqueExpressionAttributeId = function() {
      return this._uniqueExpressionAttributeId = (this._uniqueExpressionAttributeId || 0) + 1;
    };

    TableApiBaseClass.prototype._translateConsistentRead = function(params) {
      if (params.consistentRead) {
        return this._target.ConsistentRead = true;
      }
    };

    TableApiBaseClass.prototype._translateLimit = function(params) {
      if (params.limit) {
        return this._target.Limit = params.limit;
      }
    };

    TableApiBaseClass.prototype._translateExclusiveStartKey = function(params) {
      var exclusiveStartKey, lastEvaluatedKey;
      exclusiveStartKey = params.exclusiveStartKey, lastEvaluatedKey = params.lastEvaluatedKey;
      if (exclusiveStartKey || (exclusiveStartKey = lastEvaluatedKey)) {
        return this._target.ExclusiveStartKey = this._encodeItem(exclusiveStartKey);
      }
    };

    TableApiBaseClass.prototype._translateConsumedCapacity = function(params) {
      return this._translateConstantParam(params, "returnConsumedCapacity");
    };

    TableApiBaseClass.prototype._translateSelect = function(params) {
      var select;
      select = params.select;
      if (!select) {
        return this._target;
      }
      switch (select) {
        case "*":
          this._target.Select = "ALL_ATTRIBUTES";
          break;
        case "count(*)":
          this._target.Select = "COUNT";
          break;
        default:
          if (isString(select)) {
            select = select.match(/[a-z0-9\[\].]+/gi);
          }
          this._target.ProjectionExpression = select.join(', ');
          "SPECIFIC_ATTRIBUTES";
      }
      return this._target;
    };

    TableApiBaseClass.prototype._translateConditionExpression = function(conditionExpression) {
      var attributeAlias, attributeName, expressions, ret, subExpression, test, uniqueId;
      ret = isPlainArray(conditionExpression) ? (expressions = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = conditionExpression.length; i < len; i++) {
          subExpression = conditionExpression[i];
          if (isString(subExpression)) {
            results.push(subExpression);
          } else {
            results.push(this._translateConditionExpression(subExpression));
          }
        }
        return results;
      }).call(this), compact(expressions).join(' ')) : (expressions = (function() {
        var results;
        results = [];
        for (attributeName in conditionExpression) {
          test = conditionExpression[attributeName];
          uniqueId = this._getNextUniqueExpressionAttributeId(this._target);
          attributeAlias = "#attr" + uniqueId;
          this._addExpressionAttributeName(attributeAlias, attributeName);
          results.push(this._translateConditionExpressionField(attributeAlias, test, uniqueId));
        }
        return results;
      }).call(this), expressions.join(' AND '));
      if ("()" === (ret = "(" + ret + ")")) {
        return null;
      } else {
        return ret;
      }
    };


    /*
      Example:
        conditionExpression:
          myField1: 123                       # as long as value is not an object, defaults to "eq"
          myField1: eq: 123                   # same as above
          myField1: beginsWith: "foo"         #
          myField1: contains: "foo"           #
          myField1: attributeExists: true     # value only needs to be truish
          myField1: attributeNotExists: true  # value only needs to be truish
     */

    TableApiBaseClass.prototype._translateConditionExpressionField = function(attributeAlias, test, uniqueId) {
      var between, expression, gte, gteAlias, lte, lteAlias, value, valueAlias;
      valueAlias = ":val" + uniqueId;
      if (between = test != null ? test.between : void 0) {
        if (between.length !== 2) {
          throw new Error("between test must have exactly two values: " + (formattedInspect({
            between: between
          })));
        }
        test = {
          gte: between[0],
          lte: between[1]
        };
      }
      switch (false) {
        case !(test && (gte = test.gte) && (lte = test.lte)):
          this._addExpressionAttributeValue((gteAlias = valueAlias + "Gte"), gte);
          this._addExpressionAttributeValue((lteAlias = valueAlias + "Lte"), lte);
          return attributeAlias + " BETWEEN " + gteAlias + " AND " + lteAlias;
        case !test.attributeExists:
          return "attribute_exists(" + attributeAlias + ")";
        case !test.attributeNotExists:
          return "attribute_not_exists(" + attributeAlias + ")";
        default:
          expression = (function() {
            if (!isPlainObject(value = test)) {
              return attributeAlias + " = " + valueAlias;
            } else if ((value = test.eq) != null) {
              return attributeAlias + " = " + valueAlias;
            } else if ((value = test.lt) != null) {
              return attributeAlias + " < " + valueAlias;
            } else if ((value = test.gt) != null) {
              return attributeAlias + " > " + valueAlias;
            } else if ((value = test.lte) != null) {
              return attributeAlias + " <= " + valueAlias;
            } else if ((value = test.gte) != null) {
              return attributeAlias + " >= " + valueAlias;
            } else if ((value = test.beginsWith) != null) {
              return "begines_with(" + attributeAlias + ", " + valueAlias + ")";
            } else if ((value = test.attributeType) != null) {
              return "begines_with(" + attributeAlias + ", " + valueAlias + ")";
            } else if ((value = test.contains) != null) {
              return "begines_with(" + attributeAlias + ", " + valueAlias + ")";
            } else {
              throw new Error("no valid test detected in: " + attributeAlias + ": " + (inspect(test)));
            }
          })();
          this._addExpressionAttributeValue(valueAlias, value);
          return expression;
      }
    };

    TableApiBaseClass.prototype._translateConditionExpressionParam = function(params) {
      var conditionExpression, expr;
      conditionExpression = params.conditionExpression;
      if (!conditionExpression) {
        return this._target;
      }
      if (expr = this._translateConditionExpression(conditionExpression)) {
        this._target.ConditionExpression = expr;
      }
      return this._target;
    };

    TableApiBaseClass.prototype._getTranslatedKey = function(key) {
      var k, out, v;
      if (!key) {
        throw new Error("key required");
      }
      out = {};
      if (isString(key)) {
        key = {
          id: key
        };
      }
      for (k in key) {
        v = key[k];
        out[k] = this._encodeDynamoData(v);
      }
      return out;
    };

    TableApiBaseClass.prototype._translateKey = function(params) {
      return this._target.Key = this._getTranslatedKey(params.key);
    };

    TableApiBaseClass.prototype._getTableName = function(arg) {
      var table, tableName;
      table = arg.table, tableName = arg.tableName;
      if (table == null) {
        table = tableName;
      }
      if (!table) {
        throw new Error("table or tableName required");
      }
      return table;
    };

    TableApiBaseClass.prototype._translateTableName = function(params) {
      return this._target.TableName = this._getTableName(params);
    };

    TableApiBaseClass.prototype._translateIndexName = function(params) {
      if (params.index) {
        return this._target.IndexName = params.index;
      }
    };

    TableApiBaseClass.prototype._normalizeConstant = function(constant, _default) {
      var ret;
      if (!(ret = apiConstantsMap[constant] || _default)) {
        throw new Error("constant '" + constant + "' not found/supported");
      }
      return ret;
    };

    TableApiBaseClass.prototype._translateConstantParam = function(params, paramName, _default) {
      var dynamoDbName, value;
      dynamoDbName = upperCamelCase(paramName);
      value = params[paramName] || _default;
      if (value) {
        return this._target[dynamoDbName] = this._normalizeConstant(value);
      }
    };

    return TableApiBaseClass;

  })();

}).call(this);

//# sourceMappingURL=TableApiBaseClass.js.map
