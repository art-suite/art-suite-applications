// Generated by CoffeeScript 1.12.7
(function() {
  var AtomicBase, Namespace, PI, Point, abs, atan, bound, ceil, cos, floatEq, floor, inspect, inspectedObjectLiteral, isArray, isFunction, isNumber, isString, log, max, merge, min, nearInfinity, ref, round, sin, sqrt, stringToNumberArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  AtomicBase = require('./Base');

  Namespace = require('./namespace');

  ref = require('art-standard-lib'), merge = ref.merge, inspect = ref.inspect, bound = ref.bound, floatEq = ref.floatEq, log = ref.log, isNumber = ref.isNumber, isArray = ref.isArray, isString = ref.isString, isFunction = ref.isFunction, stringToNumberArray = ref.stringToNumberArray, nearInfinity = ref.nearInfinity, inspectedObjectLiteral = ref.inspectedObjectLiteral;

  abs = Math.abs, sqrt = Math.sqrt, atan = Math.atan, PI = Math.PI, floor = Math.floor, ceil = Math.ceil, round = Math.round, min = Math.min, max = Math.max, cos = Math.cos, sin = Math.sin;


  /*
  point() general point constructor
  
  IN: (p:Point)
  OUT: p
  
  IN: ()
  IN: ([])
  OUT: point 0, 0
  
  IN: (string)
  OUT: Point.namedPoints[string] || Point.parse string
  
  IN: (s:number)
  IN: ([s:number])
  OUT: new Point s, s
  
  IN: (x:number, y:number)
  IN: ([x:number, y:number])
  OUT: new Point x, y
  
  IN: ({x:number, y:number})
  OUT: new Point x || 0, y || 0
  
  IN: ({aspectRatio: number, area: number})
    aspectRatio: number representing: width / height
    area: number representing the square-area desired
  OUT:
    a point, p, with:
      p.area == o.area
      p.aspectRatio == o.aspectRatio
   */

  module.exports = Point = (function(superClass) {
    var bottomCenter, bottomLeft, bottomRight, centerCenter, centerLeft, centerRight, isPoint, k, namedPoints, point, point0, point1, point2, pointHalf, pointNearInfinity, pointNeg1, pointNeg2, pointNegHalf, pointWithAspectRatioAndArea, topCenter, topLeft, topRight, v;

    extend(Point, superClass);

    function Point() {
      return Point.__super__.constructor.apply(this, arguments);
    }

    Point.defineAtomicClass({
      fieldNames: "x y"
    });

    Point.isPoint = isPoint = function(v) {
      return (v != null ? v.constructor : void 0) === Point;
    };

    Point.prototype._initFromObject = function(obj) {
      var angle, magnitude, ref1, x, y;
      this.x = this.y = 0;
      if ((angle = obj.angle) != null) {
        magnitude = (ref1 = obj.magnitude) != null ? ref1 : 1;
        this.x = cos(angle) * magnitude;
        return this.y = sin(angle) * magnitude;
      } else {
        x = obj.x, y = obj.y;
        if (x != null) {
          this.x = x;
        }
        if (y != null) {
          return this.y = y;
        }
      }
    };

    pointWithAspectRatioAndArea = function(arg) {
      var area, aspectRatio, fitInto, fitIntoAspectRatio, ref1, sqrtArea, x, y, zoomInto, zoomIntoAspectRatio;
      aspectRatio = arg.aspectRatio, area = (ref1 = arg.area) != null ? ref1 : 1, fitInto = arg.fitInto, zoomInto = arg.zoomInto;
      if (fitInto) {
        x = fitInto.x, y = fitInto.y;
        fitIntoAspectRatio = fitInto.aspectRatio;
        if (aspectRatio < fitIntoAspectRatio) {
          return point(y * aspectRatio, y);
        } else {
          return point(x, x / aspectRatio);
        }
      } else if (zoomInto) {
        x = zoomInto.x, y = zoomInto.y;
        zoomIntoAspectRatio = zoomInto.aspectRatio;
        if (aspectRatio > zoomIntoAspectRatio) {
          return point(y * aspectRatio, y);
        } else {
          return point(x, x / aspectRatio);
        }
      } else {
        sqrtArea = Math.sqrt(area / aspectRatio);
        return point(sqrtArea * aspectRatio, sqrtArea);
      }
    };

    Point.point = point = function(a, b) {
      var p, x, y;
      if (isPoint(a)) {
        return a;
      }
      if (isString(a) && (p = namedPoints[a])) {
        return p;
      }
      if (a != null ? a.aspectRatio : void 0) {
        return pointWithAspectRatioAndArea(a);
      }
      x = a || 0;
      y = b != null ? b : a;
      if (point0.eq(x, y)) {
        return point0;
      }
      if (point1.eq(x, y)) {
        return point1;
      }
      return new Point(a, b);
    };

    Point.parse = function(string, existing) {
      if (existing) {
        throw new Error("existing feature is no longer supported");
      }
      return new Point(string);
    };

    Point.prototype._init = function(x, y) {
      x || (x = 0);
      if (y == null) {
        y = x;
      }
      this.x = x - 0;
      return this.y = y - 0;
    };

    Point.getter({
      exportedValue: function() {
        var out, ref1, x, y;
        ref1 = this, x = ref1.x, y = ref1.y;
        if (x === y) {
          return x;
        } else {
          out = {};
          if (x !== 0) {
            out.x = x;
          }
          if (y !== 0) {
            out.y = y;
          }
          return out;
        }
      },
      top: function() {
        return 0;
      },
      left: function() {
        return 0;
      },
      right: function() {
        return this.x;
      },
      bottom: function() {
        return this.y;
      },
      centerX: function() {
        return this.x * .5;
      },
      centerY: function() {
        return this.y * .5;
      },
      hCenter: function() {
        return this.getCenterX();
      },
      vCenter: function() {
        return this.getCenterY();
      },
      tl: function() {
        return point0;
      },
      tc: function() {
        return this.mul(0.5, 0);
      },
      tr: function() {
        return this.mul(1, 0);
      },
      lc: function() {
        return this.mul(0, 0.5);
      },
      cc: function() {
        return this.mul(0.5, 0.5);
      },
      rc: function() {
        return this.mul(1, 0.5);
      },
      bl: function() {
        return this.mul(0, 1);
      },
      bc: function() {
        return this.mul(0.5, 1);
      },
      br: function() {
        return this;
      },
      ccNeg: function() {
        return this.mul(-0.5);
      },
      topLeft: function() {
        return point0;
      },
      topCenter: function() {
        return this.mul(0.5, 0);
      },
      topRight: function() {
        return this.mul(1, 0);
      },
      centerLeft: function() {
        return this.mul(0, 0.5);
      },
      centerCenter: function() {
        return this.mul(0.5, 0.5);
      },
      centerRight: function() {
        return this.mul(1, 0.5);
      },
      bottomLeft: function() {
        return this.mul(0, 1);
      },
      bottomCenter: function() {
        return this.mul(0.5, 1);
      },
      bottomRight: function() {
        return this;
      },
      isFinite: function() {
        return isFinite(this.x) && isFinite(this.y);
      },
      isInfinite: function() {
        return !this.isFinite;
      },
      w: function() {
        return this.x;
      },
      width: function() {
        return this.x;
      },
      h: function() {
        return this.y;
      },
      height: function() {
        return this.y;
      },
      neg: function() {
        return new Point(-this.x, -this.y);
      },
      inv: function() {
        return new Point(1.0 / this.x, 1.0 / this.y);
      },
      vector: function() {
        return [this.x, this.y];
      },
      magnitudeSquared: function() {
        return this.x * this.x + this.y * this.y;
      },
      magnitude: function() {
        return sqrt(this.x * this.x + this.y * this.y);
      },
      aspectRatio: function() {
        return this.x / this.y;
      },
      absoluteAspectRatio: function() {
        return abs(this.x / this.y);
      },
      swapped: function() {
        return point(this.y, this.x);
      },
      rounded: function() {
        return this.round();
      },
      floored: function() {
        return this.floor();
      },
      ceiled: function() {
        return this.ceil();
      },
      area: function() {
        return this.x * this.y;
      },
      sum: function() {
        return this.x + this.y;
      },
      size: function() {
        return this;
      },
      location: function() {
        return point0;
      },
      abs: function() {
        return this["with"](abs(this.x), abs(this.y));
      },
      unitVector: function() {
        var m;
        m = 1 / this.magnitude;
        return new Point(this.x * m, this.y * m);
      },
      perpendicularVector: function() {
        return new Point(this.y, -this.x);
      },
      unitPerpendicularVector: function() {
        var m;
        m = 1 / this.magnitude;
        return new Point(this.y * m, -this.x * m);
      },
      angle: function() {
        if (this.x === 0) {
          return PI * (this.y > 0 ? .5 : 1.5);
        } else {
          if (this.x > 0) {
            return atan(this.y / this.x);
          } else {
            return atan(this.y / this.x) + PI;
          }
        }
      },
      angle2: function() {
        return Math.atan2(this.y, this.x);
      },
      isInteger: function() {
        return floatEq(this.x, this.x | 0) && floatEq(this.y, this.y | 0);
      }
    });

    Point.prototype.distance = function(p2) {
      return sqrt(this.distanceSquared(p2));
    };

    Point.prototype.distanceSquared = function(p2) {
      var x, y;
      x = this.x - p2.x;
      y = this.y - p2.y;
      return x * x + y * y;
    };

    Point.prototype.withArea = function(newArea) {
      var area;
      area = this.area;
      if (!(area > 0 && newArea >= 0)) {
        throw new Error("area must be > 0");
      }
      return this.mul(Math.sqrt(newArea / area));
    };

    Point.prototype.vectorLength = 2;

    Point.prototype.toIndex = function(lineStride) {
      return ~~this.y * lineStride + ~~this.x;
    };

    Point.prototype.contains = function(p) {
      return p.x >= 0 && p.y >= 0 && p.x < this.x & p.y < this.y;
    };

    Point.prototype.nearestInsidePoint = function(p) {
      return this["with"](bound(0, p.x, this.x), bound(0, p.y, this.y));
    };

    Point.prototype.appendToVector = function(vector) {
      var l;
      l = vector.length;
      vector[l + 1] = this.y;
      return vector[l] = this.x;
    };

    Point.prototype.dot = function(p) {
      return this.x * p.x + this.y * p.y;
    };

    Point.prototype.cross = function(p) {
      return this.x * p.y - this.y * p.x;
    };

    Point.prototype.floor = function() {
      return this["with"](floor(this.x), floor(this.y));
    };

    Point.prototype.ceil = function() {
      return this["with"](ceil(this.x), ceil(this.y));
    };

    Point.prototype.scalerProjection = function(ontoB) {
      return this.dot(ontoB) / ontoB.magnitude;
    };

    Point.prototype.scalerProjectionSquared = function(ontoB) {
      return Math.pow(this.dot(ontoB), 2) / ontoB.magnitudeSquared;
    };

    Point.prototype.scalerPerpendicularProjectionSquared = function(ontoB) {
      return this.magnitudeSquared - this.scalerProjectionSquared(ontoB);
    };

    Point.prototype.scalerPerpendicularProjection = function(ontoB) {
      return Math.sqrt(this.scalerPerpendicularProjectionSquared(ontoB));
    };

    Point.prototype.union = function(b) {
      if (isPoint(b)) {
        return this.max(b);
      } else {
        return b.union(this);
      }
    };

    Point.prototype.intersection = function(b) {
      if (isPoint(b)) {
        return this.min(b);
      } else {
        return b.intersection(this);
      }
    };

    Point.prototype.min = function(b) {
      if (b == null) {
        b = null;
      }
      if (b) {
        return this["with"](min(this.x, b.x), min(this.y, b.y));
      } else {
        return min(this.x, this.y);
      }
    };

    Point.prototype.max = function(b) {
      if (b == null) {
        b = null;
      }
      if (b) {
        return this["with"](max(this.x, b.x), max(this.y, b.y));
      } else {
        return max(this.x, this.y);
      }
    };

    Point.prototype.average = function(b) {
      if (b == null) {
        b = null;
      }
      if (b) {
        return this["with"]((this.x + b.x) / 2, (this.y + b.y) / 2);
      } else {
        return (this.x + this.y) / 2;
      }
    };

    Point.prototype.bound = function(a, b) {
      return this["with"](bound(a.x, this.x, b.x), bound(a.y, this.y, b.y));
    };

    Point.prototype.round = function(m) {
      if (m == null) {
        m = 1;
      }
      return this["with"](round(this.x / m) * m, round(this.y / m) * m);
    };

    Point.prototype.roundOut = function() {
      return this.ceil();
    };


    /*
    OUT:
      out.aspectRatio == @aspectRatio
      out <= into
      out.x == into.x or out.y == into.y
    proposed rename: scaledJustLte
     */

    Point.prototype.fitInto = function(into) {
      var x, xr, y, yr;
      if (into == null) {
        return this;
      }
      if (isNumber(into)) {
        x = y = into;
      } else {
        x = into.x, y = into.y;
      }
      xr = x / this.x;
      yr = y / this.y;
      return this.mul(min(xr, yr));
    };


    /*
    OUT:
      out.aspectRatio == @aspectRatio
      out >= into
      out.x == into.x or out.y == into.y
    
    KEYWORD: I used to call this 'zoom'
    proposed rename: scaledJustGte
     */

    Point.prototype.fill = function(into) {
      var x, xr, y, yr;
      if (isNumber(into)) {
        x = y = into;
      } else {
        x = into.x, y = into.y;
      }
      xr = x / this.x;
      yr = y / this.y;
      return this.mul(max(xr, yr));
    };


    /*
    OUT:
      out.aspectRatio == @aspectRatio
      out.area == p.area
     */

    Point.prototype.withSameAreaAs = function(p) {
      return this.mul(Math.sqrt(p.area / this.area));
    };

    Point.prototype.withAspectRatio = function(aspectRatio) {
      if (floatEq(aspectRatio, this.aspectRatio)) {
        return this;
      }
      return point({
        aspectRatio: aspectRatio,
        area: this.area
      });
    };

    Point.prototype.withRect = function(a, b, c, d) {
      if ((d != null) && a === 0 && b === 0) {
        return this["with"](c, d);
      } else {
        return Namespace.rect(a, b, c, d);
      }
    };

    Point.prototype.minRatio = function(b) {
      return min(this.x / b.x, this.y / b.y);
    };

    Point.prototype.maxRatio = function(b) {
      return max(this.x / b.x, this.y / b.y);
    };

    Point.prototype.intersect = function(withRectOrPoint, into) {
      log.warn("DEPRICATED: use: intersection");
      return this.intersection(withRectOrPoint, into);
    };

    Point.prototype.intersection = function(withRectOrPoint, into) {
      if (withRectOrPoint.constructor === Namespace.Rectangle) {
        return withRectOrPoint.intersection(this, into);
      } else {
        if (into == null) {
          into = new Namespace.Rectangle;
        }
        into._setAll(0, 0, this.w, this.h);
        return into.intersection(withRectOrPoint, into);
      }
    };

    point0 = topLeft = (new Point(0)).freeze();

    point1 = bottomRight = (new Point(1)).freeze();

    point2 = (new Point(2)).freeze();

    pointHalf = (new Point(.5)).freeze();

    pointNegHalf = (new Point(-.5)).freeze();

    pointNeg1 = (new Point(-1)).freeze();

    pointNeg2 = (new Point(-2)).freeze();

    topRight = (new Point(1, 0)).freeze();

    topCenter = (new Point(0.5, 0)).freeze();

    centerLeft = (new Point(0, 0.5)).freeze();

    centerCenter = (new Point(0.5)).freeze();

    centerRight = (new Point(1, 0.5)).freeze();

    bottomCenter = (new Point(0.5, 1)).freeze();

    bottomLeft = (new Point(0, 1)).freeze();

    pointNearInfinity = (new Point(nearInfinity)).freeze();

    Point.namedAlignmentPoints = {
      topLeft: topLeft,
      topCenter: topCenter,
      topRight: topRight,
      centerLeft: centerLeft,
      centerCenter: centerCenter,
      centerRight: centerRight,
      bottomLeft: bottomLeft,
      bottomCenter: bottomCenter,
      bottomRight: bottomRight
    };

    Point.namedPoints = namedPoints = merge(Point.namedAlignmentPoints, {
      point0: point0,
      point1: point1,
      pointNearInfinity: pointNearInfinity,
      point2: point2,
      pointNeg2: pointNeg2,
      pointNeg1: pointNeg1,
      pointHalf: pointHalf,
      pointNegHalf: pointNegHalf,
      center: topCenter,
      left: topLeft,
      right: topRight,
      bottom: bottomLeft,
      top: topLeft
    });

    for (k in namedPoints) {
      v = namedPoints[k];
      Point[k] = v;
    }

    Point.namedValues = namedPoints;

    return Point;

  })(AtomicBase);

}).call(this);

//# sourceMappingURL=Point.js.map
