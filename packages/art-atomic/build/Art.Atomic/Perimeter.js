// Generated by CoffeeScript 1.12.7
(function() {
  var AtomicBase, Perimeter, Point, floatEq, inspect, isPlainObject, isString, log, min, point, rect, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  AtomicBase = require('./Base');

  Point = require('./Point');

  ref = require('art-standard-lib'), log = ref.log, inspect = ref.inspect, floatEq = ref.floatEq, isPlainObject = ref.isPlainObject, isString = ref.isString, min = ref.min;

  point = Point.point;

  rect = require('./Rectangle').rect;

  module.exports = Perimeter = (function(superClass) {
    var isPerimeter, k, namedPerimeters, perimeter, perimeter0, ref1, v;

    extend(Perimeter, superClass);

    function Perimeter() {
      return Perimeter.__super__.constructor.apply(this, arguments);
    }

    Perimeter.defineAtomicClass({
      fieldNames: "left right top bottom"
    });

    Perimeter.isPerimeter = isPerimeter = function(v) {
      return (v != null ? v.constructor : void 0) === Perimeter;
    };

    Perimeter.perimeter = perimeter = function(a, b, c, d) {
      var p;
      if (isPerimeter(a)) {
        return a;
      }
      if (isString(a) && (p = namedPerimeters[a])) {
        return p;
      }
      if ((b == null) && (floatEq(a, 0)) || !a) {
        return perimeter0;
      }
      return new Perimeter(a, b, c, d);
    };

    Perimeter.prototype._initFields = function() {
      return this.left = this.right = this.top = this.bottom = 0;
    };

    Perimeter.prototype._initFromObject = function(obj) {
      return this._init((obj.left || 0) + (obj.l || 0) + (obj.h || 0) + (obj.horizontal || 0), (obj.right || 0) + (obj.r || 0) + (obj.h || 0) + (obj.horizontal || 0), (obj.top || 0) + (obj.t || 0) + (obj.v || 0) + (obj.vertical || 0), (obj.bottom || 0) + (obj.b || 0) + (obj.v || 0) + (obj.vertical || 0));
    };

    Perimeter.prototype._init = function(a, b, c, d) {
      var argLength;
      this._initFields();
      argLength = a != null ? b != null ? c != null ? d != null ? 4 : 3 : 2 : 1 : 0;
      switch (argLength) {
        case 0:
          return this.left = this.right = this.top = this.bottom = 0;
        case 1:
          return this.left = this.right = this.top = this.bottom = a;
        case 2:
          this.left = this.right = a;
          return this.top = this.bottom = b;
        case 4:
          this.left = a;
          this.right = b;
          this.top = c;
          return this.bottom = d;
        default:
          throw new Error("invalid number of arguments: " + (inspect(arguments)));
      }
    };

    Perimeter.getter({
      exportedValue: function() {
        var bottom, left, out, ref1, right, top;
        ref1 = this, left = ref1.left, right = ref1.right, top = ref1.top, bottom = ref1.bottom;
        if ((left === right) && (left === top) && (left === bottom)) {
          return left;
        } else {
          out = {};
          if (left === right) {
            if (left !== 0) {
              out.h = left;
            }
          } else {
            if (left !== 0) {
              out.left = left;
            }
            if (right !== 0) {
              out.right = right;
            }
          }
          if (top === bottom) {
            if (top !== 0) {
              return out.v = top;
            }
          } else {
            if (top !== 0) {
              out.top = top;
            }
            if (bottom !== 0) {
              return out.bottom = bottom;
            }
          }
        }
      },
      width: function() {
        return this.left + this.right;
      },
      height: function() {
        return this.top + this.bottom;
      },
      w: function() {
        return this.left + this.right;
      },
      h: function() {
        return this.top + this.bottom;
      },
      needsTranslation: function() {
        return this.left !== 0 || this.top !== 0;
      }
    });

    Perimeter.prototype.subtractedFromSize = function(size) {
      var h, w;
      w = this.getWidth();
      h = this.getHeight();
      if (floatEq(w, 0) && floatEq(h, 0)) {
        return size;
      } else {
        return point(size.x - w, size.y - h);
      }
    };

    Perimeter.prototype.addedToSize = function(size) {
      var h, w;
      w = this.getWidth();
      h = this.getHeight();
      if (floatEq(w, 0) && floatEq(h, 0)) {
        return size;
      } else {
        return point(size.x + w, size.y + h);
      }
    };

    Perimeter.prototype.minWH = function(maxW, maxH) {
      var out;
      out = this["with"](min(this.left, maxW), min(this.right, maxW), min(this.top, maxH), min(this.bottom, maxH));
      return out;
    };


    /*
    Named Instances
     */

    Perimeter.namedPerimeters = namedPerimeters = {
      perimeter0: perimeter0 = (new Perimeter(0)).freeze()
    };

    ref1 = Perimeter.namedPerimeters;
    for (k in ref1) {
      v = ref1[k];
      Perimeter[k] = v;
    }

    Perimeter.prototype.pad = function(rectangle) {
      var bottom, h, left, ref2, right, top, w, x, y;
      x = rectangle.left, y = rectangle.top, w = rectangle.w, h = rectangle.h;
      ref2 = this, left = ref2.left, right = ref2.right, top = ref2.top, bottom = ref2.bottom;
      return rectangle.withRect(x + left, y + top, w - left - right, h - top - bottom);
    };

    return Perimeter;

  })(AtomicBase);

}).call(this);

//# sourceMappingURL=Perimeter.js.map
