// Generated by CoffeeScript 1.12.7
(function() {
  var Atomic, AtomicBase, Point, Rectangle, bound, ceil, float32Precision, floatEq, floatEq0, floatGt, floatGte, floatLt, floatLte, floor, isArray, isFunction, isNumber, isPoint, isString, log, max, min, point, ref, round, stringToNumberArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Atomic = require('./namespace');

  AtomicBase = require('./Base');

  Point = require('./Point');

  ref = require('art-standard-lib'), max = ref.max, min = ref.min, bound = ref.bound, round = ref.round, floatEq = ref.floatEq, floor = ref.floor, ceil = ref.ceil, round = ref.round, log = ref.log, isNumber = ref.isNumber, isArray = ref.isArray, isString = ref.isString, isFunction = ref.isFunction, stringToNumberArray = ref.stringToNumberArray, floatEq0 = ref.floatEq0, float32Precision = ref.float32Precision, floatLt = ref.floatLt, floatGt = ref.floatGt, floatGte = ref.floatGte, floatLte = ref.floatLte;

  point = Point.point, isPoint = Point.isPoint;

  module.exports = Rectangle = (function(superClass) {
    var getLeftRightTopBottomPointAsDot, isRect, rect;

    extend(Rectangle, superClass);

    function Rectangle() {
      return Rectangle.__super__.constructor.apply(this, arguments);
    }

    Rectangle.defineAtomicClass({
      fieldNames: "x y w h",
      constructorFunctionName: "rect"
    });

    Rectangle.isRect = isRect = function(v) {
      return (v != null ? v.constructor : void 0) === Rectangle;
    };

    Rectangle.rect = rect = function(a, b, c, d) {
      if (isRect(a)) {
        return a;
      }
      return new Rectangle(a, b, c, d);
    };

    Rectangle.prototype._initFromObject = function(obj) {
      var center, h, size, w, x, y;
      this.x = this.y = this.w = this.h = 0;
      size = obj.size, center = obj.center;
      if (size) {
        if (isNumber(size)) {
          x = y = size;
        } else {
          x = size.x, y = size.y;
        }
        this.w = x;
        this.h = y;
      } else {
        this.w = this.h = 1;
      }
      if (center) {
        if (isNumber(center)) {
          x = y = center;
        } else {
          x = center.x, y = center.y;
        }
        this.x = x - this.w / 2;
        this.y = y - this.h / 2;
      }
      x = obj.x, y = obj.y, w = obj.w, h = obj.h;
      if (x != null) {
        this.x = x;
      }
      if (y != null) {
        this.y = y;
      }
      if (w != null) {
        this.w = w;
      }
      if (h != null) {
        return this.h = h;
      }
    };

    Rectangle.prototype._init = function(a, b, c, d) {
      this.x = this.y = this.w = this.h = 0;
      if (d != null) {
        this.x = a - 0;
        this.y = b - 0;
        this.w = c - 0;
        return this.h = d - 0;
      } else if (b != null) {
        if (isPoint(b)) {
          this.x = a.x;
          this.y = a.y;
          this.w = b.w;
          return this.h = b.h;
        } else {
          this.w = a - 0;
          return this.h = b - 0;
        }
      } else if (isPoint(a)) {
        this.w = a.w;
        return this.h = a.h;
      } else if (a != null) {
        return this.w = this.h = a - 0;
      }
    };

    Rectangle.getter({
      aspectRatio: function() {
        return this.w / this.h;
      },
      location: function() {
        return new Point(this.x, this.y);
      },
      locationMatrix: function() {
        return Atomic.Matrix.translateXY(this.x, this.y);
      },
      size: function() {
        return new Point(this.w, this.h);
      },
      width: function() {
        return this.w;
      },
      height: function() {
        return this.h;
      },
      rounded: function() {
        return this["with"](round(this.x), round(this.y), round(this.w), round(this.h));
      },
      tl: function() {
        return new Point(this.x, this.y);
      },
      tc: function() {
        return new Point(this.hCenter, this.y);
      },
      tr: function() {
        return new Point(this.right, this.y);
      },
      lc: function() {
        return new Point(this.x, this.vCenter);
      },
      cc: function() {
        return new Point(this.hCenter, this.vCenter);
      },
      rc: function() {
        return new Point(this.right, this.vCenter);
      },
      bl: function() {
        return new Point(this.x, this.bottom);
      },
      bc: function() {
        return new Point(this.hCenter, this.bottom);
      },
      br: function() {
        return new Point(this.right, this.bottom);
      },
      topLeft: function() {
        return new Point(this.x, this.y);
      },
      topCenter: function() {
        return new Point(this.hCenter, this.y);
      },
      topRight: function() {
        return new Point(this.right, this.y);
      },
      centerLeft: function() {
        return new Point(this.x, this.vCenter);
      },
      centerCenter: function() {
        return new Point(this.hCenter, this.vCenter);
      },
      centerRight: function() {
        return new Point(this.right, this.vCenter);
      },
      bottomLeft: function() {
        return new Point(this.x, this.bottom);
      },
      bottomCenter: function() {
        return new Point(this.hCenter, this.bottom);
      },
      bottomRight: function() {
        return new Point(this.right, this.bottom);
      },
      locationIsZero: function() {
        return floatEq(this.x, 0) && floatEq(this.y, 0);
      },
      top: function() {
        return this.y;
      },
      left: function() {
        return this.x;
      },
      right: function() {
        return this.x + this.w;
      },
      bottom: function() {
        return this.y + this.h;
      },
      hCenter: function() {
        return this.x + this.w * .5;
      },
      vCenter: function() {
        return this.y + this.h * .5;
      },
      infinite: function() {
        return this.w === 2e308 || this.h === 2e308;
      },
      normalized: function() {
        var h, w, x, y;
        w = this.w;
        h = this.h;
        if (w >= 0 && h >= 0) {
          return this;
        } else {
          x = this.x;
          y = this.y;
          if (w < 0) {
            x += w;
            w = -w;
          }
          if (h < 0) {
            y += h;
            h = -h;
          }
          return this["with"](x, y, w, h);
        }
      },
      area: function() {
        return this.w * this.h;
      },
      corners: function() {
        var bottom, left, right, top;
        left = this.left;
        top = this.top;
        right = this.right;
        bottom = this.bottom;
        return [new Point(left, top), new Point(right, top), new Point(right, bottom), new Point(left, bottom)];
      }
    });

    Rectangle.prototype.withXY = function(x, y) {
      if (floatEq(x, this.x) && floatEq(y, this.y)) {
        return this;
      } else {
        return new Rectangle(x, y, this.w, this.h);
      }
    };

    Rectangle.prototype.withWH = function(w, h) {
      if (floatEq(w, this.w) && floatEq(h, this.h)) {
        return this;
      } else {
        return new Rectangle(this.x, this.y, w, h);
      }
    };

    Rectangle.prototype.withLocation = function(v) {
      return this.withXY(v.x, v.y);
    };

    Rectangle.prototype.withSize = function(v) {
      return this.withWH(v.x, v.y);
    };

    Rectangle.prototype.movedBy = function(d) {
      return this.withXY(this.x + d.x, this.y + d.y);
    };

    Rectangle.prototype.nearestInsidePoint = function(p) {
      return new Point(bound(this.left, p.x, this.right), bound(this.top, p.y, this.bottom));
    };

    Rectangle.prototype.largestInsideRect = function(ofSize) {
      var h, scaler, w;
      scaler = min(this.w / ofSize.w, this.h / ofSize.h);
      w = ofSize.w * scale;
      h = ofSize.h * scale;
      return new Rectangle((this.w - w) / 2, (this.h - h) / 2, w, h);
    };

    getLeftRightTopBottomPointAsDot = function(val) {
      var x, y;
      if (isPoint(val)) {
        x = val.x, y = val.y;
        return {
          left: x,
          right: x,
          top: y,
          bottom: y
        };
      } else if (isRect(val)) {
        return val;
      } else {
        throw new Error("Invalid arguments. Expecting Point or Rectangle. Got: " + val + ".");
      }
    };

    Rectangle.prototype.overlaps = function(val) {
      var bottom, left, ref1, right, top;
      if (val == null) {
        return false;
      }
      ref1 = getLeftRightTopBottomPointAsDot(val), left = ref1.left, right = ref1.right, top = ref1.top, bottom = ref1.bottom;
      if (floatEq(left, right) || floatEq(top, bottom)) {
        return floatGte(left, this.left) && floatGte(top, this.top) && floatLt(left, this.right) && floatLt(top, this.bottom);
      } else {
        return floatGt(right, this.left) && floatGt(bottom, this.top) && floatLt(left, this.right) && floatLt(top, this.bottom);
      }
    };

    Rectangle.prototype.contains = function(val) {
      var bottom, left, ref1, right, top;
      if (val == null) {
        return false;
      }
      ref1 = getLeftRightTopBottomPointAsDot(val), left = ref1.left, right = ref1.right, top = ref1.top, bottom = ref1.bottom;
      if (floatEq(left, right) || floatEq(top, bottom)) {
        return floatGte(left, this.left) && floatGte(top, this.top) && floatLt(left, this.right) && floatLt(top, this.bottom);
      } else {
        return floatGte(left, this.left) && floatGte(top, this.top) && floatLte(right, this.right) && floatLte(bottom, this.bottom);
      }
    };

    Rectangle.prototype.round = function(m) {
      var h, w, x, y;
      if (m == null) {
        m = 1;
      }
      x = round(this.x, m);
      y = round(this.y, m);
      w = round(this.x + this.w, m) - x;
      h = round(this.y + this.h, m) - y;
      return this["with"](x, y, w, h);
    };

    Rectangle.prototype.roundOut = function(m, k, expand) {
      var h, w, x, y;
      if (m == null) {
        m = 1;
      }
      if (k == null) {
        k = float32Precision;
      }
      if (expand == null) {
        expand = 0;
      }
      x = floor(this.x + k, m) - expand;
      y = floor(this.y + k, m) - expand;
      w = ceil(this.x + this.w - k, m) - x + 2 * expand;
      h = ceil(this.y + this.h - k, m) - y + 2 * expand;
      return this["with"](x, y, w, h);
    };

    Rectangle.prototype.roundIn = function(m, k) {
      var h, w, x, y;
      if (m == null) {
        m = 1;
      }
      if (k == null) {
        k = float32Precision;
      }
      x = ceil(this.x - k, m);
      y = ceil(this.y - k, m);
      w = floor(this.x + this.w + k, m) - x;
      h = floor(this.y + this.h + k, m) - y;
      return this["with"](x, y, w, h);
    };

    Rectangle.prototype.union = function(b) {
      var h, w, x, y;
      if (b == null) {
        return this;
      }
      if (this.getArea() <= 0) {
        return b;
      }
      x = min(this.x, b.left);
      y = min(this.y, b.top);
      w = max(this.getRight(), b.getRight()) - x;
      h = max(this.getBottom(), b.getBottom()) - y;
      return this["with"](x, y, w, h);
    };

    Rectangle.prototype.unionInto = function(into) {
      var _x, _y, area, h, intoArea, w, x, y;
      if (into == null) {
        return new Rectangle(this.x, this.y, this.w, this.h);
      }
      area = this.getArea();
      intoArea = into.getArea();
      if (area <= 0 || intoArea === 2e308) {
        return into;
      }
      if (intoArea <= 0 || area === 2e308) {
        into._setAll(this.x, this.y, this.w, this.h);
      } else {
        x = into.x, y = into.y, w = into.w, h = into.h;
        into._setAll(_x = min(x, this.x), _y = min(y, this.y), max(x + w, this.x + this.w) - _x, max(y + h, this.y + this.h) - _y);
      }
      return into;
    };

    Rectangle.prototype._intoOrWith = function(into, x, y, w, h) {
      if (into) {
        return into._setAll(x, y, w, h);
      } else {
        return this["with"](x, y, w, h);
      }
    };

    Rectangle.prototype._returnOrSaveInto = function(into, returnThisUnlessInto) {
      var h, w, x, y;
      if (into) {
        x = returnThisUnlessInto.x, y = returnThisUnlessInto.y, w = returnThisUnlessInto.w, h = returnThisUnlessInto.h;
        return this._intoOrWith(into, x, y, w, h);
      } else {
        return returnThisUnlessInto;
      }
    };

    Rectangle.prototype.intersectInto = function(into) {
      log.warn("DEPRICATED: use: intersection");
      return this.intersection(into, into);
    };

    Rectangle.prototype.intersect = function(rectB, into) {
      log.warn("DEPRICATED: use: intersection");
      return this.intersection(rectB, into);
    };


    /* intersection
      IN:
        rectB: anything that has these properties (or getters):
          left, right, top, bottom <Number>
        into: [optional]
          a Rectangle instance
    
      NOTE: All of these are OK! and work:
        this  == into
        rectB == into
        this  == rectB == into (though this is just a NOOP)
    
      EFFECT:
        if provided, into will be mutated to contain
        the result.
    
      OUT:
        if into?
          this will be the return value
          AND it will be MUTATED to contain the intersection x, y, w, h fields
        else
          if the intersection result didn't change anything,
            this
          else
            a new rectangle with the intersection result
     */

    Rectangle.prototype.intersection = function(rectB, into) {
      var _h, _w, _x, _y, areaA, areaB, fromH, fromW, fromX, fromY, ref1;
      fromX = this.x;
      fromY = this.y;
      fromW = this.w;
      fromH = this.h;
      areaA = fromW * fromH;
      areaB = (ref1 = rectB != null ? rectB.getArea() : void 0) != null ? ref1 : 2e308;
      if (areaB <= 0 || areaA === 2e308) {
        return this._returnOrSaveInto(into, rectB);
      } else if (areaA <= 0 || areaB === 2e308) {
        return this._intoOrWith(into, fromX, fromY, fromW, fromH);
      } else {
        _x = max(rectB.left, fromX);
        _y = max(rectB.top, fromY);
        _w = min(rectB.right, fromX + fromW) - _x;
        _h = min(rectB.bottom, fromY + fromH) - _y;
        if (_h <= 0 || _w <= 0) {
          return this._intoOrWith(into, 0, 0, 0, 0);
        } else {
          return this._intoOrWith(into, _x, _y, _w, _h);
        }
      }
    };

    Rectangle.prototype.grow = function(a, b) {
      var x, y;
      if (isPoint(a)) {
        x = a.x, y = a.y;
      } else {
        x = a;
        y = b != null ? b : a;
      }
      if (floatEq0(x) && floatEq0(y)) {
        return this;
      }
      return this["with"](this.x - x, this.y - y, this.w + 2 * x, this.h + 2 * y);
    };

    Rectangle.prototype.pad = function(a) {
      return this.grow(-a);
    };

    Rectangle.prototype.expand = function(a) {
      return this.grow(a);
    };

    Rectangle.nothing = (new Rectangle(0, 0, 0, 0)).freeze();

    Rectangle.everything = (new Rectangle(0, 0, 2e308, 2e308)).freeze();

    Rectangle.prototype.withRect = function(a, b, c, d) {
      return this["with"](a, b, c, d);
    };

    Rectangle.prototype.cutout = function(r) {
      var bottom, h, out, outX, rBottom, rRight, ref1, right, w, x, y;
      if (!this.overlaps(r)) {
        return [this];
      }
      ref1 = this, x = ref1.x, y = ref1.y, w = ref1.w, h = ref1.h, right = ref1.right, bottom = ref1.bottom;
      out = [];
      if (r.x > x) {
        out.push(new Rectangle(x, y, r.x - x, h));
      }
      if ((rRight = r.right) < right) {
        out.push(new Rectangle(rRight, y, right - rRight, h));
      }
      if (r.y > y) {
        out.push(new Rectangle(outX = max(r.x, x), y, min(rRight, right) - outX, r.y - y));
      }
      if ((rBottom = r.bottom) < bottom) {
        out.push(new Rectangle(outX = max(r.x, x), rBottom, min(rRight, right) - outX, bottom - rBottom));
      }
      return out;
    };

    return Rectangle;

  })(AtomicBase);

}).call(this);

//# sourceMappingURL=Rectangle.js.map
