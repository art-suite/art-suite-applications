// Generated by CoffeeScript 1.12.7
(function() {
  var Base, floatEq, inspect, inspectedObjectLiteral, isFunction, isNumber, isPlainArray, isPlainObject, isString, log, lowerCamelCase, numberToTightString, object, ref, stringToNumberArray, upperCamelCase, wordsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('art-standard-lib'), inspect = ref.inspect, log = ref.log, isNumber = ref.isNumber, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray, isString = ref.isString, isFunction = ref.isFunction, stringToNumberArray = ref.stringToNumberArray, lowerCamelCase = ref.lowerCamelCase, upperCamelCase = ref.upperCamelCase, inspectedObjectLiteral = ref.inspectedObjectLiteral, floatEq = ref.floatEq, wordsArray = ref.wordsArray, inspect = ref.inspect, object = ref.object, numberToTightString = ref.numberToTightString;

  module.exports = Base = (function(superClass) {
    var letterFieldNames, reservedWords;

    extend(Base, superClass);


    /*
    Base generates these standard methods:
    
      validate()
      clone()
      toArray()
      toObject()
    
      _initFromObject(o)
        IN: o: object mapping fieldNames to values
    
      interpolate(b, p, into)
        IN:
          b: <thisType>
          p: number between 0 and 1
          into: [optional] <thisType> MUTATED and returned, if provided
    
      builders & setters:
        _setAll(fieldList...)
          OUT: this
    
        _into(into, fieldList...)
          OUT: this
    
        with(fieldList...)
          OUT: this, if no changed, else new instance with fieldList values
    
         * defined for each individual field:
        @prototype["with#{FieldName}"] = (number) ->
    
      comparisons:
        methods:
          eq
          lt
          gt
          lte
          gte
          add
          sub
          mul
          div
    
        IN: (instance <thisType>) ->
        OR: (fieldList...) ->
    
        OUT: T/F
     */


    /*
    TODO
    
    All Atomics follow the same pattern:
    
      A fixed, ordered set of fields
      with fixed names
      and fixed defaults
    
    Most functions could be automatically defined given:
    
      An array of field-names
      An array of default values
      NOTE: I wish we could just use an object to specifiy those, but
        the order is not guaranteed, and we need a fixed order.
    
    The field-names could be defined with a string.
    Zero (0) can be the default default-value
    
    Point:      @defineAtomic fieldNames: "x y"
    Matrix:     @defineAtomic fieldNames: "sx shy tx shx sy ty", defaults: [1, 1]
    Rectangle:  @defineAtomic fieldNames: "x y w h"
    Perimeter:  @defineAtomic fieldNames: "left right top bottom"
    
    nonStandardInitializes
      Initializing with 1 arg or fields.length args is usually the same for all atomics
      But, intializing with a number of args in between tends to vary.
      I suggest overrides:
      _init0: -> defaults
      _init1: (a) -> all fields = a
      _init2:
      _init3:
      _init4:
      _init#{n}: -> each field gets set individually
    
    @defineAtomicClass: ({fieldNames, defaults, aliases}) ->
      fields = wordsArray fields if isString fields
      @defineSetAll()           # uses fieldNames
      @defineInit0()            # uses fieldNames and defaults
      @defineInit1()            # uses fieldNames
      @defineInterpolate()      # uses fieldNames
      @defineComparisonOperators()  # uses fieldNames, defines: eq, gt, lt, gte, lte
      @defineMathOperators()        # uses fieldNames, defines: add, sub, mul, div
      @defineToArray()          # uses fieldNames
      @defineInitFromObject()   # uses fieldNames and aliases
      @defineToObject()         # uses fieldNames
      @defineGetters()          # uses fieldNames and aliases
      @defineInto()             # uses fieldNames
      @defineToString()
      @defineInspect()
      @defineToInspectedObjects()
     */

    Base.prototype._initFromString = function(string) {
      return this._init.apply(this, stringToNumberArray(string));
    };

    function Base(a, b, c, d, e, f, g) {
      Base.__super__.constructor.apply(this, arguments);
      if (isPlainArray(a)) {
        this._init.apply(this, a);
      } else if (isString(a)) {
        this._initFromString(a);
      } else if (isPlainObject(a)) {
        this._initFromObject(a);
      } else if ((a != null) && !isNumber(a) && !(a instanceof Base) && isFunction(a.toString)) {
        this._initFromString(a.toString());
      } else {
        this._init(a, b, c, d, e, f, g);
      }
      this.validate();
    }

    Base.prototype.compare = function(b) {
      if (this.eq(b)) {
        return 0;
      }
      if (this.lte(b)) {
        return -1;
      }
      if (this.gte(b)) {
        return 1;
      }
      return 0/0;
    };

    Base.getConstructorFunctionName = function() {
      return this.constructorFunctionName || (this.constructorFunctionName = lowerCamelCase(this.getName()));
    };

    Base.getter({
      plainObjects: function() {
        return this.toObject();
      },
      inspectedObjects: function() {
        return inspectedObjectLiteral(this.inspectedObjectString);
      },
      inspectedObjectString: function() {
        var c, name, value;
        value = this.inspectedObjectInitializer;
        c = this["class"].getConstructorFunctionName();
        c += "(" + value + ")";
        if (name = this["class"].getNamedValuesByValue()[value]) {
          c += " '" + name + "'";
        }
        return c;
      },
      inspectedObjectInitializer: function() {
        var e;
        return ((function() {
          var j, len, ref1, results;
          ref1 = this.toArray();
          results = [];
          for (j = 0, len = ref1.length; j < len; j++) {
            e = ref1[j];
            results.push(numberToTightString(e, 10));
          }
          return results;
        }).call(this)).join(', ');
      },
      array: function() {
        return this.toArray();
      }
    });

    Base.namedValues = {};

    Base.getNamedValuesByValue = function() {
      var base, k, key, ref1, v;
      if (this._namedValuesByValue != null) {
        return this._namedValuesByValue;
      }
      this._namedValuesByValue = {};
      ref1 = this.namedValues;
      for (k in ref1) {
        v = ref1[k];
        key = v.inspectedObjectInitializer;
        if ((base = this._namedValuesByValue)[key] == null) {
          base[key] = k;
        }
      }
      return this._namedValuesByValue;
    };

    Base.prototype.toPlainStructure = function() {
      return this.getPlainObjects();
    };

    Base.prototype.toPlainEvalString = function() {
      return inspect(this.getPlainObjects());
    };

    Base.prototype.inspect = function() {
      return (this["class"].getConstructorFunctionName()) + "(" + (this.toArray().join(', ')) + ")";
    };

    Base.prototype.toJson = function() {
      return this.toString();
    };

    Base.prototype.toString = function(precision) {
      var a;
      if (precision) {
        return "[" + (((function() {
          var j, len, ref1, results;
          ref1 = this.toArray();
          results = [];
          for (j = 0, len = ref1.length; j < len; j++) {
            a = ref1[j];
            results.push(a.toPrecision(precision));
          }
          return results;
        }).call(this)).join(', ')) + "]";
      } else {
        return "[" + (this.toArray().join(', ')) + "]";
      }
    };

    Base.prototype.neq = function(b) {
      return !this.eq(b);
    };

    Base.prototype.between = function(a, b) {
      return this.gte(a) && this.lte(b);
    };

    Base.prototype.floatEq = floatEq;

    Base.prototype.isNumber = isNumber;


    /*
    for use by extending children classes
     */

    Base.defineAtomicClass = function(arg) {
      this.fieldNames = arg.fieldNames, this.constructorFunctionName = arg.constructorFunctionName;
      if (isString(this.fieldNames)) {
        this.fieldNames = wordsArray(this.fieldNames);
      }
      this.getConstructorFunctionName();
      this._defineCore(this.fieldNames);
      this._defineComparisonOperators(this.fieldNames);
      return this._defineMathOperators(this.fieldNames);

      /*
      TODO: more standard methods to add:
      
       * most init can be standardized
      _init*
      
       * more math methods
      min max floor ceil average bound round
      
       * class methods
      @isPoint
       */
    };

    reservedWords = {
      "with": true
    };

    Base._definePrototypeMethodViaEval = function(name, paramsList, body) {
      var nameInEval;
      nameInEval = reservedWords[name] ? "" : name;
      return this.prototype[name] = eval(body = "(function " + nameInEval + "(" + paramsList + ") {" + body + "})");
    };


    /*
    define: eq, lt, gt, lte, gt
    With these signatures:
    
       * provide numbers for all fields to compare
      myColor.eq r, g, b, a
    
       * provide another instance of @class to compare against
      myColor.eq myOtherColor
     */

    letterFieldNames = wordsArray("a b c d e f");

    Base._defineComparisonOperators = function(fieldNames) {
      var comparisonOperators, f, functionName, i, operator, params, paramsList, results;
      params = letterFieldNames.slice(0, fieldNames.length);
      paramsList = params.join(', ');
      this._definePrototypeMethodViaEval("eq", paramsList, "if (this === a) return true;\nif (this.isNumber(a)) {\n  return " + (((function() {
        var j, len, results;
        results = [];
        for (i = j = 0, len = fieldNames.length; j < len; i = ++j) {
          f = fieldNames[i];
          results.push("this.floatEq(this." + f + ", " + params[i] + ")");
        }
        return results;
      })()).join(" &&\n  ")) + ";\n} else {\n  return a &&\n  " + (((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = fieldNames.length; j < len; j++) {
          f = fieldNames[j];
          results.push("this.floatEq(this." + f + ", a." + f + ")");
        }
        return results;
      })()).join(" &&\n  ")) + ";\n}");
      comparisonOperators = {
        lt: "<",
        gt: ">",
        lte: "<=",
        gte: ">="
      };
      results = [];
      for (functionName in comparisonOperators) {
        operator = comparisonOperators[functionName];
        results.push(this._definePrototypeMethodViaEval(functionName, paramsList, "if (this.isNumber(a)) {\n  return " + (((function() {
          var j, len, results1;
          results1 = [];
          for (i = j = 0, len = fieldNames.length; j < len; i = ++j) {
            f = fieldNames[i];
            results1.push("this." + f + " " + operator + " " + params[i]);
          }
          return results1;
        })()).join(" &&\n  ")) + ";\n} else {\n  return a &&\n  " + (((function() {
          var j, len, results1;
          results1 = [];
          for (j = 0, len = fieldNames.length; j < len; j++) {
            f = fieldNames[j];
            results1.push("this." + f + " " + operator + " a." + f);
          }
          return results1;
        })()).join(" &&\n  ")) + ";\n}"));
      }
      return results;
    };


    /*
    define: add, sub, mul and div
    With these signatures:
    
      myColor.add r, g, b, a   # 4 numbers
    
      myColor.add myOtherColor, into # add by component
      myColor.add v, into            # one number to add to all
    
      into is optional. if set:
        it should be an instance of @class
        into is what is returned; a new instance of @class is not created
        into's field are set to the result
        NOTE: Atomic classes are designed to be used Pure-Functionally!
          SO, only use this if you created 'into' and you are not using it ANYWHERE else.
     */

    Base._defineMathOperators = function(fieldNames) {
      var f, functionName, i, mathOperators, operator, params, results;
      mathOperators = {
        add: "+",
        sub: "-",
        mul: "*",
        div: "/"
      };
      params = letterFieldNames.slice(0, fieldNames.length);
      results = [];
      for (functionName in mathOperators) {
        operator = mathOperators[functionName];
        results.push(this._definePrototypeMethodViaEval(functionName, params.join(', '), "if (this.isNumber(b)) {\n  return this._into(\n  null,\n  " + (((function() {
          var j, len, results1;
          results1 = [];
          for (i = j = 0, len = fieldNames.length; j < len; i = ++j) {
            f = fieldNames[i];
            results1.push("this." + f + " " + operator + " " + params[i]);
          }
          return results1;
        })()).join(",\n  ")) + "\n  );\n} else if (this.isNumber(a)) {\n  return this._into(\n  b,\n  " + (((function() {
          var j, len, results1;
          results1 = [];
          for (j = 0, len = fieldNames.length; j < len; j++) {
            f = fieldNames[j];
            results1.push("this." + f + " " + operator + " a");
          }
          return results1;
        })()).join(",\n  ")) + "\n  );\n} else {\n  return this._into(\n  b,\n  " + (((function() {
          var j, len, results1;
          results1 = [];
          for (j = 0, len = fieldNames.length; j < len; j++) {
            f = fieldNames[j];
            results1.push("this." + f + " " + operator + " a." + f);
          }
          return results1;
        })()).join(",\n  ")) + "\n  );\n}"));
      }
      return results;
    };

    Base._defineCore = function(fields) {
      var f, field, fieldList, j, len;
      fieldList = fields.join(', ');
      this._definePrototypeMethodViaEval("_into", "into, " + fieldList, "if (into === true)\n  into = this;\nelse\n  into = into || new this.class;\nreturn into._setAll(" + fieldList + ");");
      this._definePrototypeMethodViaEval("validate", "", ((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = fields.length; j < len; j++) {
          field = fields[j];
          results.push("if ((typeof this." + field + " != 'number') || isNaN(this." + field + ")) { throw new Error('" + field + " is not a number: ' + this." + field + "); }");
        }
        return results;
      })()).join(';\n'));
      this._definePrototypeMethodViaEval("_setAll", fieldList, (((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = fields.length; j < len; j++) {
          f = fields[j];
          results.push("this." + f + " = " + f);
        }
        return results;
      })()).join(";\n")) + ";\nreturn this;");
      this._definePrototypeMethodViaEval("_initFromObject", "o", "return this._init(" + (((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = fields.length; j < len; j++) {
          field = fields[j];
          results.push("o." + field + " || 0");
        }
        return results;
      })()).join(', ')) + ");");
      this._definePrototypeMethodViaEval("with", fieldList, "if (this.eq(" + fieldList + "))\n  return this;\nelse\n  return new this.class(" + fieldList + ");");
      this._definePrototypeMethodViaEval("clone", '', "return new this.class(" + (((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = fields.length; j < len; j++) {
          field = fields[j];
          results.push("this." + field);
        }
        return results;
      })()).join(',')) + ");");
      for (j = 0, len = fields.length; j < len; j++) {
        field = fields[j];
        this._definePrototypeMethodViaEval("with" + (upperCamelCase(field)), field, "return this.with(\n  " + (((function() {
          var l, len1, results;
          results = [];
          for (l = 0, len1 = fields.length; l < len1; l++) {
            f = fields[l];
            results.push(f === field ? f : "this." + f);
          }
          return results;
        })()).join(",\n  ")) + "\n);");
      }
      this._definePrototypeMethodViaEval("interpolate", "b, p, into", "var oneMinusP = 1 - p;\nreturn this._into(\ninto,\n" + (((function() {
        var l, len1, results;
        results = [];
        for (l = 0, len1 = fields.length; l < len1; l++) {
          f = fields[l];
          results.push("b." + f + " * p + this." + f + " * oneMinusP");
        }
        return results;
      })()).join(",\n")) + "\n);");
      this._definePrototypeMethodViaEval("toArray", "", "return [" + (((function() {
        var l, len1, results;
        results = [];
        for (l = 0, len1 = fields.length; l < len1; l++) {
          f = fields[l];
          results.push("this." + f);
        }
        return results;
      })()).join(", ")) + "];");
      return this._definePrototypeMethodViaEval("toObject", "", "return {" + (((function() {
        var l, len1, results;
        results = [];
        for (l = 0, len1 = fields.length; l < len1; l++) {
          f = fields[l];
          results.push(f + ": this." + f);
        }
        return results;
      })()).join(", ")) + "};");
    };

    return Base;

  })((require('art-class-system')).BaseClass);

}).call(this);

//# sourceMappingURL=Base.js.map
