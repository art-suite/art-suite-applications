// Generated by CoffeeScript 1.12.7
(function() {
  var Matrix, Point, describe, floatEq, identityMatrix, log, matrix, point, rect, ref;

  ref = require('./StandardImport'), describe = ref.describe, log = ref.log, floatEq = ref.floatEq, point = ref.point, rect = ref.rect, matrix = ref.matrix, Matrix = ref.Matrix, identityMatrix = ref.identityMatrix, Point = ref.Point;

  module.exports = describe({
    basic: function() {
      test("0-arg creation", function() {
        assert.equal(matrix().toString(), '[1, 1, 0, 0, 0, 0]');
        return assert.equal((new Matrix).toString(), '[1, 1, 0, 0, 0, 0]');
      });
      test("6-arg creation", function() {
        return assert.equal(matrix(1, 2, 3, 4, 5, 6).toString(), '[1, 2, 3, 4, 5, 6]');
      });
      test("scale is pure functional", function() {
        var m1, m2;
        m1 = matrix(1, 2, 3, 4, 5, 6);
        m2 = m1.scaleXY(10, 100);
        return assert.deepEqual(m1, matrix(1, 2, 3, 4, 5, 6));
      });
      test("inspectX", function() {
        var m1;
        m1 = matrix(1, 2, 3, 4, 5, 6);
        assert.eq(m1.inspectX(), "x + 3y + 5");
        assert.eq(m1.inspectX("foo"), "foo.x + 3 * foo.y + 5");
        assert.eq(matrix(2.1, 0, .5, 0, .1, 0).inspectX(), "2.1x + .5y + .1");
        assert.eq(matrix(0, 0, 0, 0, 0, 0).inspectX(), "0");
        assert.eq(matrix(0, 2, 3, 4, 5, 6).inspectX(), "3y + 5");
        assert.eq(matrix(1, 2, 0, 4, 5, 6).inspectX(), "x + 5");
        assert.eq(matrix(1, 2, 3, 4, 0, 6).inspectX(), "x + 3y");
        assert.eq(matrix(-1, 0, 1, 0, 0, 0).inspectX(), "-x + y");
        assert.eq(matrix(0, 0, 1, 0, -1, 0).inspectX(), "y - 1");
        return assert.eq(matrix(1, 0, -1, 0, 0, 0).inspectX(), "x - y");
      });
      test("inspectY", function() {
        var m1;
        m1 = matrix(1, 2, 3, 4, 5, 6);
        assert.eq(m1.inspectY(), "2y + 4x + 6");
        assert.eq(m1.inspectY("foo"), "2 * foo.y + 4 * foo.x + 6");
        assert.eq(matrix(0, 2.1, 0, .5, 0, .1).inspectY(), "2.1y + .5x + .1");
        assert.eq(matrix(0, 0, 0, 0, 0, 0).inspectY(), "0");
        assert.eq(matrix(1, 0, 3, 4, 5, 6).inspectY(), "4x + 6");
        assert.eq(matrix(1, 2, 1, 0, 5, 6).inspectY(), "2y + 6");
        assert.eq(matrix(1, 2, 3, 4, 1, 0).inspectY(), "2y + 4x");
        assert.eq(matrix(0, -1, 0, 1, 0, 0).inspectY(), "-y + x");
        assert.eq(matrix(0, 0, 0, 1, 0, -1).inspectY(), "x - 1");
        return assert.eq(matrix(0, 1, 0, -1, 0, 0).inspectY(), "y - x");
      });
      test("scaleXY", function() {
        return assert.deepEqual(matrix(1, 2, 3, 4, 5, 6).scaleXY(10, 100), matrix(10, 200, 30, 400, 50, 600));
      });
      test("rotate is pure functional", function() {
        var m;
        m = matrix();
        m.rotate(10);
        return assert.deepEqual(m, matrix(1, 1, 0, 0, 0, 0));
      });
      test("rotate 0", function() {
        return assert.eq(Matrix.rotate(0), identityMatrix);
      });
      test("rotate pi/2", function() {
        return assert.eq(Matrix.rotate(Math.PI / 2), matrix(0, 0, -1, 1, 0, 0));
      });
      test("rotate pi", function() {
        return assert.eq(Matrix.rotate(Math.PI), matrix(-1, -1, 0, 0, 0, 0));
      });
      test("rotate 3*pi/2", function() {
        return assert.eq(Matrix.rotate(3 * Math.PI / 2), matrix(0, 0, 1, -1, 0, 0));
      });
      test("rotate 2*pi", function() {
        return assert.eq(Matrix.rotate(2 * Math.PI), identityMatrix);
      });
      test("translate", function() {
        return assert.eq(Matrix.translateXY(2, 3), matrix(1, 1, 0, 0, 2, 3));
      });
      test("translate by 1,0", function() {
        return assert.eq(Matrix.translateXY(1, 0), matrix(1, 1, 0, 0, 1, 0));
      });
      test("translate by 0,0", function() {
        return assert.eq(Matrix.translateXY(0, 0), identityMatrix);
      });
      test("translate by 0", function() {
        return assert.eq((new Matrix).translate(0), identityMatrix);
      });
      test("Matrix.translate vs Matrix.translateXY", function() {
        assert.eq(Matrix.translateXY(123, 456), Matrix.translateXY(123, 456));
        assert.eq(Matrix.translateXY(123, 456), Matrix.translate(point(123, 456)));
        return assert.eq(Matrix.translate(point(123, 456)), Matrix.translate(point(123, 456)));
      });
      test("Matrix.scale vs Matrix.scaleXY", function() {
        assert.eq(Matrix.scaleXY(123, 456), Matrix.scaleXY(123, 456));
        assert.eq(Matrix.scaleXY(123, 456), Matrix.scale(point(123, 456)));
        return assert.eq(Matrix.scale(point(123, 456)), Matrix.scale(point(123, 456)));
      });
      test("Matrix.rotate vs Matrix.rotate", function() {
        return assert.eq(Matrix.rotate(1), Matrix.rotate(1));
      });
      test("inverted identity matrix is the identity matrix", function() {
        return assert.eq(identityMatrix, identityMatrix.invert());
      });
      test("invert translate", function() {
        return assert.eq(Matrix.translate(point(2, 3)).invert(), matrix(1, 1, 0, 0, -2, -3));
      });
      test("invert scale", function() {
        return assert.eq(Matrix.scale(point(2, 5)).invert(), matrix(0.5, 0.2, 0, 0, 0, 0));
      });
      test("invert rotate", function() {
        var m1, m2;
        m1 = Matrix.rotate(Math.PI / 2).invert();
        m2 = Matrix.rotate(-Math.PI / 2);
        return assert.eq(m1, m2);
      });
      test("clone constructor", function() {
        var m1, m2;
        m1 = matrix(2, 3, 5, 7, 11, 13);
        m2 = new Matrix(m1);
        m1.sx = 100;
        return assert.equal("" + m2, "[2, 3, 5, 7, 11, 13]");
      });
      test("mul", function() {
        var m1, m2, m3;
        m1 = Matrix.scaleXY(2, 3);
        m2 = Matrix.translateXY(5, 7);
        m3 = m1.mul(m2);
        assert.equal("" + m3, "[2, 3, 0, 0, 5, 7]");
        m3 = m2.mul(m1);
        return assert.equal("" + m3, "[2, 3, 0, 0, 10, 21]");
      });
      test("invert & mul itself == idenity", function() {
        var m;
        m = Matrix.scaleXY(2, 3);
        assert.eq(identityMatrix, m.inv.mul(m));
        m = Matrix.rotate(3 * Math.PI / 4);
        assert.eq(identityMatrix, m.inv.mul(m));
        m = Matrix.translateXY(7, 11);
        return assert.eq(identityMatrix, m.inv.mul(m));
      });
      test("div by itself == identity", function() {
        var m;
        m = Matrix.scaleXY(2, 3);
        assert.eq(identityMatrix, m.div(m));
        m = Matrix.rotate(3 * Math.PI / 4);
        assert.eq(identityMatrix, m.div(m));
        m = Matrix.translateXY(7, 11);
        return assert.eq(identityMatrix, m.div(m));
      });
      test("transform", function() {
        var m, p;
        m = Matrix.translateXY(5, 7).scaleXY(2, 3);
        p = m.transformXY(2, 3);
        return assert.eq(point("" + p), point(14, 30));
      });
      test("set from string", function() {
        var m;
        m = matrix("1, 2, 3,         4,5, 6");
        return assert.equal("" + m, "[1, 2, 3, 4, 5, 6]");
      });
      test("exactScale identity matrix", function() {
        var m;
        m = new Matrix;
        assert.eq(m.exactScaler, 1);
        return assert.floatEq(m.exactScaler, m.exactScale.average());
      });
      test("exactScale rotated matrix", function() {
        var m;
        m = Matrix.rotate(Math.PI / 4);
        assert.floatEq(m.exactScaler, 1);
        return assert.floatEq(m.exactScaler, m.exactScale.average());
      });
      test("exactScale scaled, rotated matrix", function() {
        var m;
        m = Matrix.scale(1.5).rotate(Math.PI / 4);
        assert.floatEq(m.exactScaler, 1.5);
        return assert.floatEq(m.exactScaler, m.exactScale.average());
      });
      test("transformVector", function() {
        var a, b, d, dControl, m, ta, tb;
        a = point(2, 3);
        b = point(5, 7);
        m = Matrix.translateXY(11, 13).scaleXY(17, 19).rotate(23);
        ta = m.transform(a);
        tb = m.transform(b);
        dControl = ta.sub(tb);
        d = m.transformVector(a.sub(b));
        return assert.eq(dControl, d);
      });
      return test("interpolate 0, .5 and 1", function() {
        var m1, m2;
        m1 = new Matrix();
        m2 = new Matrix(3, 5, 6, 8, 10, 12);
        assert.eq(m1.interpolate(m2, 0), m1);
        assert.eq(m1.interpolate(m2, 1), m2);
        return assert.eq(m1.interpolate(m2, .5), new Matrix(2, 3, 3, 4, 5, 6));
      });
    },
    inverseTransform: function() {
      var testInverseTransform;
      testInverseTransform = function(matrix) {
        return test("" + matrix, function() {
          var k, p, ref1;
          ref1 = Point.namedPoints;
          for (k in ref1) {
            p = ref1[k];
            assert.eq(matrix.inv.transform(p), matrix.inverseTransform(p), "point: " + p);
          }
          return void 0;
        });
      };
      testInverseTransform(identityMatrix);
      testInverseTransform(Matrix.translate(10));
      testInverseTransform(Matrix.translate(-10));
      testInverseTransform(Matrix.translateXY(10, -10));
      testInverseTransform(Matrix.rotate(Math.PI / 4));
      testInverseTransform(Matrix.scale(10));
      testInverseTransform(Matrix.scale(1 / 10));
      return testInverseTransform(Matrix.scale(1 / 10).rotate(Math.PI / 4).translateXY(10, -10));
    },
    into: function() {
      var doChain;
      doChain = function(into) {
        var m, n;
        m = new Matrix;
        n = m.translate(10, into);
        n = n.scale(10, into);
        n = n.rotate(3, into);
        n = n.invert(into);
        n = n.add(identityMatrix, into);
        n = n.sub(identityMatrix, into);
        n = n.mul(1, into);
        n = n.div(1, into);
        return {
          first: m,
          last: n
        };
      };
      test("into = true, i.e. @, returns @", function() {
        var first, last, ref1;
        ref1 = doChain(true), first = ref1.first, last = ref1.last;
        return assert.equal(first, last);
      });
      test("into = false, returns new matrix", function() {
        var first, last, ref1;
        ref1 = doChain(false), first = ref1.first, last = ref1.last;
        return assert.notEqual(first, last);
      });
      return test("into = new Matrix, returns passed in matrix", function() {
        var first, into, last, ref1;
        into = new Matrix;
        ref1 = doChain(into), first = ref1.first, last = ref1.last;
        assert.notEqual(first, last);
        return assert.equal(into, last);
      });
    },
    transformBoundingRect: function() {
      test("transformBoundingRect translation", function() {
        var m, r;
        m = Matrix.translateXY(100, 200);
        r = m.transformBoundingRect(rect(10, 20, 45, 50));
        return assert.eq(r, rect(110, 220, 45, 50));
      });
      test("transformBoundingRect scale", function() {
        var m, r;
        m = Matrix.scale(2).translateXY(100, 200);
        r = m.transformBoundingRect(rect(10, 20, 45, 50));
        return assert.eq(r, rect(120, 240, 90, 100));
      });
      test("transformBoundingRect rotation", function() {
        var m, r;
        m = Matrix.translateXY(100, 100).rotate(Math.PI / 4);
        r = m.transformBoundingRect(rect(10, 10, 50, 50));
        return assert.eq(rect("" + (r.round())), rect(-35, 156, 70, 70));
      });
      test("transformBoundingRect rotation2", function() {
        var m, r;
        m = Matrix.rotate(.01).translateXY(10, 200);
        r = m.transformBoundingRect(rect(10, 100, 50, 150));
        return assert.eq(rect("" + (r.round())), rect(17, 300, 52, 151));
      });
      return test("transformBoundingRect PI rotation", function() {
        var m, r;
        m = Matrix.translateXY(100, 100).rotate(Math.PI);
        r = m.transformBoundingRect(rect(10, 10, 50, 50));
        return assert.eq(r.round(), rect(-160, -160, 50, 50));
      });
    }
  });

}).call(this);

//# sourceMappingURL=Matrix.test.js.map
