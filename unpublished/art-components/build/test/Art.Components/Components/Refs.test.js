"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["test", "Component", "assert", "TestElement", "Object"], [global, require('../StandardImport')], (test, Component, assert, TestElement, Object) => {test("refs", function() {let rr, br, MyComponent, c; rr = null; br = null; MyComponent = Caf.defClass(class MyComponent extends Component {}, function(MyComponent, classSuper, instanceSuper) {this.prototype.render = function() {return TestElement(rr = TestElement({key: "redRectangle", draw: "red"}), br = TestElement({key: "blueRectangle", draw: "blue"}));};}); (c = MyComponent())._instantiate(); assert.eq(true, c.refs.redRectangle === rr); return assert.eq(true, c.refs.blueRectangle === br);}); test("duplicate refs warning", function() {let rr, br, MyComponent, c; rr = null; br = null; MyComponent = Caf.defClass(class MyComponent extends Component {}, function(MyComponent, classSuper, instanceSuper) {this.prototype.render = function() {return TestElement({}, rr = TestElement({key: "redRectangle", draw: "red"}), br = TestElement({key: "redRectangle", draw: "blue"}));};}); (c = MyComponent())._instantiate(); return c.refs;}); test("refs should not reach into sub-components", function() {let SubComponent, MyComponent, c; SubComponent = Caf.defClass(class SubComponent extends Component {}, function(SubComponent, classSuper, instanceSuper) {this.prototype.render = function() {return TestElement({key: "inSubcomponent"});};}); MyComponent = Caf.defClass(class MyComponent extends Component {}, function(MyComponent, classSuper, instanceSuper) {this.prototype.render = function() {return TestElement(SubComponent({key: "subComponentInParent"}), TestElement({key: "inParent"}));};}); (c = MyComponent())._instantiate(); assert.eq(Object.keys(c.refs).sort(), ["inParent", "subComponentInParent"]); return assert.eq(Object.keys(c.refs.subComponentInParent.refs), ["inSubcomponent"]);}); return test("refs to children passed to component should be bound to the component they are rendered in", function() {let rr, br, Wrapper, MyComponent, myComponent, wrapper; rr = null; br = null; Wrapper = Caf.defClass(class Wrapper extends Component {}, function(Wrapper, classSuper, instanceSuper) {this.prototype.render = function() {return TestElement({key: "wrapper"}, this.props.children);};}); MyComponent = Caf.defClass(class MyComponent extends Component {}, function(MyComponent, classSuper, instanceSuper) {this.prototype.render = function() {return Wrapper({key: "wrapperComponentRenderedInMyComponent"}, rr = TestElement({key: "redRectangle", draw: "red"}), br = TestElement({key: "blueRectangle", draw: "blue"}));};}); (myComponent = MyComponent({key: "myComponentRenderedManually"}))._instantiate(); wrapper = myComponent._virtualSubtree; assert.eq(myComponent, wrapper.renderedIn, "myComponent is the renderedIn for wrapper"); assert.eq(wrapper, wrapper._virtualSubtree.renderedIn, "wrapper is the renderedIn for it's top-most TestElement"); assert.eq(wrapper, wrapper.findFirstElement("redRectangle").renderedIn, "instantiate: wrapper is the renderedIn for TestElement-redRectangle - because it is rendered first in myComponent and then cloned in wrapper"); assert.eq(Object.keys(myComponent._virtualSubtree.refs).sort(), ["blueRectangle", "redRectangle", "wrapper"]); assert.eq(Object.keys(myComponent.refs).sort(), ["blueRectangle", "redRectangle", "wrapperComponentRenderedInMyComponent"]); assert.eq(true, myComponent.refs.redRectangle === rr); return assert.eq(true, myComponent.refs.blueRectangle === br);});});});
//# sourceMappingURL=Refs.test.js.map
