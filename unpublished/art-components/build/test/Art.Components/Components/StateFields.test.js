"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["chainedTest", "test", "assert", "Component", "TestElement"], [global, require('../StandardImport')], (chainedTest, test, assert, Component, TestElement) => {let testAllFooValues, testAllFooValuesOnNextReady; testAllFooValues = function(instance, expectedFooValue, context = "unknown context") {let expected; expected = {foo: expectedFooValue}; assert.selectedEq(expected, instance, `getter: ${Caf.toString(context)}`); assert.selectedEq(expected, instance.state, `state-prop: ${Caf.toString(context)}`); return assert.selectedEq(expected, instance.element.props, `concrete-element-prop: ${Caf.toString(context)}`);}; testAllFooValuesOnNextReady = function(instance, expectedFooValue) {return instance.onNextReady().then(() => testAllFooValues(instance, expectedFooValue));}; chainedTest("basicStateField", function() {let MyComponent, instance; MyComponent = Caf.defClass(class MyComponent extends Component {}, function(MyComponent, classSuper, instanceSuper) {this.stateFields({foo: "fooValue"}); this.prototype.render = function() {return TestElement({foo: this.foo});};}); (instance = MyComponent())._instantiate(); testAllFooValues(instance, "fooValue"); return instance;}).tapTest(["@foo = :barValue", function(instance) {instance.foo = "barValue"; testAllFooValues(instance, "fooValue"); return testAllFooValuesOnNextReady(instance, "barValue");}], ["@setFoo :bazValue", function(instance) {instance.setFoo("bazValue"); return testAllFooValuesOnNextReady(instance, "bazValue");}], ["@clearFoo()", function(instance) {instance.clearFoo(); return testAllFooValuesOnNextReady(instance, null);}]); chainedTest("booleanStateField", function() {let MyComponent, instance; MyComponent = Caf.defClass(class MyComponent extends Component {}, function(MyComponent, classSuper, instanceSuper) {this.stateFields({foo: false}); this.prototype.render = function() {return TestElement({foo: this.foo});};}); (instance = MyComponent())._instantiate(); testAllFooValues(instance, false); return instance;}).tapTest(["@foo = true", function(instance) {instance.foo = true; testAllFooValues(instance, false, "only updated next epoch"); return testAllFooValuesOnNextReady(instance, true);}], ["@foo = any-truthy-value becomes true", function(instance) {instance.foo = "hi"; return testAllFooValuesOnNextReady(instance, true);}], ["@foo = any-falsy-value becomes true", function(instance) {instance.foo = null; return testAllFooValuesOnNextReady(instance, false);}], ["@setFoo true", function(instance) {instance.setFoo(true); return testAllFooValuesOnNextReady(instance, true);}], ["@clearFoo() => false", function(instance) {instance.clearFoo(); return testAllFooValuesOnNextReady(instance, false);}], ["@triggerFoo() => true", function(instance) {instance.triggerFoo(); return testAllFooValuesOnNextReady(instance, true);}], ["@triggerFoo(anything-even-if-falsy) => true", function(instance) {instance.triggerFoo(false); return testAllFooValuesOnNextReady(instance, true);}]); return test("and mixins", function() {let FooMixin, MyComponent1, MyComponent2, c; FooMixin = (superClass) => {let Foo; return Foo = Caf.defClass(class Foo extends superClass {}, function(Foo, classSuper, instanceSuper) {this.abstractClass(); this.stateFields({foo: "foo"});});}; MyComponent1 = Caf.defClass(class MyComponent1 extends FooMixin(Component) {}, function(MyComponent1, classSuper, instanceSuper) {this.stateFields({bar: "bar"}); this.prototype.render = function() {return TestElement();};}); MyComponent2 = Caf.defClass(class MyComponent2 extends FooMixin(Component) {}, function(MyComponent2, classSuper, instanceSuper) {this.stateFields({baz: "baz"}); this.prototype.render = function() {return TestElement();};}); c = MyComponent1(); assert.eq({}, c.state); assert.eq(c._instantiate().state, {foo: "foo", bar: "bar"}); c = MyComponent2(); assert.eq({}, c.state); return assert.eq(c._instantiate().state, {foo: "foo", baz: "baz"});});});});
//# sourceMappingURL=StateFields.test.js.map
