"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "chainedTest", "Component", "TestElement", "TestOtherElement", "assert"], [global, require('../StandardImport')], (describe, chainedTest, Component, TestElement, TestOtherElement, assert) => {return describe({illegalUpdates: {rootComponentStillCantChangeRootElement: function() {return chainedTest(() => {let Foo; Foo = Caf.defClass(class Foo extends Component {}, function(Foo, classSuper, instanceSuper) {this.stateFields({useMain: true}); this.prototype.render = function() {return this.useMain ? TestElement() : TestOtherElement();};}); return Foo()._instantiate().onNextReady();}).tapTest(["initial render", (foo) => assert.eq(foo._virtualSubtree.element.elementType, "TestElement")], ["setup for alt render", (foo) => {foo.clearUseMain(); return foo.onNextReady();}], ["alt render didn't change", (foo) => assert.eq(foo._virtualSubtree.element.elementType, "TestElement")]);}, nonRootComponentsCantChangeTheirRootElementIfGloballyRoot: function() {return chainedTest(() => {let NonRootComponent, RootComponent; NonRootComponent = Caf.defClass(class NonRootComponent extends Component {}, function(NonRootComponent, classSuper, instanceSuper) {this.stateFields({useMain: true}); this.prototype.render = function() {return this.useMain ? TestElement() : TestOtherElement();};}); RootComponent = Caf.defClass(class RootComponent extends Component {}, function(RootComponent, classSuper, instanceSuper) {this.prototype.render = function() {return NonRootComponent();};}); return RootComponent()._instantiate().onNextReady();}).tapTest(["initial render", (foo) => assert.eq(foo._virtualSubtree.element.elementType, "TestElement")], ["setup for alt render", (foo) => {let nonRoot; ([nonRoot] = foo.find("NonRootComponent")); assert.exists(nonRoot); nonRoot.clearUseMain(); return foo.onNextReady();}], ["alt render didn't change", (foo) => assert.eq(foo._virtualSubtree.element.elementType, "TestElement")]);}}, legalUpdates: {typeChangeOnNonGlobalRootOk: function() {return chainedTest(() => {let NonRootComponent, RootComponent; NonRootComponent = Caf.defClass(class NonRootComponent extends Component {}, function(NonRootComponent, classSuper, instanceSuper) {this.stateFields({useMain: true}); this.prototype.render = function() {return this.useMain ? TestElement({name: "alice"}) : TestOtherElement({name: "bill"});};}); RootComponent = Caf.defClass(class RootComponent extends Component {}, function(RootComponent, classSuper, instanceSuper) {this.prototype.render = function() {return TestElement(NonRootComponent());};}); return RootComponent()._instantiate().onNextReady().then((rootComponent) => {return {rootComponent};});}).tapTest(["initial render", ({rootComponent}) => assert.eq(rootComponent._virtualSubtree.element.inspectedObjects, {ConcreteTestElement: {children: [{ConcreteTestElement: {props: {name: "alice"}}}]}})], ["setup for alt render", ({rootComponent}) => {let nonRootComponent; ([nonRootComponent] = rootComponent.find("NonRootComponent")); assert.exists(nonRootComponent); nonRootComponent.clearUseMain(); return rootComponent.onNextReady();}], ["alt render didn't change", ({rootComponent}) => assert.eq(rootComponent._virtualSubtree.element.inspectedObjects, {ConcreteTestElement: {children: [{ConcreteTestOtherElement: {props: {name: "bill"}}}]}}, "rootComponent's _virtualSubtree.element.elementType")]);}, keyChangeResultsInNewConcreteElement: function() {return chainedTest(() => {let NonRootComponent, RootComponent; NonRootComponent = Caf.defClass(class NonRootComponent extends Component {}, function(NonRootComponent, classSuper, instanceSuper) {this.stateFields({useMain: true}); this.prototype.render = function() {return TestElement({key: this.useMain ? "alice" : "bill"});};}); RootComponent = Caf.defClass(class RootComponent extends Component {}, function(RootComponent, classSuper, instanceSuper) {this.prototype.render = function() {return TestElement(NonRootComponent());};}); return RootComponent()._instantiate().onNextReady();}).thenTest("initial render", (rootComponent) => {return {rootComponent, concreteElement: rootComponent._virtualSubtree.element.children[0]};}).tapTest(["setup for alt render", ({rootComponent}) => {let nonRootComponent; ([nonRootComponent] = rootComponent.find("NonRootComponent")); assert.exists(nonRootComponent); nonRootComponent.clearUseMain(); return rootComponent.onNextReady();}], ["alt render resulted in new concrete element", ({rootComponent, concreteElement}) => assert.true(concreteElement !== rootComponent._virtualSubtree.element.children[0], "old and new concrete elements should be different objects when key changes")]);}}});});});
//# sourceMappingURL=RootElementUpdates.test.js.map
