"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["chainedTest", "assert", "Component", "TestElement"], [global, require('../StandardImport')], (chainedTest, assert, Component, TestElement) => {let testAllFooValues, testAllFooValuesOnNextReady; testAllFooValues = function(instance, expectedFooValue, context = "unknown context") {let expected; expected = {foo: expectedFooValue}; assert.selectedEq(expected, instance.state, `state-prop: ${Caf.toString(context)}`); return assert.selectedEq(expected, instance.element.props, `concrete-element-prop: ${Caf.toString(context)}`);}; testAllFooValuesOnNextReady = function(instance, expectedFooValue, context) {return instance.onNextReady().then(() => testAllFooValues(instance, expectedFooValue, context));}; return chainedTest("basicStateField", function() {let MyComponent, instance; MyComponent = Caf.defClass(class MyComponent extends Component {}, function(MyComponent, classSuper, instanceSuper) {this.prototype.render = function() {return TestElement({foo: this.state.foo});};}); (instance = MyComponent())._instantiate(); testAllFooValues(instance, undefined); return instance;}).tapTest(["@setState :foo :barValue", function(instance) {let foo; foo = instance.state.foo; instance.setState("foo", "barValue"); testAllFooValues(instance, foo, "not updated until next epoch"); return testAllFooValuesOnNextReady(instance, "barValue", "should update now");}], ["@setState foo: :bazValue", function(instance) {let foo; foo = instance.state.foo; instance.setState({foo: "bazValue"}); testAllFooValues(instance, foo, "not updated until next epoch"); return testAllFooValuesOnNextReady(instance, "bazValue", "should update now");}], ["@setState (state) -> foo: state.foo + :Bam >> transforms applied at epoch-update", function(instance) {let foo; foo = instance.state.foo; instance.setState((state) => {return {foo: state.foo + "Bam"};}); instance.setState((state) => {return {foo: state.foo + "Boom"};}); testAllFooValues(instance, foo, "not updated until next epoch"); return testAllFooValuesOnNextReady(instance, `${Caf.toString(foo)}BamBoom`, "should update now");}], ["@setState (state) -> bar: 123 >> fully replaces state", function(instance) {let foo; foo = instance.state.foo; instance.setState((state) => {return {bar: 123};}); testAllFooValues(instance, foo, "not updated until next epoch"); return testAllFooValuesOnNextReady(instance, undefined, "should update now");}]);});});
//# sourceMappingURL=State.test.js.map
