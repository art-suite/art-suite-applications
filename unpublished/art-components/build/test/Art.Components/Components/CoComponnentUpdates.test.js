"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["chainedTest", "assert", "Component", "TestElement", "Counters"], [global, require('../StandardImport')], (chainedTest, assert, Component, TestElement, Counters) => {let testThree, assertAllInitial; testThree = function(parent, child, parentStateString, childPropString, childStateString) {assert.eq(parent.state, {parentProp: parentStateString}, `parent state.parentProp should be ${Caf.toString(parentStateString)}`); assert.eq(child.props, {parentProp: childPropString}, `child props.parentProp should be ${Caf.toString(childPropString)}`); return assert.eq(child.state, {childProp: childStateString}, `child state.childProp should be ${Caf.toString(childStateString)}`);}; return chainedTest(function() {let ChildComponent, ParentComponent; ChildComponent = Caf.defClass(class ChildComponent extends Component {}, function(ChildComponent, classSuper, instanceSuper) {this.stateFields({childProp: "childValue1"}); this.prototype.render = function() {return TestElement({name: "childComponentsElement"}, this.state, this.props);};}); ParentComponent = Caf.defClass(class ParentComponent extends Component {}, function(ParentComponent, classSuper, instanceSuper) {this.stateFields({parentProp: "parentValue1"}); this.prototype.render = function() {return ChildComponent(this.state);};}); return {ParentComponent, ChildComponent};}).thenTest("instantiate", function({ChildComponent, ParentComponent}) {let child, parent; child = (parent = ParentComponent())._instantiate().find(/childComponent/i)[0]; return {ChildComponent, ParentComponent, parent, child};}).tapTest(["initial state", assertAllInitial = function({parent, child}) {return testThree(parent, child, "parentValue1", "parentValue1", "childValue1");}], ["update parent only", function({parent, child}) {parent.setParentProp("parentValue2"); assertAllInitial({parent, child}); return parent.onNextReady(() => testThree(parent, child, "parentValue2", "parentValue2", "childValue1"));}], ["update parent childOnly", function({parent, child}) {child.setChildProp("childValue2"); testThree(parent, child, "parentValue2", "parentValue2", "childValue1"); return parent.onNextReady(() => testThree(parent, child, "parentValue2", "parentValue2", "childValue2"));}], ["update both, parent-first", function({parent, child}) {parent.setParentProp("parentValue3"); child.setChildProp("childValue3"); testThree(parent, child, "parentValue2", "parentValue2", "childValue2"); return parent.onNextReady(() => testThree(parent, child, "parentValue3", "parentValue3", "childValue3"));}], ["update both, child-first", function({parent, child}) {Counters.reset(); child.setChildProp("childValue4"); parent.setParentProp("parentValue4"); testThree(parent, child, "parentValue3", "parentValue3", "childValue3"); return parent.onNextReady(() => {testThree(parent, child, "parentValue4", "parentValue4", "childValue4"); return assert.eq(2, Counters.componentsUpdated, "should only take 2 updates to updated 2 components, even if their updates were triggered out-of-order");});}]);});});
//# sourceMappingURL=CoComponnentUpdates.test.js.map
