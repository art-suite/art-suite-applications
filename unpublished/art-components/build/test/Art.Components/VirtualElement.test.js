"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "test", "TestElement", "VirtualElement", "assert", "TestOtherElement"], [global, require('./StandardImport')], (describe, test, TestElement, VirtualElement, assert, TestOtherElement) => {return describe({nonInstantiated: function() {test("empty", () => {let ve; ve = TestElement(); ve instanceof VirtualElement; assert.eq(ve.props, {}); assert.eq(ve.children, []); return assert.doesNotExist(ve.element);}); test("withProps", () => {let ve; ve = TestElement({foo: "bar"}); assert.eq(ve.props, {foo: "bar"}); assert.eq(ve.children, []); return assert.doesNotExist(ve.element);}); test("twoSetsOfProps", () => {let a; a = TestElement({a: 1}, {b: 2}); return assert.eq(a.props, {a: 1, b: 2});}); test("withChildren", () => {let ve; ve = TestElement(TestElement()); assert.eq(ve.props, {}); assert.eq(ve.children.length, 1); return assert.doesNotExist(ve.element);}); test("withChildrenStructure", () => {let a; a = TestElement({name: "parent"}, false ? TestElement({name: "child1"}) : undefined, TestElement({name: "child2"}), [null, TestElement({name: "child3"}), false, TestElement({name: "child4"})]); return assert.eq(["child2", "child3", "child4"], Caf.array(a.children, (child) => child.props.name));}); return test("intermingledPropsAndChildren", () => {let a; a = TestElement({a: 1}, TestElement({name: "child1"}), {b: 2}, TestElement({name: "child2"})); assert.eq(a.props, {a: 1, b: 2}); return assert.eq(["child1", "child2"], Caf.array(a.children, (child) => child.props.name));});}, instantiate: function() {test("instantiate VirtualElement with props", () => {let a; a = TestElement({size: 123})._instantiate({}); assert.eq(a.element.elementType, "TestElement"); return assert.eq(a.element.props.size, 123);}); return test("instantiate VirtualElement with children", () => {let element; ({element} = TestElement({name: "parent"}, TestElement({name: "child1"}), TestElement({name: "child2"}))._instantiate({})); return assert.eq(["child1", "child2"], Caf.array(element.children, (child) => child.props.name));});}, _canUpdateFrom: function() {test("_canUpdateFrom matching elementClasses >> true", () => {let a, b; a = TestElement({name: "foo"}); b = TestElement({name: "bar"}); return assert.eq(true, a._canUpdateFrom(b));}); test("_canUpdateFrom missmatched elementClasses >> false", () => {let a, b; a = TestElement({name: "foo"}); b = TestOtherElement({name: "bar"}); return assert.eq(false, a._canUpdateFrom(b));}); return test("_canUpdateFrom missmatched keys >> false", () => {let a, b; a = TestElement({key: "foo"}); b = TestElement({key: "bar"}); return assert.eq(false, a._canUpdateFrom(b));});}, _updateFrom: function() {test("_updateFrom changed props", () => {let a; a = TestElement({name: "foo"})._instantiate({})._updateFrom(TestElement({name: "bar"})); return assert.eq(a.element.props.name, "bar");}); test("_updateFrom: same children reuses children's array and children's VitualElement instances", () => {let a, b, initialElements, initialChildren; a = TestElement({name: "foo"}, TestElement({name: "child1"}), TestElement({name: "child2"})); b = TestElement({name: "bar"}, TestElement({name: "child1"}), TestElement({name: "child2"})); a._instantiate({}); initialElements = Caf.array(a.children, (child) => child.element); initialChildren = a.children; a._updateFrom(b); assert.eq(a.element.props.name, "bar"); assert.ok(initialChildren === a.children); assert.eq(initialElements, Caf.array(a.children, (child) => child.element)); return assert.eq(["child1", "child2"], Caf.array(a.children, (child) => child.props.name));}); test("_updateFrom: children with only props changed reuses children's array and children's VitualElement instances", () => {let a, b, initialelements, initialChildren; a = TestElement({name: "foo"}, TestElement({name: "child1"}), TestElement({name: "child2"})); b = TestElement({name: "bar"}, TestElement({name: "child3"}), TestElement({name: "child4"})); a._instantiate({}); initialelements = Caf.array(a.children, (child) => child.element); initialChildren = a.children; a._updateFrom(b); assert.eq(a.element.props.name, "bar"); assert.ok(initialChildren === a.children); assert.eq(initialelements, Caf.array(a.children, (child) => child.element)); return assert.eq(["child3", "child4"], Caf.array(a.children, (child) => child.props.name));}); test("_updateFrom: children with keys can reuse with swapped order", () => {let a, b, element1, element2, initialChildren; a = TestElement({name: "foo"}, TestElement({key: "child1"}), TestElement({key: "child2"})); b = TestElement({name: "bar"}, TestElement({key: "child2"}), TestElement({key: "child1"})); a._instantiate({}); ([element1, element2] = Caf.array(a.children, (child) => child.element)); initialChildren = a.children; a._updateFrom(b); assert.eq(a.element.props.name, "bar"); assert.ok(initialChildren !== a.children); assert.eq(initialChildren.length, a.children.length); assert.eq([element2, element1], Caf.array(a.children, (child) => child.element)); return assert.eq(["child2", "child1"], Caf.array(a.children, (child) => child.props.key));}); test("_updateFrom: children without keys and same type won't swap order", () => {let a, b, element1, element2, initialChildren; a = TestElement({name: "foo"}, TestElement({name: "child1"}), TestElement({name: "child2"})); b = TestElement({name: "bar"}, TestElement({name: "child2"}), TestElement({name: "child1"})); a._instantiate({}); ([element1, element2] = Caf.array(a.children, (child) => child.element)); initialChildren = a.children; a._updateFrom(b); assert.eq(a.element.props.name, "bar"); assert.ok(initialChildren === a.children); assert.eq(initialChildren.length, a.children.length); assert.eq([element1, element2], Caf.array(a.children, (child) => child.element)); return assert.eq(["child2", "child1"], Caf.array(a.children, (child) => child.props.name));}); test("_updateFrom: children without keys but different types can swap order", () => {let a, b, element1, element2, initialChildren; a = TestElement({name: "foo"}, TestElement({name: "child1"}), TestOtherElement({name: "child2"})); b = TestElement({name: "bar"}, TestOtherElement({name: "child2"}), TestElement({name: "child1"})); a._instantiate({}); ([element1, element2] = Caf.array(a.children, (child) => child.element)); initialChildren = a.children; a._updateFrom(b); assert.eq(a.element.props.name, "bar"); assert.ok(initialChildren !== a.children); assert.eq(initialChildren.length, a.children.length); assert.eq([element2, element1], Caf.array(a.children, (child) => child.element)); return assert.eq(["child2", "child1"], Caf.array(a.children, (child) => child.props.name));}); test("_updateFrom: add child", () => {let a, b; a = TestElement({name: "foo"}, TestElement({name: "child1"})); b = TestElement({name: "bar"}, TestElement({name: "child1"}), TestElement({name: "child2"})); a._instantiate({})._updateFrom(b); return assert.eq(["child1", "child2"], Caf.array(a.children, (child) => child.props.name));}); return test("_updateFrom: remove child", () => {let a, b; a = TestElement({name: "foo"}, TestElement({name: "child1"}), TestElement({name: "child2"}), TestElement({name: "child3"})); b = TestElement({name: "bar"}, TestElement({name: "child1"}), TestElement({name: "child3"})); a._instantiate({})._updateFrom(b); return assert.eq(["child1", "child3"], Caf.array(a.children, (child) => child.props.name));});}});});});
//# sourceMappingURL=VirtualElement.test.js.map
