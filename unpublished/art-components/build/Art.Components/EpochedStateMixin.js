"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["isString", "isFunction", "Epoch", "merge", "log"], [global, require('./StandardImport'), require('art-epoched-state'), {Counters: require('./Counters')}], (isString, isFunction, Epoch, merge, log) => {let emptyState; emptyState = {}; return function(baseClass) {let EpochedStateMixin; return EpochedStateMixin = Caf.defClass(class EpochedStateMixin extends require('./StateFieldsMixin')(baseClass) {constructor() {super(...arguments); this.state = emptyState; this._wasInstantiated = false; this._epochUpdateQueued = false;};}, function(EpochedStateMixin, classSuper, instanceSuper) {let defaultPreprocessState, _autoEpoch; this._emptyState = {}; this.prototype.setState = function(a, b) {let newState, testState, _state, from, into, temp; return isString(a) ? this._setSingleState(a, b) : (newState = a) ? (isFunction(newState) ? this._queueUpdate(newState) : (testState = this.state, _state = null, (from = newState, into = from, (from != null) ? (() => {for (let k1 in from) {let v, k; v = from[k1]; k = k1; temp = (this._pendingState || testState[k] !== v) ? (_state != null ? _state : _state = this._getStateToSet(), _state[k] = v) : undefined;}; return temp;})() : undefined, into)), this) : undefined;}; this.prototype.onNextReady = function(f, forceEpoch = true) {return this.getEpoch().onNextReady(f, forceEpoch, this);}; this.prototype.preprocessState = defaultPreprocessState = function(newState) {return newState;}; _autoEpoch = null; this.getter({epoch: function() {return _autoEpoch != null ? _autoEpoch : _autoEpoch = new Epoch;}}); this.prototype.processEpoch = function() {this.state = this._preprocessState(this._resolvePendingStateUpdates(), false); return this._epochUpdateQueued = false;}; this.prototype._instantiateState = function() {let stateAfterPossibleSetState, stateFields, emptyStateFields, haveStateFields, haveStateFromSetState; stateAfterPossibleSetState = this.state; stateFields = this.getStateFields(); emptyStateFields = this.class.emptyStateFields; haveStateFields = stateFields !== emptyStateFields; haveStateFromSetState = stateAfterPossibleSetState !== emptyState; this.state = emptyState; this.state = this._preprocessState((() => {switch (false) {case !(haveStateFields && haveStateFromSetState): return merge(stateFields, stateAfterPossibleSetState); case !haveStateFields: return stateFields; case !haveStateFromSetState: return stateAfterPossibleSetState; default: return emptyState;};})(), true); return this._wasInstantiated = true;}; this.prototype._preprocessState = function(state, firstCall) {let error; if (defaultPreprocessState === this.preprocessState) {return state;}; return (() => {try {return this.preprocessState(state, firstCall);} catch (error1) {error = error1; log.error({[this.class.name]: {error, instance: this}}); return state;};})();}; this.prototype._getStateToSet = function() {return this._wasInstantiated ? this._getPendingState() : ((this.state === emptyState) ? this.state = {} : undefined, this.state);}; this.prototype._setSingleState = function(stateKey, stateValue, callback) {if (this._pendingState || this.state[stateKey] !== stateValue) {this._getStateToSet()[stateKey] = stateValue;}; return stateValue;}; this.prototype._queueChangingComponentUpdates = function() {return !this._epochUpdateQueued ? (this._epochUpdateQueued = true, this.getEpoch().queueItem(this)) : undefined;}; this.prototype._getPendingState = function() {return this._pendingState || this._setPendingState({});}; this.prototype._setPendingState = function(pendingState) {this._queueChangingComponentUpdates(); return this._pendingState = pendingState;}; this.prototype._queueUpdate = function(updateFunction) {let temp; this._queueChangingComponentUpdates(); return (((temp = this._pendingUpdates) != null ? temp : this._pendingUpdates = [])).push(updateFunction);}; this.prototype._resolvePendingStateUpdates = function() {let oldState, newState, from, into, from1, into1, to, i; oldState = this.state; if (newState = this._pendingState) {from = oldState; into = newState; if (from != null) {for (let k1 in from) {let v, k; v = from[k1]; k = k1; if (newState[k] === undefined) {into[k1] = v;};};}; into; this._pendingState = null;}; if (this._pendingUpdates) {newState != null ? newState : newState = merge(oldState); from1 = this._pendingUpdates; into1 = from1; if (from1 != null) {to = from1.length; i = 0; while (i < to) {let updateFunction; updateFunction = from1[i]; newState = updateFunction.call(this, newState); i++;};}; into1; this._pendingUpdates = null;}; return newState != null ? newState : oldState;};});};});});
//# sourceMappingURL=EpochedStateMixin.js.map
