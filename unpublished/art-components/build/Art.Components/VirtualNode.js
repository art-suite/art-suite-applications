"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseClass", "objectKeyCount", "Error", "isFunction", "console", "isObject", "inspect", "propsEq"], [global, require('./StandardImport')], (BaseClass, objectKeyCount, Error, isFunction, console, isObject, inspect, propsEq) => {let ArtComponents, emptyObject, VirtualNode; ArtComponents = require("./namespace"); emptyObject = {}; return VirtualNode = Caf.defClass(class VirtualNode extends BaseClass {constructor(props) {super(...arguments); this._initVirtualNode(props);};}, function(VirtualNode, classSuper, instanceSuper) {this.virtualElementPoolEnabled = false; this.currentlyRendering = null; this.prototype._initVirtualNode = function(props) {this._resetVirtualNodeProps(); this._released = false; this._renderedIn = VirtualNode.currentlyRendering; this.props = this._rawProps = props != null ? props : props = emptyObject; return this.key = props.key;}; this.prototype._resetVirtualNodeProps = function() {this._released = true; this._propsLength = -1; return this._renderedIn = this._parentVirtualNode = this._parentComponent = this.key = this.props = this._rawProps = null;}; this.prototype._resetAllProps = function() {return this._resetVirtualNodeProps();}; this.prototype.findFirstElement = function(pattern, options) {let found; found = this.findElements(pattern, options); return Caf.exists(found) && found[0];}; this.getter("rawProps", "reusable", "parentComponent", "renderedIn", {inspectedName: function() {return `VirtualNode<${Caf.toString(this.key)}>`;}, inspectedNameAndId: function() {return `${Caf.toString(this.inspectedName)}-${Caf.toString(this.uniqueId)}`;}, inspectedPath: function() {let temp, base; return ((temp = Caf.exists(base = this.parentComponent) && base.inspectedPathName) != null ? temp : "");}, inspectedPathName: function() {return this.inspectedPath + "/" + this.inspectedName;}, parentVirtualElement: function() {let base; return (this._parentVirtualNode instanceof ArtComponents.VirtualElement) ? this._parentVirtualNode : Caf.exists(base = this._parentVirtualNode) && base.parentVirtualElement;}, propsLength: function() {return (this._propsLength >= 0) ? this._propsLength : this._propsLength = objectKeyCount(this.props);}}); this.setter({propsLength: function(v) {return this._propsLength = v;}}); this.prototype.eachInComponent = function(f) {return f(this);}; this.prototype.checkin = function() {}; this.prototype.release = function() {if (this._released) {throw new Error(`VirtualNode.release: already released ${Caf.toString(this.inspectedNameAndId)}`);}; if (this._parentComponent === this._renderedIn) {this._resetAllProps(); this.checkin();}; return this;}; this.prototype.testMatchesPattern = function(pattern, testString) {return isFunction(pattern) ? !!pattern(this) : (testString != null ? testString : this.inspectedName).match(pattern);}; this.prototype._validateChildren = function(children) {let from, into, to, i; if (!children) {return children;}; from = children; into = from; if (from != null) {to = from.length; i = 0; while (i < to) {let child; child = from[i]; if (!(child instanceof VirtualNode)) {console.warn({"invalid VirtualNode child": child, parent: this}); if (isObject(child)) {console.warn("Hint: Did you place properties AFTER a child element?");}; throw new Error(`VirtualNode child is not a VirtualNode.\ninvalid child: ${Caf.toString(inspect(child))}\nparent: ${Caf.toString(this.inspectedName)}`);}; i++;};}; into; return children;}; this.prototype._propsChanged = function(virtualNode) {let newProps, _propsLength, from, into; newProps = virtualNode._rawProps; _propsLength = 0; from = this._rawProps; into = from; if (from != null) {for (let k1 in from) {let v, k; v = from[k1]; k = k1; _propsLength++; if (!propsEq(v, newProps[k])) {return true;};};}; into; return (this._propsLength = _propsLength) !== virtualNode.getPropsLength();}; this.prototype._updateFrom = function(sourceNode) {}; this.prototype._canUpdateFrom = function(sourceNode) {return false;}; this.prototype._instantiate = function(_parentComponent, _parentVirtualNode) {this._parentComponent = _parentComponent; this._parentVirtualNode = _parentVirtualNode; return this;};});});});
//# sourceMappingURL=VirtualNode.js.map
