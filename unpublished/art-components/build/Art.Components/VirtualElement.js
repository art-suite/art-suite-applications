"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["merge", "Counters", "Error", "log", "objectHasKeys", "toInspectedObjects", "Promise", "objectDiff", "propsEq", "startFrameTimer", "endFrameTimer"], [global, require('./StandardImport'), {Counters: require('./Counters')}], (merge, Counters, Error, log, objectHasKeys, toInspectedObjects, Promise, objectDiff, propsEq, startFrameTimer, endFrameTimer) => {let virtualElementPoolEnabled, VirtualNode, devMode, VirtualElement; ({virtualElementPoolEnabled} = VirtualNode = require('./VirtualNode')); devMode = require('./DevMode'); return VirtualElement = Caf.defClass(class VirtualElement extends VirtualNode {constructor(elementClassName, props, children) {Counters.virtualElementCreated(); super(props); this._initVirtualElement(elementClassName, props, children);};}, function(VirtualElement, classSuper, instanceSuper) {let emptyChildren, elementTemp, addedOrChanged, removed; this.abstractClass(); this.createVirtualElementFactories = function(elementClassNames) {return require('art-object-tree-factory').createObjectTreeFactories(merge(require('./Helpers').objectTreeFactoryOptions, {class: this}), elementClassNames, (elementClassName) => (props, children) => this._newVirtualElement(elementClassName, props, children));}; this._newVirtualElement = function(elementClassName, props, children) {return new this(elementClassName, props, children);}; this.prototype.init = function(elementClassName, props, children) {Counters.virtualElementReused(); this._initVirtualNode(props); this._initVirtualElement(elementClassName, props, children); return this;}; emptyChildren = []; this.prototype._initVirtualElement = function(elementClassName, props, children) {this._elementClassName = elementClassName; this._children = children != null ? children : emptyChildren; if (devMode) {this._validateChildren(children);}; return this._element = null;}; this.getter("elementClassName released element", {children: function() {if (!this._children) {throw new Error(log.warn(this._released ? `Critical Failure: VirtualElement<${Caf.toString(this.inspectedName)}-${Caf.toString(this.uniqueId)}> was released! Should not be accessing children!` : `Internal Failure: VirtualElement<${Caf.toString(this.inspectedName)}-${Caf.toString(this.uniqueId)}> has no children!`));}; return this._children;}, concreteChildren: function() {let from, into, to, i, temp; return (from = this._children, into = [], (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let child, element; child = from[i]; into.push((this.validateIsVirtualElement(child), element = child.element, (!element || element instanceof VirtualNode) ? (() => {throw new Error("VirtualElement: All children should be instantiated instances of VirtualNode.");})() : undefined, element)); temp = i++;}; return temp;})()) : undefined, into);}, inspectedName: function() {let key, elementClassName; ({key, elementClassName} = this); return `VirtualElement-${Caf.toString(elementClassName)}${Caf.toString(key ? "-" + key : "")}`;}, inspectedObjects: function() {let base; return {[this.elementClassName]: merge({key: (this.key != null) ? this.key : undefined, props: objectHasKeys(this.props) ? merge(this.props) : undefined, children: ((Caf.exists(base = this.children) && base.length) > 0) ? toInspectedObjects(this.children) : undefined})};}}); this.prototype.findElements = function(pattern, options, matches = []) {let foundMatch; if (foundMatch = this.testMatchesPattern(pattern)) {matches.push(this);}; if (!foundMatch || Caf.exists(options) && options.findAll) {Caf.each2(this.children, (child) => child.findElements(pattern, options, matches));}; return matches;}; this.prototype.eachInComponent = function(f) {instanceSuper.eachInComponent.apply(this, arguments); Caf.each2(this.children, (child) => child.eachInComponent(f)); return null;}; this.prototype._newElement = function(elementClassName, props, childElements) {return elementClassName;}; this.prototype._newErrorElement = function() {return this._newElement("ErrorElement");}; elementTemp = null; addedOrChanged = function(k, v) {return !(k === "children") ? elementTemp.setProperty(k, v) : undefined;}; removed = function(k, v) {return !(k === "children") ? elementTemp.resetProperty(k) : undefined;}; this.prototype._updateElementProps = function(newProps) {let out; elementTemp = this.element; try {out = this._updateElementPropsHelper(newProps, addedOrChanged, removed);} catch (error) {}; elementTemp = null; return out;}; this.prototype._setElementChildren = function(childElements) {return this.element.setChildren(childElements);}; this.prototype.withElement = function(f) {return new Promise((resolve) => resolve(f(this._element)));}; this.prototype.sendToElement = function(method, ...args) {return new Promise((resolve) => resolve(this._element[method](...args)));}; this.prototype._updateElementPropsHelper = function(newProps, addedOrChanged, removed) {let oldPropsLength, oldProps, noChangeCount, noChange, newPropsLength; oldPropsLength = this.getPropsLength(); oldProps = this.props; noChangeCount = 0; noChange = () => noChangeCount++; newPropsLength = this.setPropsLength(objectDiff(newProps, oldProps, addedOrChanged, removed, addedOrChanged, noChange, propsEq, oldPropsLength)); return (newPropsLength === noChangeCount && oldPropsLength === newPropsLength) ? false : (this.props = this._rawProps = newProps, true);}; this.prototype.clone = function() {return new VirtualElement(this.elementClassName, this.props, Caf.array(this.children, (child) => child.clone()));}; this.prototype._captureRefs = function(component) {let key; if (component === this.renderedIn) {if ((key = this.key) != null) {if (component._refs[key]) {log.warn(`Duplicate key ${Caf.toString(key)} found in ${Caf.toString(this.inspectedPath)}`);}; component._refs[key] = this;}; Caf.each2(this.children, (child) => child._captureRefs(component));}; return null;}; this.prototype._resetAllProps = function() {let from, into, to, i; Counters.virtualElementReleased(); this._resetVirtualNodeProps(); from = this._children; into = from; if (from != null) {to = from.length; i = 0; while (i < to) {let child; child = from[i]; child.release(); i++;};}; into; return this._elementClassName = this._children = null;}; this.prototype._unmount = function() {return Caf.each2(this.children, (child) => child._unmount());}; this.prototype._instantiate = function(parentComponent, parentVirtualNode) {let error, from, into, to, i, temp; if (parentComponent !== this._renderedIn && parentComponent && this._renderedIn) {return this.clone()._instantiate(parentComponent, parentVirtualNode);}; instanceSuper._instantiate.apply(this, arguments); Counters.virtualElementInstantiated(); startFrameTimer("acCreate"); this._element = (() => {try {return this._newElement(this.elementClassName, this.props, (from = this.children, into = [], (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let child, childIndex; child = from[i]; childIndex = i; into.push((this.children[childIndex] = child._instantiate(parentComponent, this)).element); temp = i++;}; return temp;})()) : undefined, into));} catch (error1) {error = error1; log.error({"VirtualElement._instantiate": {error, elementClassName: this.elementClassName, props: this.props}}); return this._newErrorElement();};})(); endFrameTimer(); if (!(this._element != null)) {throw new Error("VirtualElement._instantiate: no @_element");}; return this;}; this.prototype._canUpdateFrom = function(virtualElement) {return this.elementClassName === virtualElement.elementClassName && this.key === virtualElement.key;}; this.prototype._extractOldChildToUpdate = function(child) {return Caf.find(this.children, (oldChild, i) => (Caf.exists(oldChild) && oldChild._canUpdateFrom(child)) ? (this.children[i] = null, oldChild) : undefined);}; this.prototype._fastUpdateChildren = function(fromVirtualElement) {let newChildren, oldChildren, from, into, to, i1, from1, into1, to1, i2; newChildren = fromVirtualElement.children; oldChildren = this.children; if (!(oldChildren.length === newChildren.length)) {return false;}; from = oldChildren; into = from; if (from != null) {to = from.length; i1 = 0; while (i1 < to) {let oldChild, i; oldChild = from[i1]; i = i1; if (!oldChild._canUpdateFrom(newChildren[i])) {return false;}; i1++;};}; into; from1 = oldChildren; into1 = from1; if (from1 != null) {to1 = from1.length; i2 = 0; while (i2 < to1) {let oldChild, i; oldChild = from1[i2]; i = i2; oldChild._updateFrom(newChildren[i]); i2++;};}; into1; return true;}; this.prototype.validateIsVirtualElement = function(ve) {if (!(ve instanceof VirtualNode)) {log({self: this, ve}); throw new Error("Expecting ve to be a virtualElement");}; return ve;}; this.prototype._slowUpdateChildren = function(fromVirtualElement) {let oldChildren, newChildren, from, into, to, i, temp; oldChildren = this.children; newChildren = (from = fromVirtualElement.children, into = [], (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let newChild, oldChild; newChild = from[i]; into.push((oldChild = this._extractOldChildToUpdate(newChild)) ? oldChild._updateFrom(newChild) : newChild._instantiate(this._parentComponent, this)); temp = i++;}; return temp;})()) : undefined, into); Caf.each2(oldChildren, (child) => child._unmount(), (child) => child); this._children = newChildren; return this._updateConcreteChildren();}; this.prototype._releaseUnusedChildren = function(oldChildren) {}; this.prototype._updateConcreteChildren = function() {this._setElementChildren(this.concreteChildren); return this;}; this.prototype._updateChildren = function(fromVirtualElement) {return this._fastUpdateChildren(fromVirtualElement) ? false : (this._slowUpdateChildren(fromVirtualElement), true);}; this.prototype._updateFrom = function(fromVirtualElement) {let propsChanged, childrenChanged; if (!this._element) {throw new Error(`VirtualElement._updateFrom: ${Caf.toString(this.inspectedName)} no @_element`);}; if (fromVirtualElement._released) {log.error(`updating from released VirtualElement: ${Caf.toString(fromVirtualElement.inspectedName)}`);}; if (this.released) {log.error(`updating at released VirtualElement: ${Caf.toString(this.inspectedName)}`);}; if (fromVirtualElement === this) {throw new Error("_updateFrom self!!!");}; propsChanged = this._updateElementProps(fromVirtualElement.props); childrenChanged = this._updateChildren(fromVirtualElement); return this;};});});});
//# sourceMappingURL=VirtualElement.js.map
