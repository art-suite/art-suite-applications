"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["isFunction", "fastBind"], [global, require('./StandardImport')], (isFunction, fastBind) => {return function(superClass) {let InstanceFunctionBindingMixin; return InstanceFunctionBindingMixin = Caf.defClass(class InstanceFunctionBindingMixin extends superClass {constructor() {super(...arguments); this._boundFunctionList = null;};}, function(InstanceFunctionBindingMixin, classSuper, instanceSuper) {this.getFunctionsToBindList = function(hotReload) {return (!hotReload && this.hasOwnProperty("_functionsToBindList")) ? this._functionsToBindList : this._functionsToBindList = this._getFunctionsToBindList().sort();}; this.classGetter("boundFunctionList"); this.prototype.bindFunctionsToInstance = function(hotReload) {let functionsToBindList; this._removeUnboundFunctions(functionsToBindList = this.class.getFunctionsToBindList(hotReload)); this._bindFunctions(functionsToBindList); return this._boundFunctionList = functionsToBindList;}; this._getFunctionsToBindList = function() {let from, into, temp; return (from = this.prototype, into = [], (from != null) ? (() => {for (let k1 in from) {let v, k; v = from[k1]; k = k1; temp = (k !== "constructor" && (isFunction(v) && (this.propertyIsConcrete(k) && (!this.nonBindingFunctions || !(Caf.in(k, this.nonBindingFunctions)))))) ? into.push(k) : undefined;}; return temp;})() : undefined, into);}; this.prototype._bindFunctions = function(functionsToBindList) {let prototype, from, into, to, i, temp; prototype = this.class.prototype; return (from = functionsToBindList, into = from, (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let k, prototypeMethod; k = from[i]; this[k] = (prototypeMethod = prototype[k]) ? fastBind(prototypeMethod, this) : undefined; temp = i++;}; return temp;})()) : undefined, into);}; this.prototype._removeUnboundFunctions = function(functionsToBindList) {let from, into, to, i, temp; return (from = this._boundFunctionList, into = from, (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let k; k = from[i]; if (!(Caf.in(k, functionsToBindList))) {delete this[k];}; temp = i++;}; return temp;})()) : undefined, into);};});};});});
//# sourceMappingURL=InstanceFunctionBindingMixin.js.map
