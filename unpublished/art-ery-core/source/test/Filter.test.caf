import &StandardImport

ArtConfig.configure()

describe "filters" ->

  test "basic before filter" ->
    class MyPipeline extends Pipeline
      @handlers         hello: ({key}) -> "Hello, #{key}."
      @filter   before: hello: (request) -> request.withKey "" before-#{request.key}

    .myPipeline.hello :George
    .then (result) ->
      assert.eq result, "Hello, before-George."

  test "multiple before filters in one declaration" ->
    class MyPipeline extends Pipeline
      @handlers         hello: ({key}) -> "Hello, #{key}."
      @filter
        {} before: hello: (request) -> request.withKey "" before1-#{request.key}
        {} before: hello: (request) -> request.withKey "" before2-#{request.key}

    .myPipeline.hello :George
    .then (result) ->
      assert.eq result, "Hello, before2-before1-George."

  test "multiple before filters in separate declarations" ->
    class MyPipeline extends Pipeline
      @handlers         hello: ({key}) -> "Hello, #{key}."
      @filter before: hello: (request) -> request.withKey "" before1-#{request.key}
      @filter before: hello: (request) -> request.withKey "" before2-#{request.key}

    .myPipeline.hello :George
    .then (result) ->
      assert.eq result, "Hello, before2-before1-George."

  test "basic before all" ->
    {myPipeline} = class MyPipeline extends Pipeline
      @handlers
        hello:    ({key}) -> "Hello, #{key}."
        goodbye:  ({key}) -> "Goodbye, #{key}."
      @filters  before: all: (request) -> request.withKey "" before-#{request.key}

    myPipeline.hello :George
    .then (result) -> assert.eq result, "Hello, before-George."
    .then -> myPipeline.goodbye :George
    .then (result) -> assert.eq result, "Goodbye, before-George."

  test "basic after filter" ->
    class MyPipeline extends Pipeline
      @handlers         hello: ({key}) -> "Hello, #{key}."
      @filter   after:  hello: (response) -> response.withData "" #{response.data}-after

    .myPipeline.hello :George
    .then (result) -> assert.eq result, "Hello, George.-after"

describe "all beforeFilter response Types" ->

  test "request" ->
    class MyPipeline extends Pipeline
      @handlers         hello: ({key}) -> "Hello, #{key}."
      @filters  before: hello: (request) -> request.withKey :demon

    .myPipeline.hello :George
    .then (result) -> assert.eq result, "Hello, demon."

  test "response" ->
    class MyPipeline extends Pipeline
      @handlers         hello: ({key}) -> "Hello, #{key}."
      @filters  before: hello: (request) -> request.success data: :whatever

    .myPipeline.hello :George
    .then (result) -> assert.eq result, :whatever

  test "undefined" ->
    class MyPipeline extends Pipeline
      @handlers         hello: ({key}) -> "Hello, #{key}."
      @filters  before: hello: (request) ->

    .myPipeline.hello :George
    .then (result) -> assert.eq result, "Hello, George."

  test "null" ->
    class MyPipeline extends Pipeline
      @handlers         hello: ({key}) -> "Hello, #{key}."
      @filters  before: hello: (request) -> null

    assert.missing MyPipeline.myPipeline.hello :George

  test "string" ->
    class MyPipeline extends Pipeline
      @handlers         hello: ({key}) -> "Hello, #{key}."
      @filters  before: hello: (request) -> "bob"

    MyPipeline.myPipeline.hello :George
    .then (result) -> assert.eq result, :bob

  test "object" ->
    class MyPipeline extends Pipeline
      @handlers         hello: ({key}) -> "Hello, #{key}."
      @filters  before: hello: (request) -> name: "bob"

    MyPipeline.myPipeline.hello :George
    .then (result) -> assert.eq result, name: :bob

  test "invalid response" ->
    class MyPipeline extends Pipeline
      @handlers         hello: ({key}) -> "Hello, #{key}."
      @filters  before: hello: (request) -> MyPipeline

    assert.rejects MyPipeline.myPipeline.hello :George
    .then (error) -> assert.eq error.status, failure
