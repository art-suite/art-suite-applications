"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseClass", "isPlainObject", "objectWithout", "merge", "isString", "failure", "Error", "formattedInspect", "isJsonType", "validStatus", "success", "missing", "objectKeyCount", "toInspectedObjects", "push", "clientFailure", "clientFailureNotAuthorized", "Promise", "RequestError", "compactFlatten", "cleanStackTrace", "getDetailedRequestTracingExplanation", "getCleanStackTraceWarning"], [global, require('./StandardImport'), require('./Lib').Env, {Request: require('request')}], (BaseClass, isPlainObject, objectWithout, merge, isString, failure, Error, formattedInspect, isJsonType, validStatus, success, missing, objectKeyCount, toInspectedObjects, push, clientFailure, clientFailureNotAuthorized, Promise, RequestError, compactFlatten, cleanStackTrace, getDetailedRequestTracingExplanation, getCleanStackTraceWarning) => {let normalizeResponseOptions, Request; normalizeResponseOptions = function(status, responseOptions = {}) {let key, data, props, keyDataProps; return (() => {switch (false) {case !isPlainObject(responseOptions): key = responseOptions.key; data = responseOptions.data; props = responseOptions.props; return (key || data) ? (keyDataProps = (key && data) ? {key, data} : key ? {key} : {data}, responseOptions = objectWithout(responseOptions, "key", "data", "props"), responseOptions.props = props ? merge(props, keyDataProps) : keyDataProps, responseOptions.status = status, responseOptions) : merge(responseOptions, {status}); case !isString(responseOptions): return {status, data: {message: responseOptions}}; default: return {status: failure, data: {message: (responseOptions instanceof Error) ? `Internal Error: ArtEry.Request#toResponse received Error instance: ${Caf.toString(formattedInspect(responseOptions))}` : "Internal Error: ArtEry.Request#toResponse received unsupported type"}};};})();}; return Request = Caf.defClass(class Request extends BaseClass {constructor(options) {let temp; super(...arguments); this._pipeline = options.pipeline; this._type = options.type; this._status = options.status; this._previousRequest = options.previousRequest; this._props = (options.key || options.data) ? options.props ? merge(options.props, {key: options.key, data: options.data}) : (options.key && options.data) ? {key: options.key, data: options.data} : options.key ? {key: options.key} : {data: options.data} : ((temp = options.props) != null ? temp : {}); this.validate(options);};}, function(Request, classSuper, instanceSuper) {this.prototype.validate = function(options) {if (this.props != null && !isPlainObject(this.props)) {throw new Error(`Props must nullish or a plain object: ${Caf.toString(formattedInspect(this.props))}`);}; if (this.data != null && !isJsonType(this.data)) {throw new Error(`Data must nullish or a json value: ${Caf.toString(formattedInspect({data: this.data, options}))}`);}; if (this.key != null && !isJsonType(this.key)) {throw new Error(`Key must nullish or a json value: ${Caf.toString(formattedInspect({key: this.key, options}))}`);}; if (this.status && !validStatus(this.status)) {throw new Error(`invalid status: ${Caf.toString(formattedInspect(this.status))}`);}; if (!(isString(this.type) && this.type.length > 0)) {throw new Error("missing type");}; return !(this.pipeline != null) ? (() => {throw new Error("missing pipeline");})() : undefined;}; this.getter("previousRequest", "pipeline", "type", "props", "status", {key: function() {return this.props.key;}, data: function() {return this.props.data;}, originalRequest: function() {let temp, base; return ((temp = Caf.exists(base = this.previousRequest) && base.originalRequest) != null ? temp : this);}, request: function() {return this.isResponse ? this.previousRequest.request : this;}, optionsForClone: function() {return {pipeline: this.pipeline, type: this.type, props: this.props, status: this.status};}, isResponse: function() {return this.status != null;}, isSuccessful: function() {return this.status === success;}, isMissing: function() {return this.status === missing;}, notSuccessful: function() {return this.isResponse != null && !this.isSuccessful;}, responseProps: function() {return this.isResponse ? this.props : undefined;}, responseData: function() {return this.isResponse ? this.data : undefined;}, responseKey: function() {return this.isResponse ? this.key : undefined;}, requestProps: function() {return this.request.props;}, requestData: function() {return this.request.data;}, requestKey: function() {return this.request.key;}}); this.property("filter"); this.getter({pipelineName: function() {return this.pipeline.getName();}, pipelineAndType: function() {return `${Caf.toString(this.pipelineName)}.${Caf.toString(this.type)}`;}, requestString: function() {return (this.key != null) ? this.pipelineAndType + ` ${Caf.toString(formattedInspect(this.key))}` : this.pipelineAndType;}, simpleInspectedObjects: function() {let props, raw; props = objectWithout(this.props, "key", "data"); if (!(0 < objectKeyCount(props))) {props = null;}; raw = {[`${Caf.toString(this.isResponse ? "Response" : "Request")}`]: this.requestString, filter: this.filter, originatedOnServer: this.originatedOnServer, status: this.status, data: this.data, props, errorProps: this.errorProps}; return toInspectedObjects(Caf.object(raw, null, (v) => v != null));}, requestChain: function(appendTo = []) {let base; return push(this.previousRequest ? Caf.exists(base = this.previousRequest) && base.getRequestChain(appendTo) : [], this);}, inspectedObjects: function() {let base; return {[`Art.Ery.${Caf.toString(this.constructor.name)}`]: Caf.array(this.requestChain, (request) => request.simpleInspectedObjects)};}}); this.prototype.withKey = function(key) {return this.withMergedOptions({key});}; this.prototype.withData = function(data) {return this.withMergedOptions({data});}; this.prototype.withProps = function(props) {return this.withMergedOptions({props});}; this.prototype.withMergedOptions = function(options) {return new Request(merge(this.optionsForClone, options, {previousRequest: this}));}; this.prototype.success = function(responseOptions) {return this.toResponse(success, responseOptions);}; this.prototype.missing = function(responseOptions) {return this.toResponse(missing, responseOptions);}; this.prototype.clientFailure = function(responseOptions) {return this.toResponse(clientFailure, responseOptions);}; this.prototype.clientFailureNotAuthorized = function(responseOptions) {return this.toResponse(clientFailureNotAuthorized, responseOptions);}; this.prototype.failure = function(responseOptions) {return this.toResponse(failure, responseOptions);}; this.prototype.toResponse = function(status, responseOptions) {if (!isString(status)) {throw new Error("missing status");}; return Promise.resolve(responseOptions).then((responseOptions) => this.withMergedOptions(normalizeResponseOptions(status, responseOptions)));}; this.prototype.toPromise = function() {return this.isSuccessful ? Promise.resolve(this) : Promise.reject(this._getRejectionError());}; this.prototype._getRejectionError = function() {let exception, temp, temp1, temp2, base, base1, base2, base3, base4, from, into, i1, temp3; return ((temp = this._preparedRejectionError) != null ? temp : this._preparedRejectionError = new RequestError({message: compactFlatten([((temp1 = ((temp2 = Caf.exists(base = this.responseData) && base.message) != null ? temp2 : Caf.exists(base1 = this.responseProps) && base1.message)) != null ? temp1 : Caf.exists(base2 = this.errorProps) && (Caf.exists(base3 = base2.exception) && base3.message)), "", `request: ${Caf.toString(this.pipeline)}.${Caf.toString(this.type)}`, formattedInspect({status: this.status, session: this.session, props: this.requestProps})]).join("\n"), type: this.type, status: this.status, requestData: this.requestData, responseData: this.responseData, sourceLib: "ArtEry", response: this, stack: compactFlatten([(exception = Caf.exists(base4 = this.errorProps) && base4.exception) ? `Exception stack:\n${Caf.toString(cleanStackTrace(exception.stack, false, true))}\n` : undefined, (from = this.requestTrace, into = [], (from != null) ? (i1 = from.length - 1, (() => {while (i1 >= 0) {let time, request, context, name, stack, filterLog, i; ({time, request, context, name, stack, filterLog} = from[i1]); i = i1; into.push(`${Caf.toString(request)}: ${Caf.toString((filterLog != null) ? Caf.array(filterLog, ({name}) => name, ({name}) => name !== "created").join(" -> ") : `${Caf.toString(context)} ${Caf.toString(name)}`)} (request-depth: ${Caf.toString(i + 1)}, start-time: ${Caf.toString(time * 1000 | 0)}ms) ${Caf.toString(stack ? `\n${Caf.toString(cleanStackTrace(stack, null, true))}\n` : "")}`); temp3 = i1--;}; return temp3;})()) : undefined, into).join("\n"), getDetailedRequestTracingExplanation(), getCleanStackTraceWarning()]).join("\n")}));};});});});
//# sourceMappingURL=Request.js.map
