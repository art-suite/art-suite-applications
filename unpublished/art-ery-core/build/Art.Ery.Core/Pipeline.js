"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseClass", "isString", "isPlainObject", "Error", "formattedInspect", "merge", "isClass", "Filter", "inspect", "compactFlatten", "lowerCamelCase", "Promise", "isJsonType", "Request"], [global, require('./StandardImport'), {Filter: require('./Filter'), Request: require('./Request')}], (BaseClass, isString, isPlainObject, Error, formattedInspect, merge, isClass, Filter, inspect, compactFlatten, lowerCamelCase, Promise, isJsonType, Request) => {let normalizeRequestArgs, preprocessFilter, preprocessFilters, Pipeline; normalizeRequestArgs = function(a, b) {let key, options, optionsWithKey; if (isString(a)) {key = a; a = b; b = null;}; if (isPlainObject(a)) {options = a; a = b; b = null;}; if (a != null) {throw new Error(`Invalid argument: ${Caf.toString(formattedInspect(a))}`);}; return (key != null) ? (optionsWithKey = {key}, (options != null) ? merge(optionsWithKey, options) : optionsWithKey) : options != null ? options : {};}; preprocessFilter = function(filter) {return isClass(filter) ? new filter : (Caf.is(filter, Filter)) ? filter : isPlainObject(filter) ? new Filter(filter) : (() => {throw `invalid filter: ${Caf.toString(inspect(filter))} ${Caf.toString(filter instanceof Filter)}`;})();}; preprocessFilters = function(filters) {return Caf.array(compactFlatten(filters), (f) => preprocessFilter(f), (f) => f);}; return Pipeline = Caf.defClass(class Pipeline extends BaseClass {}, function(Pipeline, classSuper, instanceSuper) {this.abstractClass(); this.extendableProperty({handlers: {}, filters: []}); this.register = function() {return this.singletonClass();}; this.postCreateConcreteClass = function({hotReloaded}) {this._defineRequestMethods(); if (!hotReloaded) {this.register();}; return classSuper.postCreateConcreteClass.apply(this, arguments);}; this.getter({filterChain: function() {let chain, from, into, i, temp; return this._filterChain ? this._filterChain : (chain = [this], (from = this.filters, into = from, (from != null) ? (i = from.length - 1, (() => {while (i >= 0) {let filter; filter = from[i]; chain = [filter, chain]; temp = i--;}; return temp;})()) : undefined, into), chain);}, name: function() {let temp; return ((temp = this._name) != null ? temp : this._name = lowerCamelCase(this.class.name));}}); this.prototype.toString = function() {return this.name;}; this.filters = function(...filters) {return this.extendFilters(preprocessFilters(compactFlatten(filters)));}; this.filter = function(...filters) {return this.filters(filters);}; this.handler = function(handlers) {return this.handlers(handlers);}; this.prototype.handleRequest = function(request) {return Promise.then(() => {let handler; return (handler = this.handlers[request.type]) ? Promise.resolve(request).then(handler).then((result) => (() => {switch (false) {case !(result === null): return request.missing(); case !isJsonType(result): return request.success({data: result}); case !(Caf.is(result, Request) && result.isResponse): return result; default: return request.failure(`invalid handler result for '${Caf.toString(request.type)}': ${Caf.toString(formattedInspect(result))}`);};})()) : request.failure(`no handler for request: ${Caf.toString(formattedInspect({request}))}`);});}; this.prototype.createRequest = function(type, options) {return new Request(merge(options, {type, pipeline: this}));}; this.prototype._processRequest = function(type, a, b) {let options; return this._filterAndHandleRequest(this.createRequest(type, options = normalizeRequestArgs(a, b))).then((response) => response.toPromise(options)).then((successfulResponse) => options.returnResponse ? successfulResponse : successfulResponse.data);}; this.prototype._filterAndHandleRequest = function(request) {let firstHandler, remainingHandlers; ([firstHandler, remainingHandlers] = this.filterChain); return firstHandler.handleRequest(request, remainingHandlers);}; this._defineRequestMethod = function(requestType) {let temp, base; return ((temp = (base = this.prototype)[requestType]) != null ? temp : base[requestType] = function(a, b) {return this._processRequest(requestType, a, b);});}; this._defineRequestMethods = function() {return Caf.each2(this.getHandlers(), (handler, name) => this._defineRequestMethod(name));};});});});
//# sourceMappingURL=Pipeline.js.map
