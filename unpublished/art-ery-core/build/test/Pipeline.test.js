"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["test", "describe", "Pipeline", "assert", "Date", "merge", "log"], [global, require('./StandardImport')], (test, describe, Pipeline, assert, Date, merge, log) => {test("pipeline automatically has a singlton", function() {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}); return assert.present(MyPipeline.myPipeline);}); describe("handlers", function() {test("basic handler", () => {let MyPipeline; return (MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({hello: function() {return "Hello world.";}});})).myPipeline.hello().then((result) => assert.eq(result, "Hello world."));}); test("handler and that responds to a key", () => {let MyPipeline; return (MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({hello: function({key}) {return `Hello, ${Caf.toString(key)}.`;}});})).myPipeline.hello("Shane").then((result) => assert.eq(result, "Hello, Shane."));}); test("handler error on invalid argument", () => {let MyPipeline; MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({hello: function() {return "Hi";}});}); return assert.throws(() => MyPipeline.myPipeline.hello(new Date));}); test("handler with data payload", () => {let MyPipeline; return (MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({hello: function({data}) {return `Hello, ${Caf.toString(data.name)}.`;}});})).myPipeline.hello({data: {name: "Alice"}}).then((result) => assert.eq(result, "Hello, Alice."));}); test("handler with custom props", () => {let MyPipeline; return (MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({hello: function({props}) {return `Hello, ${Caf.toString(props.customProp)}.`;}});})).myPipeline.hello({customProp: "John"}).then((result) => assert.eq(result, "Hello, John."));}); return test("handler with key and data", () => {let MyPipeline; return (MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({hello: function({key, data}) {return {key, data};}});})).myPipeline.hello("John", {data: "Frank"}).then((result) => assert.eq(result, {key: "John", data: "Frank"}));});}); return describe("filters", function() {test("basic before filter", () => {let MyPipeline; return (MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({hello: function({key}) {return `Hello, ${Caf.toString(key)}.`;}}); this.filters({before: {hello: function(request) {return merge(request, {key: `before-${Caf.toString(request.key)}`});}}});})).myPipeline.hello("George").then((result) => assert.eq(result, "Hello, before-George."));}); return test("basic after filter", () => {let MyPipeline; return (MyPipeline = Caf.defClass(class MyPipeline extends Pipeline {}, function(MyPipeline, classSuper, instanceSuper) {this.handlers({hello: function({key}) {return `Hello, ${Caf.toString(key)}.`;}}); this.filter({after: {hello: function(request) {log({afterFilter: request}); return merge(request, {responseProps: {data: `${Caf.toString(request.responseProps.data)}-after`}});}}});})).myPipeline.hello("George").then((result) => assert.eq(result, "Hello, George.-after"));});});});});
//# sourceMappingURL=Pipeline.test.js.map
